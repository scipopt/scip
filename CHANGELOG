@page RN80 Release notes for SCIP 8.0

@section RN805 SCIP 8.1.0
*************************

Fixed bugs
----------

- fixed that scaling of rows in Gurobi interface (SCIPlpiScaleRow()) changed infinite sides to large finite ones (1e20) when scale factor is negative
- check whether objective limit is truly reached in SCIPlpiIsStable()
- if an objective limit is set and Mosek claims that it is exceeded, check that this is indeed the case in SCIPlpiIsStable()
- the .mps file reader was extended to additionally accept .mps files with the objective sense section on one line
- ensure that delayed cutpool separation does not happen if enough cuts have been found already
- fixed that a Gurobi or Mosek interface (LPI) could not be freed from a thread different than the one it was created in, which lead to problems when, e.g., using the concurrent optimizer
- in cons_varbound if both variables are fixed, instead of propagating the constraint check the feasibility of the constraint since propagating can lead to unnecessary numerical troubles
- fixed memory leak in branching rule "distribution"
- fixed that undercover did not enforce that sufficiently many variables in an and-constraints were fixed to have it linearized in the generated sub-scip
- fixed two bugs in cons_varbound: avoid adding variable bounds if vbdcoef is infinite and unlock/lock variables if lhs/rhs/vbdcoef are changed
- globalize constraint changes before bound changes during the effective root shift in treeSwitchPath() to correctly update variable locks by avoiding global bounds with outstanding bound change events when deleting constraints
- fixed error when attempting to copy SCIP with activated pricers
- remove integrality check for implicit integral variables in cons_integral.c, updated the definition for variable type implicit integer to be more explicit that these variables can take fractional values, and updated FAQ entry
- updated and, or, and pseudoboolean constraint handlers to better handle fractional implicit integer variables in enforcement
- avoid invalid strong Chvatal-Gomory cuts by ceiling with tolerance in the calculation of parameter k and flooring slack coefficients with standard epsilon tolerance as well as quad precision
- add missing row links to columns in SCIPflushRowExtensions() required to maintain correct row norms
- restrict separator intobj to solutions for which there can be no better feasible integral objective values to avoid cutting them off
- delay removal of clique lists from SCIPvarRemoveCliquesImplicsVbs() into cliqueCleanup() to avoid segmentation faults by incomplete cleanups after variable conversions
- reject sub-solutions with invalid objectives in SCIPtranslateSubSols() due to contradicting infinite contributions
- correct column index in getMinMaxActivityResiduals() to make presolver dualinfer work
- copy quiet flag from main scip's message handler to the one of solverscip in concurrent optimization
- avoid bound tightening cycles towards huge redundancy bounds in fullDualPresolve() to avert fatal numerical trouble in representing vertices of linear relaxations with unbounded domains
- fix problem where debug solution did not work if branching constraints are present
- update index of dominating variable on coefficient deletion in dualPresolving() of constraint handler logicor
- pass on flags from a redundant to the implying varbound constraint in preprocessConstraintPairs() to avoid suboptimal fixings by model relaxations
- apply reductions of dualinfer only if a dual solution exists (primal is bounded)
- before presolving is finished check solutions before retransforming them including tiny values to keep check flags consistent
- disable heuristics before and during presolving in benders decomposition to avoid messing up the objective structure in the solution store by dropping auxiliary variables in the required retransformations
- correct local flag of singleton conflict constraints in tightenSingleVar() against invalid bound globalization
- respect unboundedness in the computation of activity bounds in conflict.c to avoid invalid huge bounds due to small coefficients on unbounded variables
- ensure positive sides of a linear constraint when recognizing a set partition in rangedRowSimplify() to account for redundancy issues
- relax numerical conditions for variable aggregations to avert invalid variable fixings
- fixed harmless read of uninitialized data when creating parameters

Performance improvements
------------------------

- Use sassy/bliss as default symmetry computation package.

Interface changes
-----------------

### Interfaces to external software

- added interface to nauty/traces for symmetry computation
- added interface to sassy, a preprocessor for symmetry computation
- The directory src/sassy contains the source code of sassy.

Build system
------------

### Cmake

- added flag option "SYM=sbliss" for using sassy/bliss as a graph automorphism package

### Makefile

- added flag option "nauty" for SYM variable to specify which graph automorphism package should be used
- added flag option "sbliss" for SYM variable to specify which graph automorphism package should be used
- use SYM=sbliss by default, since sassy and bliss are now shipped with SCIP

Miscellaneous
-------------

- the parameter change callback is no longer called at the moment a parameter is created

@section RN804 SCIP 8.0.4
*************************

Features
--------

- use quad precision in cutsSubstituteMIR() for substituting slack variables into CMIR cuts
- use quad precision for activity computations in cons_linear.c

### Deleted and changed API methods

- SCIPshrinkDisjunctiveVarSet() no longer attempts to cutoff the current node if it finds the
  given disjunction to be infeasible; it is now in the responsibility of the caller to act accordingly

### New API functions

- added SCIPskipSpace
- added XML parser routines from src/xml/xml.h

### Interfaces to external software

- updated XPRESS interface to work with XPRESS 41 as well

### Changed parameters

- changed integer parameter "propagating/symmetry/recomputrestart" from range {0, 1, 2} to being fixed at value 0

Unit tests
----------

- added new checks for objective, bounds and sides inside the scaling tests in lpi/change.c

Fixed bugs
----------

- relax condition of assert in lpSolve to hold only if lp/checkstability is true
- OPB reader: dynamically increase the size of the line buffer for reading in getMaxAndConsDim()
- Enabled the solution limit checks in SCIPsolveIsStopped in solve.c when in SCIP_STAGE_PRESOLVING
- fix quad precision comparison for the calculation of knapsackcover constraints.
- force copying of symmetry constraints for concurrent solve
- increase the precision of double multiplications in quad precision environments
- corrected handling of different variable types in symmetry
- orbitope detection: refine computation of overlap structure and fixed bug in finding orbitope generators
- ensure that winner is always determined in concurrent mode
- when a row with invalid index range is added to the global cutpool, update the indices instead of failing with an assert
- update of watched literals in cons_xor.c and ensure that fixed variables are counted in propacateCons()
- avoid some numerical issue in check for redundant variables in linear constraints (introduced with version 8.0.2)
- more rows are treated as being integral in cutsSubstituteMIR() for CMIR cuts
- fixed several relaxations of the rhs of cuts to 0 in cuts.c
- avoid aggregation into a single linear constraint if they should not be upgraded (needed for indicator constraints)
- apply effective root changes before fork is repropagated during treeSwitchPath() in tree.c
- avoid invalid objective value for solutions generated from an unbounded LP relaxation in case of a nonlinear objective function
- disable recomputing symmetries after a restart (constraint removal is not permitted)
- avoid cutting off optimal solutions for small feasibility tolerances in conflict analysis
- initialize variable in presol_dualsparsify.c
- fix in presolving of variable bound constraints to use absolute instead of relative difference
- free variable histories in reoptimization mode
- handle whitespaces in interactive shell history consistently
- check and enforce equalities on which the objective is projected in cons_linear.c
- ensure row feasibilities of solution shiftings in heur_oneopt.c and heur_twoopt.c
- remove rounded row check blocking tolerable primal solutions in cons_varbound.c
- fixed that presolve of logicor-constraints may have attempted to cutoff a root of the not yet existing branch-and-bound tree
- only consider positive slack variables as active in benders.c
- in the feasibility check of and/or constraints, allow for fractional values in operands
- fixed linear outer-approximation for some composite absolute-value expressions

Miscellaneous
-------------

- Extended documentation of the parameter limits/solutions to point out that the limit is first checked in presolving
- Added more information about using SCIPcache- and SCIPflushRowExtensions() to documentation and comments
- Extended the `how to add' sections of the documentation by adding information on how to include default plugins into SCIP

@section RN803 SCIP 8.0.3
*************************

Examples and applications
-------------------------

- Externalize STP and PolySCIP applications

Interface changes
-----------------

### Command line interface

- When running the AMPL interface, the .nl filename extension does not need to be omitted for the input file anymore.

Build system
------------

### Cmake

- Forbid CMAKE_BUILD_TYPE nonstandard values
- Move -I/path/to/src/amplmp/include to front of compiler flags for include directories

### Makefile

Fixed bugs
----------

- fixed an incorrect handling of xor constraints
- the feasibility checker for integrality constraints now uses checkintegrality even for implied integers
- skip integrality check in cons_integral for relaxation-only implicit-integer variables
- fixed an issue caused by aggregated variables not added to a hashmap in the xor constraint handler
- changed function solveRowEchelonGF2 in cons_xor.c to avoid errors if rank is 0
- fixed that the implication presolver tried to aggregate or tighten bounds of multiaggregated variables
- fixed a sign check in detection of linear constraints that are parallel to the objective
- fixed bug in Clp and lpi_clp with missing basis information when calling the barrier with crossover; needs new Clp version
- do not assume aggregation is successful in cons_setppc.c

Miscellaneous
-------------

- Changed license to Apache 2.0, see https://www.apache.org/licenses/LICENSE-2.0.
- When an LP could not be solved accurately, scaling is now turned off as a last fall-back method.
- Methods for using the debug solution mechanism SCIPdebugAddSolVal, SCIPdebugGetSol, SCIPdebugGetSolVal,
  SCIPdebugSolIsValidInSubtree, SCIPdebugIsMainscip, SCIPdebugSolEnable, SCIPdebugSolDisable, SCIPdebugSolIsEnabled,
  SCIPwithDebugSol are now exported

Known bugs
----------

@section RN802 SCIP 8.0.2
*************************

Interface changes
-----------------

### Deleted and changed API methods

- added input parameter SCIP_Bool initiallp to SCIPcutselsSelect
- changed function type int to SCIP_Longint for SCIPcutpoolGetMaxNCuts
- replaced SCIPsepastoreGetNCutsFound with SCIPsepastoreGetNCutsAdded following the naming convention for the new statistics
- replaced SCIPsepaIncNAppliedCuts with SCIPsepaIncNCutsApplied

### New API functions

- added SCIPsepastoreGetNCutsAdded, SCIPsepastoreGetNCutsAddedViaPool, SCIPsepastoreGetNCutsAddedDirect
- added SCIPsepaIncNCutsAdded, SCIPsepaDecNCutsAdded, SCIPsepaIncNCutsApplied, SCIPsepaGetNRootCalls, SCIPsepaGetNCutsAdded, SCIPsepaGetNCutsAddedViaPool, SCIPsepaGetNCutsAddedDirect, SCIPsepaGetNCutsAppliedViaPool, SCIPsepaGetNCutsAppliedDirect
- added SCIPcutpoolGetNRootCalls, SCIPcutpoolGetNCutsAdded, SCIPcutpoolAddMaxNCuts, SCIPcutpoolSetTime, SCIPcutpoolAddNCalls, SCIPcutpoolAddNRootCalls, SCIPcutpoolAddNCutsFound, SCIPcutpoolAddNCutsAdded,
- added SCIPcutselGetNCalls, SCIPcutselGetNRootCalls, SCIPcutselGetNRootCuts, SCIPcutselGetNRootForcedCuts, SCIPcutselGetNRootCutsFiltered, SCIPcutselGetNLocalCuts, SCIPcutselGetNLocalForcedCuts, SCIPcutselGetNLocalCutsFiltered,

### Interfaces to external software

- Added compatibility with Mosek 10.0.18.

### New parameters

- new parameters to turn on more statistics: misc/showdivingstats (diving heuristics), heuristics/alns/shownbstats (ALNS), estimation/showstats (tree size estimation)

### Data structures

- added nrootcalls and ncutsadded to SCIP_Cutpool
- added fromcutpool flag to SCIP_Row and fixed 33 bit allocation
- added ncalls, nrootcalls, nrootcutsselected, nrootcutsforced, nrootcutsfiltered, nlocalcutsselected, nlocalcutsforced, nlocalcutsfiltered to SCIP_Cutsel
- added ncutsadded, ncutsaddedviapool, ncutsaddeddirect, ncutsappliedviapool, ncutsapplieddirect, nrootcalls to SCIP_Sepa
- added ncutsadded, ncutsaddedviapool, ncutsaddeddirect to SCIP_Sepastore
- fixed statistics of relaxators w.r.t. number of times conss/cuts were added

Build system
------------

### Cmake

- new option `-DAUTOBUILD` that configures scip with dependencies on availability.
  Packages like Ipopt, PaPILO, Readline, Zimpl, ZLIB, GMP, Worhp are automatically found and linked, otherwise ignored.
  The individual flags for these packages are ignored. This makes a quick build easier. It is by default set to off.

Fixed bugs
----------

- read objective offset from ZIMPL files
- Make sure that objective limit is disabled if not all variables are in the LP. If we would run into
  an objective limit in this case, the results of the LP solver are unclear.
- fixed bug in reopt.c, which occured for bounds outside of current valid bounds
- fixed problem with recomputing symmetries after a restart
- fixed bug in SCIPcalcMIR() with wrong order of arguments for removeZerosQuad()
- fixed segmentation fault in update of cut statistic
- fixed bug in presolving of and constraints by merging variables with multiple occurrences before cliquePresolve()
- fixed bug in dual presolving of linear constraints by setting implicit integers to integers in multi-aggregation
- fixed update of presolve statistics on added constraints and changed coefficients in constraint handler for nonlinear constraints
- fixed bug with reading CIP files with large constraints split over several lines
- fixed bug with infinite bounds in the computation of conflict cuts
- fixed check for unbounded solution constructed by SCIPlpGetUnboundedSol(): The constructed solution is very likely infeasible
  since scaling increases small numerical feasibility violations. Therefore, the solution is now always accepted. However, the
  feasibility of the ray is now checked. This fix now might lead to several rounds of separation in order to resolve unbounded solutions,
  whereas previously SCIP started to branch immediately.
- changed to absolute tolerances in all redundancy checks for linear constraints

Miscellaneous
-------------

- Added extended cutselector statistics splitting between root node specific and general statistics
- Added extended and refined cutpool statistics showing the number of cuts added from the cutpool to the sepastore
- Added extended and refined separator statistics to get a better view of the individual generators performance
- turned off output of statistics for the following information by default:
  diving heuristics, ALNS neighborhood information and tree size estimation statistics;
  they can be turned on using the following new parameters:
  misc/showdivingstats (diving heuristics), heuristics/alns/shownbstats (ALNS), estimation/showstats (tree size estimation)

@section RN801 SCIP 8.0.1
*************************
Features
--------

- clique lifting in cons_setppc (parameter enablecliquelifting) is only disabled if it has been applied
- avoid warning if Mosek has reached/exceeded the objective limit
- improved curvature check for quadratic expressions when extended formulations are disabled

Examples and applications
-------------------------

- Fixed handling of enforcing in the TSP example.

Interface changes
-----------------

### Interfaces to external software

- Added compatibility with Mosek 10.0.13.

Build system
------------

- BLISS is now built from the vendored version from https://github.com/ds4dm/Bliss

### Cmake

- avoid warnings about unrecognized compiler warning silencing options when compilation with GCC fails
- adjust mosek find module to version 9.3
- added cmake compatibility for ipopt versions 3.14.x

### Makefile

- avoid warnings about unrecognized compiler warning silencing options when compilation with GCC fails
- fixed that compilation with MS/Intel compilers on Windows and Cray compilers was broken when enabling PAPILO

Fixed bugs
----------

- fixed uninitialized array in detection of suborbitopes
- Fixed problem with reading long lines in LP/FZN/OPB/Diff-files. The buffer is now reallocated,
  which also should be much faster.
- fixed that recursive products in expressions were sometimes not flattened
- fixed that expressions in original variables could not be simplified
- fixed handling of objective limit with Mosek
- made SCIPlpiGetSolverName()/SCIPlpiGetSolverDesc() thread-safe for LP Solvers (Cplex,Gurobi,Glop,Mosek,SoPlex,Xpress)
- made SYMsymmetryGetName() thread-safe for Bliss
- fixed memory allocation issue in detection of SOC nlhdlr
- fixed that reaching the walltime limit in Ipopt was not handled properly
- Deactivated dual fixing of unlocked variables with zero objective in presol_milp that SCIP is unable to postsolve.
- set the column flag kImplInt for implicit integers in the papilo problem
- fixed bug in propagation of indicator constraints (one case always reported a change through propagation)

@section RN800 SCIP 8.0.0
*************************

Features
--------

- Variables that were marked as relaxation-only and that were not used in any solution (SCIP_SOL)
  are now deleted when during a restart.
- New symmetry handling method, symmetry handling inequalities based on the Schreier Sims table,
  which is able to handle symmetries of arbitrary kinds of variables.
- Revise way in which external memory (e.g., of LP-solver) is estimated.
- The symmetry code can now heuristically search for orbitopes that do not completely handle
  a symmetry component and add certain Schreier Sims cuts to such components.
- The LPIs for Gurobi and Mosek are thread-safe now.
- The complete code is now thread-safe by default.
- New separator to generate mixing cuts (works well for stochastic programming with probabilistic constraint).
- New parsing routines for cons_orbisack and cons_symresack.
- Variables can now be marked to forbid aggregation.
- Heuristic PADM can now reoptimize found solution with original objective function.
- Added code to support debugging of catching or releasing of variables to var.c (prints backtrace
  when catching and releasing).
- SCIPintervalSin() and SCIPintervalCos() are now rounding-safe.
- Removed special handling of second-order cones in undercover heuristic for now.
- Removed use of Hessian sparsity pattern for nonquadratic nonlinear constraints in undercover heuristic.
- Added reader for AMPL .nl files.
- New separator sepa_rlt to compute cuts via the reformulation-linearization technique (RLT).
- New separator sepa_minor to compute cuts from 2x2 minors of a violated semidefiniteness constraint that is
  implied by the extended formulation for bilinear products.
- New separator sepa_interminor to compute intersection cuts from 2x2 (not only principle) minors of a violated
  rank-one constraint that is implied by the extended formulation for bilinear products.
- Symmetry handling has been extended to detect also symmetries between variables that also appear in nonlinear constraints.
- Improved OBBT propagator by only considering variables that are contained in at least one nonconvex expression that has an auxiliary variable.
- Default parameter settings for NLP solves are now defined independently of the NLP solver.
- Added table to print statistics on NLP solvers.
- Knapsack, linear, logicor, setppc, and varbound constraints now add themselves to the NLP relaxation, if enabled.
  And, linking constraints and bounddisjunctions in one variable are added to the NLP relaxation now.
- Ipopt interface now supports warmstarts from a full primal/dual solution pair.
- Extended data structure SCIP_ROWPREP and routines to assemble a linear inequality before it is turned into a SCIP row and
  made it available via the API.
- MIR procedure is now available for strengthening the Benders' optimality cut
- SCIPbranchcandCalcLPCands() now also returns fractional variables in unbounded solutions.
- New emphasis "benchmark" to avoid different solving paths that may come from checking remaining memory.
- New plugin type for cut selection: users can now include their own cut selection rules, default rule moved to cutsel_hybrid.
- New construction heuristic DPS which additionally needs a user-provided decomposition and splits the problem into several sub-SCIPs
  according to this decomposition. The sub-SCIPs are solved and updated repeatedly until a feasible solution of the original problem is found.

Expressions:
- Removed support for expression types min and max for now. Removed support for expression type sign.
  Removed complex expression types sum, product, linear, quadratic, polynomial.
  Removed support for parameterized expressions.
- Added support for expression types sin, cos, and entropy. Added an expression type that stores a SCIP variable.
- Added handling of sin and cos expressions in OSiL reader.
- Added handling of sin, cos, and tan expressions in ZIMPL reader.
- Added expression handler plugin type, removed user expression type.
- Replaced expressions, expression trees, and expression graphs by a new implementation of expressions.
- Added differentiation methods (Gradients and Hessian directions) to expressions.
- Added integrality information to expressions.
- Added comparison and hashing of expressions.
- Improved simplification of expressions and identification of common subexpressions, in particular terms that appear
  equally in several quadratic functions are now identified.
- Expression simplification now expands powers also when the resulting exponents will be larger than 2.
- Added table to print statistics on expression handlers.
- Removed interval-arithmetic evaluation from expression interpreter (interfaces to automatic differentiation codes).
- Hessians for user-provided expression handlers are not available in the NLP solver interfaces for now.
- Sparse Hessians are now returned by expression interpreter. Removed dense Hessians.

Constraint handlers for NLP:
- cons_nonlinear has been completely rewritten and now handles constraints of the form lhs <= expr <= rhs, where
  expr is an expression using the new expression type. A linear part of a nonlinear constraint is no longer distinguished.
- Methods that work on a particular nonlinear structure are now implemented via nonlinear handlers (nlhdlr).
  These handlers are plugins of cons_nonlinear and interact with cons_nonlinear by detecting structures in expressions and
  providing propagation and separation mechanisms.
- Added nlhdlr "default" as a mandatory nlhdlr: this is a nlhdlr that gets active on expressions that no other nlhdlr handles.
  It then uses the callbacks implemented in expression handlers to provide domain propagation and linear under/overestimates.
- Added nlhdlr for quadratic expressions: domain propagation that was previously part of cons_quadratic; separation via intersection cuts (currently disabled).
- Added nlhdlr for bilinear expressions: collects bilinear products and provides under/overestimation of a product over a 2D-projection of the LP.
- Added nlhdlr for convex and concave expressions: detection of convex/concave subexpressions and linear under/overestimation.
- Added nlhdlr for quotients: detects quotients, provides specialized linear under/overestimation and domain propagation for univariate quotients.
- Added nlhdlr for perspective reformulations: detects expressions in semi-continuous variables and tightens linear
  under/overestimates of these expressions by applying a perspective transformation.
- Added nlhdlr for second-order cones: detects second-order cone constraints (as ||x|| <= t or a quadratic that can written like that) and
  separates on a disaggregated reformulation (similar to cons_soc previously).
- Removed constraint handlers abspower, bivariate, quadratic, and soc.
- Removed simplification of duplicate abspower constraints for now.
  Removed simplification of abspower constraints with loose variables.
  Removed resolving of domain propagation (ConsResProp callback) and conflict analysis for abspower constraints.
  Removed propagation of varbounds for variables of abspower constraints.
  Removed reformulation of abs(x)^p * x into signpower expression for now.
- Removed reformulation of SOC constraints when adding to the NLP.
  Removed possibility to add linearizations a la Glineur or BenTal&Nemirovski for SOC constraints.
- Removed possibility to disaggregate quadratic constraints.
  Removed lifted tangent inequalities for bilinear terms in quadratic constraints.
  Removed option to project LP solution onto feasible region of a quadratic constraint via interior point or gauge function.
  Removed handling of unbounded LPs when enforcing quadratic constraints.
- Removed construction of cuts from interval gradients for nonlinear constraints.
  Removed possibility to pretend that all nonlinear constraints are convex.
  Removed possibility to create local or non-initial nonlinear constraints for now.
- Removed explicit reformulation of nonlinear constraints in presolve.
  An extended formulation is now generated implicitly and used to construct the LP relaxation,
  but the original formulation is used to check feasibility, propagate variable domains, etc.
  Variables that are added for the extended formulation are now marked as relaxation-only.
- Improved locking of nonlinear variables in nonlinear constraints by taking monotonicity into account.
- Improved mechanisms to detect and handle structures in nonlinear constraints, which allows for several algorithms
  to work simultaneously on equal or overlapping expressions.
- Improved linearization of (sums of) products of binary variables, e.g., clique information is now taken into account.
  Removed option to linearize products between a binary and a non-binary variable.
- Nonlinear constraints with the same function (but possibly different left- or right-hand-side) are now merged.
- When a variable appears in only one concave less-or-equal constraint, it will be fixed to one of its bounds in more cases now.
- New branching rule for variables in nonlinear constraints (implemented in cons_nonlinear) that scores candidates
  based on constraint violation, variable type, and pseudo-costs simultaneously.
- Added tables to print statistics of nonlinear constraint handler and nonlinear handlers.

Performance improvements
------------------------

- Use the objective cutoff row as base row for separation in sepa_aggregation.c.
- Separate lifted cover cuts based on newer lifting function of Letchford and Souli (2019) in sepa_aggregation.c.
- In-tree restarts due to tree size estimation have been made compatible with orbital fixing.
- Improved upgrade of orbisacks to packing/partitioning orbitopes.
- Improved running time of symresack cover separation.
- Improved propagation algorithm for orbisack and symresack.
- Improved handling for expressions of type signpower in CppAD interface by making use of CppADs conditional expressions.
- Faster reevaluation of Hessian for quadratic expressions in CppAD interface.
- Enabled optimization of taped expressions in the CppAD interface.
- Sparse Hessian evaluation for expressions with sparse Hessian in the CppAD interface.
- Disabled branching on variables that are added for the extended formulation of a nonlinear constraint.
- Prefer branching on variables in nonconvex terms of nonlinear constraints also if a cut could be generated but would yield a small reduction in the convexification gap only.
- When violations of nonlinear constraints are tiny, the feasibility tolerance for the LP relaxation may now be reduced temporarily to allow for cuts to have an effect.
- Improved under/overestimation of multidimensional vertex-polyhedral (e.g., multilinear or concave) functions by use of scaling and keeping the cut-generating LP around.
- Products in nonlinear constraints are no longer disaggregated for the extended formulation.
- No longer relax bounds of integral variables when computing bounds on activity in nonlinear constraints.
- Revised and improved Ipopt interface.
- Revised and improved subNLP primal heuristic, in particular choice of iteration limit and starting condition and reuse of subSCIP.
- Merge strongcg into the gomory separator to avoid computing the same base equality twice. The files
  sepa_strongcg.{h|c} have been removed.
- The RENS neighborhood in ALNS now fixes fractional variables if necessary for reaching its target fixing rate.
- Use cpsolver emphasis in sepa_rapidlearning.
- If decomposition/maxgraphedge = 0, the computation of the block graph is completely turned off.
- Fixed a performance bug in cons_integral.c where rounding information was passed incorrectly to the generic diving algorithm.

Examples and applications
-------------------------

- Add c++ Sudoku example
- Removed circle.c and renamed string.c to spring.c in CallableLibrary example.
- SCIP-Jack (Steiner tree application):
  Most files have been modified and many new ones have been added (code base more than doubled).
  Two new problem classes are supported: maximum-weight connected subgraph problem with budget constraints, partial-terminal node-weighted Steiner tree problem.
  Major performance improvements accross all problem classes that are supported.

Interface changes
-----------------

### New and changed callbacks

- extend SEPAEXEC{LP,SOL} callbacks by parameter "depth", which should be used within separation instead of SCIPgetCurrentDepth()
- extend SCIPseparateSolCutpool() by parameter "pretendroot", which is passed to SCIPcutpoolSeparate() instead of SCIPtreeGetCurrentDepth(scip->tree) == 0
- removed SCIP_DECL_EXPRGRAPHVARADDED, SCIP_DECL_EXPRGRAPHVARREMOVE, SCIP_DECL_EXPRGRAPHVARCHGIDX
- removed SCIP_DECL_USEREXPRESTIMATE, SCIP_DECL_USEREXPREVAL, SCIP_DECL_USEREXPRINTEVAL, SCIP_DECL_USEREXPRCURV, SCIP_DECL_USEREXPRPROP, SCIP_DECL_USEREXPRCOPYDATA, SCIP_DECL_USEREXPRFREEDATA, SCIP_DECL_USEREXPRPRINT
- added SCIP_DECL_EXPR_OWNERFREE, SCIP_DECL_EXPR_OWNERPRINT, SCIP_DECL_EXPR_OWNEREVALACTIVITY, SCIP_DECL_EXPR_OWNERCREATE
- added SCIP_DECL_EXPR_INTEVALVAR, SCIP_DECL_EXPR_MAPEXPR
- added SCIP_DECL_EXPRCOPYHDLR, SCIP_DECL_EXPRFREEHDLR, SCIP_DECL_EXPRCOPYDATA, SCIP_DECL_EXPRFREEDATA, SCIP_DECL_EXPRPRINT, SCIP_DECL_EXPRPARSE, SCIP_DECL_EXPRCURVATURE, SCIP_DECL_EXPRMONOTONICITY, SCIP_DECL_EXPRINTEGRALITY, SCIP_DECL_EXPRHASH, SCIP_DECL_EXPRCOMPARE, SCIP_DECL_EXPREVAL, SCIP_DECL_EXPRBWDIFF, SCIP_DECL_EXPRFWDIFF, SCIP_DECL_EXPRBWFWDIFF, SCIP_DECL_EXPRINTEVAL, SCIP_DECL_EXPRESTIMATE, SCIP_DECL_EXPRINITESTIMATES, SCIP_DECL_EXPRSIMPLIFY, SCIP_DECL_EXPRREVERSEPROP
- removed SCIP_DECL_QUADCONSUPGD
- added SCIP_DECL_VERTEXPOLYFUN
- added argument nvarexprs to SCIP_DECL_NONLINCONSUPGD to inform upgrade method about number of variables in constraint
- removed SCIP_DECL_EXPRGRAPHNODEREFORM
- added SCIP_DECL_NLHDLRCOPYHDLR, SCIP_DECL_NLHDLRFREEHDLRDATA, SCIP_DECL_NLHDLRFREEEXPRDATA, SCIP_DECL_NLHDLRINIT, SCIP_DECL_NLHDLREXIT, SCIP_DECL_NLHDLRDETECT, SCIP_DECL_NLHDLREVALAUX, SCIP_DECL_NLHDLRINTEVAL, SCIP_DECL_NLHDLRREVERSEPROP, SCIP_DECL_NLHDLRINITSEPA, SCIP_DECL_NLHDLREXITSEPA, SCIP_DECL_NLHDLRENFO, SCIP_DECL_NLHDLRESTIMATE
- replaced BMS_BLKMEM* blkmem argument of SCIP_DECL_NLPICOPY by SCIP* scip, removed targetnlpi argument
- added SCIP* scip and SCIP_NLPIDATA** nlpidata arguments to SCIP_DECL_NLPIFREE
- added SCIP* scip to SCIP_DECL_NLPIGETSOLVERPOINTER, SCIP_DECL_NLPICREATEPROBLEM, SCIP_DECL_NLPIFREEPROBLEM, SCIP_DECL_NLPIGETPROBLEMPOINTER, SCIP_DECL_NLPIADDVARS, SCIP_DECL_NLPIADDCONSTRAINTS, SCIP_DECL_NLPISETOBJECTIVE, SCIP_DECL_NLPICHGVARBOUNDS, SCIP_DECL_NLPICHGCONSSIDES, SCIP_DECL_NLPIDELVARSET, SCIP_DECL_NLPIDELCONSSET, SCIP_DECL_NLPICHGLINEARCOEFS, SCIP_DECL_NLPICHGOBJCONSTANT, SCIP_DECL_NLPISETINITIALGUESS, SCIP_DECL_NLPISOLVE, SCIP_DECL_NLPIGETSOLSTAT, SCIP_DECL_NLPIGETTERMSTAT, SCIP_DECL_NLPIGETSOLUTION, SCIP_DECL_NLPIGETSTATISTICS
- replaced SCIP_DECL_NLPICHGEXPRTREE by SCIP_DECL_NLPICHGEXPR
- removed nquadelems, quadelems, exprvaridxs arguments from SCIP_DECL_NLPIADDCONSTRAINTS, changed exprtrees argument to exprs
- removed nquadelems, quadelems, exprvaridxs arguments from SCIP_DECL_NLPISETOBJECTIVE, changed exprtree argument to expr
- removed SCIP_DECL_NLPICHGQUADCOEFS, SCIP_DECL_NLPICHGNONLINCOEF, SCIP_DECL_NLPISETMESSAGEHDLR
- added SCIP_NLPIPROBLEM* problem to SCIP_DECL_NLPIGETSOLVERPOINTER

### Deleted and changed API methods

- When calling SCIPdelVar() in the SCIP_STAGE_PROBLEM stage, it is now documented as the user's responsibility to ensure
  the variable is not present in any constraints. Otherwise, SCIPsolve() now returns SCIP_INVALIDDATA.
- removed SCIPselectCuts(), replaced by SCIPselectCutsHybrid() of the hybrid cut selector plugin
- If SCIPvarMarkRelaxationOnly() is called for a variable, then this now need to happen before the
  variable is added to the transformed problem (SCIPaddVar()).
  SCIPvarMarkRelaxationOnly() will automatically call SCIPvarMarkDeletable().
- SCIPcomputeOrbitsFilterSym() and SCIPcomputeComponentsSym(): Type of argument componentblocked
  changed from SCIP_Shortbool* to unsigned*.
- removed SCIPsetParam()
- SCIPcreateConsOrbitope() and SCIPcreateConsBasicOrbitope() have two new arguments "usedynamicprop"
  and "mayinteract" to encode whether a dynamic reordering of the orbitope rows shall be used in
  full orbitope propagation and whether the orbitope might interact with other symmetry handling
  methods, respectively.
- internal function SCIPgetPropertiesPerm() has been replaced by SCIPisInvolutionPerm()
- internal function SCIPgenerateOrbitopeVarsMatrix() has new arguments "storelexorder", "lexorder",
  "nvarsorder", "maxnvarsorder" to compute and store the lexicographic order defined by an orbitope
- renamed SCIPcomputeArraysIntersection() and SCIPcomputeArraysSetminus() to
  SCIPcomputeArraysIntersectionInt() and SCIPcomputeArraysSetminusInt(), respectively, and changed
  their return type from SCIP_RETCODE (which _always_ was SCIP_OKAY) to void
- removed SCIPincludeDialogDefault(), use SCIPincludeDialogDefaultBasic() instead and check whether you also need SCIPincludeDialogDefaultSet() and SCIPincludeDialogDefaultFix()
- removed exprint argument from SCIPaddNlRowGradientBenderscutOpt()
- added copyexprhdlrs argument to SCIPcopyPlugins() (19th position)
- added copycutselectors argument to SCIPcopyPlugins() (10th position)
- removed refpoint argument from SCIPaddSquareSecant()
- added argument exprdata to SYMcomputeSymmetryGenerators()
- removed SCIPconsNonlinearGetRhs(), SCIPconsNonlinearGetLhs(), SCIPconsNonlinearAddLinearCoef()
- removed arguments timelimit, minimprove, itercontingent, and iterused from SCIPapplyHeurSubNlp()
- removed SCIPresolveSolHeurSubNlp(), SCIPgetSubScipHeurSubNlp(), SCIPgetVarMappingScip2SubScipHeurSubNlp(), SCIPgetVarMappingSubScip2ScipHeurSubNlp()
- SCIPlockVarCons() and SCIPunlockVarCons() are now allowed in stage TRANSFORMED as well
- Added functions SCIPsetSepaIsParentsepa(), SCIPsetSepaParentsepa() [in scip_sepa.h], SCIPsepaSetIsParentsepa(), SCIPsepaSetParentsepa() [in sepa.h],
  SCIPsepaIsParentsepa(), SCIPsepaGetParentsepa() [in pub_sepa.h]
- Added function SCIPpruneTree() to immediately delete nodes that were marked to be deleted with SCIPcutoffNode

NLP:
- SCIPhasNLPContinuousNonlinearity() now returns SCIP_RETCODE and has additional argument result
- removed SCIPnlrowGetNQuadVars(), SCIPnlrowGetQuadVars(), SCIPnlrowSearchQuadVar(), SCIPnlrowGetNQuadElems(), SCIPnlrowGetQuadElems(), SCIPnlrowGetQuadData()
- renamed SCIPnlrowGetExprtree() to SCIPnlrowGetExpr() and changed return type to SCIP_EXPR*
- removed arguments nquadvars, quadvars, nquadelems, quadelems from SCIPcreateNlRow(); argument expr(ession) is now of type SCIP_EXPR*
- removed SCIPaddQuadVarToNlRow(), SCIPaddQuadVarsToNlRow(), SCIPaddQuadElementToNlRow(), SCIPaddQuadElementsToNlRow(), SCIPchgNlRowQuadElement(), SCIPsetNlRowExprtreeParam(), SCIPsetNlRowExprtreeParams()
- renamed SCIPsetNlRowExprtree() to SCIPsetNlRowExpr() and changed type of expr(tree) argument to SCIP_EXPR*
- SCIPenableNLP() is no longer allowed in stages INITSOLVE and SOLVING
- removed SCIPaddLinearConsToNlpHeurSubNlp()
- SCIPhasNLPSolution() now returns true also if a infeasible solution to the NLP exists; SCIPcreateNLPSol() can now also be used when only an infeasible solution to the NLP exists
- renamed SCIPsolveNLP() to SCIPsolveNLPParam() and added parameter SCIP_NLPPARAM param
- removed SCIPsolveDiveNLP(), use SCIPsolveNLPParam() instead

NLPI:
- removed SCIPnlpiCopy(), SCIPnlpiFree(), SCIPnlpiChgQuadCoefs(), SCIPnlpiChgNonlinCoef(), SCIPnlpiSetMessageHdlr()
- removed SCIPnlpiCreate() from public API, use SCIPincludeNlpi() instead
- removed SCIPnlpiGetSolverPointer() from public API, use SCIPgetNlpiSolverPointer() instead
- removed SCIPnlpiCreateProblem() from public API, use SCIPcreateNlpiProblem() instead
- removed SCIPnlpiFreeProblem() from public API, use SCIPfreeNlpiProblem() instead
- removed SCIPnlpiGetProblemPointer() from public API, use SCIPgetNlpiProblemPointer() instead
- removed SCIPnlpiAddVars() from public API, use SCIPaddNlpiVars() instead
- removed SCIPnlpiAddConstraints() from public API, use SCIPaddNlpiConstraints() instead
- removed SCIPnlpiSetObjective() from public API, use SCIPsetNlpiObjective() instead
- removed SCIPnlpiChgVarBounds() from public API, use SCIPchgNlpiVarBounds() instead
- removed SCIPnlpiChgConsSides() from public API, use SCIPchgNlpiConsSides() instead
- removed SCIPnlpiDelVarSet() from public API, use SCIPdelNlpiVarSet() instead
- removed SCIPnlpiDelConsSet() from public API, use SCIPdelNlpiConsSet() instead
- removed SCIPnlpiChgLinearCoefs() from public API, use SCIPchgNlpiLinearCoefs() instead
- removed SCIPnlpiChgExprtree() from public API, use SCIPchgNlpiExpr() instead
- removed SCIPnlpiChgObjConstant() from public API, use SCIPchgNlpiObjConstant() instead
- removed SCIPnlpiSetInitialGuess() from public API, use SCIPsetNlpiInitialGuess() instead
- removed SCIPnlpiSolve() from public API, use SCIPsolveNlpiParam() instead
- removed SCIPnlpiGetSolstat() from public API, use SCIPgetNlpiSolstat() instead
- removed SCIPnlpiGetTermstat() from public API, use SCIPgetNlpiTermstat() instead
- removed SCIPnlpiGetSolution() from public API, use SCIPgetNlpiSolution() instead
- removed SCIPnlpiGetStatistics() from public API, use SCIPgetNlpiStatistics() instead
- removed SCIPnlpiGetWarmstartSize()
- removed SCIPnlpiGetWarmstartMemo()
- removed SCIPnlpiSetWarmstartMemo()
- removed SCIPnlpiGetIntPar()
- removed SCIPnlpiSetIntPar()
- removed SCIPnlpiGetRealPar()
- removed SCIPnlpiSetRealPar()
- removed SCIPnlpiGetStringPar(),
- removed SCIPnlpiSetStringPar()
- removed SCIPnlpiSetPriority() from public API, use SCIPsetNlpiPriority() instead
- removed argument nlpi from SCIPincludeNlpi() and added name, description, priority,
  nlpicopy, nlpifree, nlpigetsolverpointer, nlpicreateproblem, nlpifreeproblem, nlpigetproblempointer, nlpiaddvars, nlpiaddconstraints, nlpisetobjective, nlpichgvarbounds, nlpichgconssides, nlpidelvarset, nlpidelconsset, nlpichglinearcoefs, nlpichgexpr, nlpichgobjconstant, nlpisetinitialguess, nlpisolve, nlpigetsolstat, nlpigettermstat, nlpigetsolution, nlpigetstatistics, nlpidata
- removed SCIPcreateNlpSolverAll(), use SCIPincludeNlpSolverAll() instead
- removed SCIPcreateNlpSolverFilterSQP(), use SCIPincludeNlpSolverFilterSQP() instead
- removed SCIPcreateNlpSolverIpopt(), use SCIPincludeNlpSolverIpopt() instead
- removed SCIPcreateNlpSolverWorhp(), use SCIPincludeNlpSolverWorhp() instead
- replaced argument BMS_BLKMEM* blkmem of SCIPnlpiOracleCreate() by SCIP* scip
- added argument SCIP* scip to SCIPnlpiOracleFree(), SCIPnlpiOracleSetProblemName(), SCIPnlpiOracleAddVars(), SCIPnlpiOracleAddConstraints(), SCIPnlpiOracleSetObjective(), SCIPnlpiOracleChgVarBounds(), SCIPnlpiOracleChgConsSides(), SCIPnlpiOracleDelVarSet(), SCIPnlpiOracleDelConsSet(), SCIPnlpiOracleChgLinearCoefs(), SCIPnlpiOracleChgObjConstant(), SCIPnlpiOracleGetEvalCapability(), SCIPnlpiOracleEvalObjectiveValue(), SCIPnlpiOracleEvalConstraintValue(), SCIPnlpiOracleEvalConstraintValues(), SCIPnlpiOracleEvalObjectiveGradient(), SCIPnlpiOracleEvalConstraintGradient(), SCIPnlpiOracleGetJacobianSparsity(), SCIPnlpiOracleEvalJacobian(), SCIPnlpiOracleGetHessianLagSparsity(), SCIPnlpiOracleEvalHessianLag(), SCIPnlpiOraclePrintProblem(), SCIPnlpiOraclePrintProblemGams()
- removed arguments nquadelems, quadelems, exprvaridxs, exprtrees from SCIPnlpiOracleAddConstraints(), added argument SCIP_EXPR** exprs
- removed arguments nquadelems, quadelems, exprvaridxs, exprtree from SCIPnlpiOracleSetObjective(), added argument SCIP_EXPR* expr
- replaced arguments isnewx of SCIPnlpiOracleEvalHessianLag() by two arguments isnewx_obj and isnewx_cons
- removed SCIPnlpiOracleChgExprtree(), use SCIPnlpiOracleChgExpr() instead
- removed SCIPnlpiOracleSetInfinity(), SCIPnlpiOracleGetInfinity(), SCIPnlpiOracleChgQuadCoefs(), SCIPnlpiOracleChgExprParam(), SCIPnlpiOracleGetMaxDegree()
- removed SCIPnlpiOracleGetVarDegree() and SCIPnlpiOracleGetVarDegrees(), use SCIPnlpiOracleIsVarNonlinear() and SCIPnlpiOracleGetVarCounts(), respectively, instead
- removed SCIPnlpiOracleGetConstraintDegree(), use SCIPnlpiOracleIsConstraintNonlinear() instead
- removed argument messagehdlr from SCIPnlpiOraclePrintProblem() and SCIPnlpiOraclePrintProblemGams()
- removed SCIPcreateNlpiProb(), use SCIPcreateNlpiProblemFromNlRows() instead
- renamed SCIPupdateNlpiProb() to SCIPupdateNlpiProblem() and moved into scip_nlpi.{h,c}
- renamed SCIPaddNlpiProbRows() to SCIPaddNlpiProblemRows() and moved into scip_nlpi.{h,c}
- removed SCIPsetModifiedDefaultSettingsIpopt()
- removed SCIPgetIpoptApplicationPointerIpopt(), use SCIPgetNlpiSolverPointer() instead
- removed SCIPnlpStatisticsCreate(), SCIPnlpStatisticsFree(), SCIPnlpStatisticsGetNIterations(), SCIPnlpStatisticsGetTotalTime(), SCIPnlpStatisticsSetNIterations(), SCIPnlpStatisticsSetTotalTime(), the struct is public now
- renamed LapackDsyev() to SCIPcallLapackDsyevIpopt()
- renamed SCIPsolveLinearProb() to SCIPsolveLinearEquationsIpopt()

Expression interpreter:
- removed functions that operated with SCIPInterval
- changed first argument of SCIPexprintCreate() to SCIP*
- added SCIP* as first argument to SCIPexprintFree()
- added SCIP* as first argument to SCIPexprintCompile(), changed third argument to SCIP_EXPR*, added fourth argument SCIP_EXPRINTDATA**
- added arguments SCIP*, SCIP_EXPRINT*, and SCIP_EXPR* as first arguments to SCIPexprintFreeData()
- renamed SCIPexprintGetExprtreeCapability() to SCIPexprintGetExprCapability();
  added SCIP* as first argument, changed third argument to SCIP_EXPR*, added fourth argument SCIP_EXPRINTDATA*
- removed SCIPexprintNewParametrization()
- SCIPexprintEval(): added SCIP* as first argument, changed third argument to SCIP_EXPR*, added fourth argument SCIP_EXPRINTDATA*
- removed SCIPexprintEvalInt()
- SCIPexprintGrad(): added SCIP* as first argument, changed third argument to SCIP_EXPR*, added fourth argument SCIP_EXPRINTDATA*
- removed SCIPexprintGradInt()
- removed SCIPexprintHessianSparsityDense() and SCIPexprintHessianDense, use SCIPexprintHessianSparsity() and SCIPexprintHessian() instead

Expressions:
- removed SCIPexpropGetName(), use SCIPexprhdlrGetName() instead
- removed SCIPexpropGetNChildren()
- removed SCIPexprGetOperator(), use SCIPexprGetHdlr() instead
- removed SCIPexprGetOpIndex(), SCIPexprGetOpReal(), SCIPexprGetOpData(), use SCIPexprGetData() instead
- removed SCIPexprGetRealPowerExponent(), SCIPexprGetIntPowerExponent(), SCIPexprGetSignPowerExponent(), use SCIPgetExponentExprPow() instead
- removed SCIPexprGetLinearCoefs(), SCIPexprGetLinearConstant(), use SCIPgetCoefsExprSum() and SCIPgetConstantExprSum() instead
- removed SCIPexprGetQuadElements(), SCIPexprGetQuadConstant(), SCIPexprGetQuadLinearCoefs(), SCIPexprGetNQuadElements(), use SCIPexprGetQuadraticData(), SCIPexprGetQuadraticQuadTerm(), SCIPexprGetQuadraticBilinTerm() instead
- removed SCIPexprGetMonomials(), SCIPexprGetNMonomials, SCIPexprGetPolynomialConstant(), SCIPexprGetMonomialCoef(), SCIPexprGetMonomialNFactors(), SCIPexprGetMonomialChildIndices(), SCIPexprGetMonomialExponents()
- removed SCIPexprGetUserData(), SCIPexprHasUserEstimator(), SCIPexprGetUserEvalCapability()
- removed SCIPexprCreate(), use SCIPcreateExpr() instead
- removed SCIPexprCopyDeep(), use SCIPduplicateExpr() instead
- removed SCIPexprFreeDeep(), use SCIPreleaseExpr() instead
- removed SCIPexprFreeShallow()
- removed SCIPexprAdd(), SCIPexprMulConstant()
- removed SCIPexprCreateLinear(), use SCIPcreateExprSum() instead
- replaced SCIPexprAddToLinear() by SCIPappendExprSumExpr()
- replaced SCIPexprCreateQuadratic() by SCIPcreateExprQuadratic()
- removed SCIPexprSortQuadElems()
- removed SCIPexprCreatePolynomial(), SCIPexprAddMonomials(), SCIPexprChgPolynomialConstant(), SCIPexprMultiplyPolynomialByConstant(), SCIPexprMultiplyPolynomialByMonomial(), SCIPexprMultiplyPolynomialByPolynomial(), SCIPexprPolynomialPower()
- removed SCIPexprMergeMonomials(), SCIPexprFreeMonomial(), SCIPexprSortMonomialFactors(), SCIPexprFindMonomialFactor(), SCIPexprAreMonomialsEqual(), SCIPexprAddMonomialFactors(), SCIPexprChgMonomialCoef(), SCIPexprMultiplyMonomialByMonomial(), SCIPexprMonomialPower(), SCIPexprMergeMonomialFactors(), SCIPexprSortMonomials()
- replaced SCIPexprCreateMonomial() by SCIPcreateExprMonomial()
- removed SCIPexprCreateUser(), use SCIPincludeExprhdlr() instead
- removed SCIPexprHasParam(), SCIPexprGetMaxDegree(), SCIPexprGetVarsUsage()
- replaced SCIPexprAreEqual() by SCIPcompareExpr()
- replaced SCIPexprSimplify() by SCIPsimplifyExpr()
- replaced SCIPexprEvalShallow() by SCIPcallExprEval()
- replaced SCIPexprEval() by SCIPevalExpr()
- replaced SCIPexprEvalIntShallow() by SCIPcallExprInteval()
- replaced SCIPexprEvalInt() by SCIPevalExprActivity()
- removed SCIPexprEvalUser(), SCIPexprEvalIntUser(), SCIPexprEstimateUser()
- replaced SCIPexprCheckCurvature() by SCIPcomputeExprCurvature()
- removed SCIPexprSubstituteVars(), use SCIPcopyExpr() instead
- removed SCIPexprReindexVars(), SCIPexprReindexParams()
- replaced SCIPexprPrint() by SCIPprintExpr()
- replaced SCIPexprParse() by SCIPparseExpr()

Expression tree:
- removed SCIPexprtreeGetVars(), SCIPexprtreeSetVars(), SCIPexprtreeAddVars(), SCIPexprtreePrintWithNames(), SCIPexprtreeFindVar()
- removed SCIPexprtreeGetRoot(), SCIPexprtreeGetNVars(), SCIPexprtreeGetNParams(), SCIPexprtreeGetParamVals(), SCIPexprtreeSetParamVal(), SCIPexprtreeHasParam()
- removed SCIPexprtreeGetInterpreterData(), SCIPexprtreeSetInterpreterData(), SCIPexprtreeFreeInterpreterData()
- removed SCIPexprtreeGetMaxDegree()
- removed SCIPexprtreeEval(), use SCIPevalExpr() instead
- removed SCIPexprtreeEvalInt(), use SCIPevalExprActivity() instead
- removed SCIPexprtreePrint(), use SCIPprintExpr() instead
- removed SCIPexprtreeCreate()
- removed SCIPexprtreeCopy(), use SCIPduplicateExpr() instead
- removed SCIPexprtreeFree(), use SCIPreleaseExpr() instead
- removed SCIPexprtreeSetParams(), SCIPexprtreeGetVarsUsage()
- removed SCIPexprtreeSimplify(), use SCIPsimplifyExpr() instead
- removed SCIPexprtreeAddExpr()
- removed SCIPexprtreeCheckCurvature(), use SCIPcomputeExprCurvature() instead
- removed SCIPexprtreeSubstituteVars(), use SCIPcopyExpr() instead
- removed SCIPquadelemSort(), SCIPquadelemSortedFind(), SCIPquadelemSqueeze()

Expression graph:
- removed SCIPexprgraphCaptureNode(), use SCIPcaptureExpr() instead
- removed SCIPexprgraphIsNodeEnabled()
- removed SCIPexprgraphGetNodeNChildren(), use SCIPexprGetNChildren() instead
- removed SCIPexprgraphGetNodeChildren(), use SCIPexprGetChildren() instead
- removed SCIPexprgraphGetNodeNParents(), SCIPexprgraphGetNodeParents(), SCIPexprgraphGetNodeDepth(), SCIPexprgraphGetNodePosition()
- removed SCIPexprgraphGetNodeOperator(), use SCIPexprGetHdlr() instead
- removed SCIPexprgraphGetNodeOperatorIndex(), SCIPexprgraphGetNodeOperatorReal(), use SCIPexprGetData() instead
- removed SCIPexprgraphGetNodeVar(), use SCIPgetVarExprVar() instead
- removed SCIPexprgraphGetNodeRealPowerExponent(), SCIPexprgraphGetNodeIntPowerExponent(), SCIPexprgraphGetNodeSignPowerExponent(), use SCIPgetExponentExprPow() instead
- removed SCIPexprgraphGetNodeLinearCoefs(), SCIPexprgraphGetNodeLinearConstant(), use SCIPgetCoefsExprSum(), SCIPgetConstantExprSum() instead
- removed SCIPexprgraphGetNodeQuadraticConstant(), SCIPexprgraphGetNodeQuadraticLinearCoefs(), SCIPexprgraphGetNodeQuadraticQuadElements(), SCIPexprgraphGetNodeQuadraticNQuadElements(), use SCIPexprGetQuadraticData(), SCIPexprGetQuadraticQuadTerm(), SCIPexprGetQuadraticBilinTerm() instead
- removed SCIPexprgraphGetNodePolynomialMonomials(), SCIPexprgraphGetNodePolynomialNMonomials(), SCIPexprgraphGetNodePolynomialConstant(), SCIPexprgraphGetNodePolynomialMonomialCurvature()
- removed SCIPexprgraphGetNodeUserData(), SCIPexprgraphHasNodeUserEstimator()
- removed SCIPexprgraphGetNodeBounds(), use SCIPexprGetActivity() instead
- removed SCIPexprgraphGetNodeVal(), use SCIPexprGetEvalValue() instead
- removed SCIPexprgraphGetNodeCurvature(), use SCIPexprGetCurvature() instead
- removed SCIPexprgraphCreateNode()
- removed SCIPexprgraphCreateNodeLinear(), use SCIPcreateExprSum() instead
- removed SCIPexprgraphCreateNodeQuadratic(), use SCIPcreateExprQuadratic() instead
- removed SCIPexprgraphCreateNodePolynomial(), SCIPexprgraphNodePolynomialAddMonomials()
- removed SCIPexprgraphCreateNodeUser(), removed SCIPexprgraphNodeSplitOffLinear(), SCIPexprgraphMoveNodeParents()
- removed SCIPexprgraphReleaseNode(), use SCIPreleaseExpr() instead
- removed SCIPexprgraphFreeNode(), use SCIPreleaseExpr() instead
- removed SCIPexprgraphEnableNode(), SCIPexprgraphDisableNode()
- removed SCIPexprgraphHasNodeSibling(), SCIPexprgraphAreAllNodeChildrenVars(), SCIPexprgraphHasNodeNonlinearAncestor()
- removed SCIPexprgraphPrintNode(), SCIPprintExpr() instead
- removed SCIPexprgraphTightenNodeBounds()
- removed SCIPexprgraphUpdateNodeBoundsCurvature(), use SCIPevalExprActivity() and SCIPcomputeExprCurvature() instead
- removed SCIPexprgraphGetDepth(), SCIPexprgraphGetNNodes(), SCIPexprgraphGetNodes(), SCIPexprgraphGetNVars(), SCIPexprgraphGetVars()
- removed SCIPexprgraphGetVarNodes(), SCIPexprgraphSetVarNodeValue(), SCIPexprgraphSetVarsBounds(), SCIPexprgraphSetVarBounds(), SCIPexprgraphSetVarNodeBounds(), SCIPexprgraphSetVarNodeLb(), SCIPexprgraphSetVarNodeUb(), SCIPexprgraphGetVarsBounds()
- removed SCIPexprgraphCreate(), SCIPexprgraphFree()
- removed SCIPexprgraphAddNode(), SCIPexprgraphAddVars(), SCIPexprgraphAddConst(), SCIPexprgraphAddExprtreeSum()
- removed SCIPexprgraphReplaceVarByLinearSum(), SCIPexprgraphFindVarNode(), SCIPexprgraphFindConstNode()
- replaced SCIPexprgraphPrintDot() by SCIPprintExprDotInit[2](), SCIPprintExprDot(), SCIPprintExprDotFinal()
- removed SCIPexprgraphEval(), use SCIPevalExpr() instead
- removed SCIPexprgraphPropagateVarBounds(), SCIPexprgraphPropagateNodeBounds()
- removed SCIPexprgraphCheckCurvature(), use SCIPcomputeExprCurvature() instead
- removed SCIPexprgraphSimplify(), use SCIPsimplifyExpr() instead
- removed SCIPexprgraphGetTree(), SCIPexprgraphGetSeparableTrees(), SCIPexprgraphGetSubtreeVarsUsage(), SCIPexprgraphGetSumTreesNSummands(), SCIPexprgraphGetSumTrees()

Constraint handlers for NLP:
- removed SCIPincludeConshdlrAbspower()
- deprecated SCIPcreateConsAbspower() and SCIPcreateConsBasicAbspower(), use SCIPcreateConsBasicSignpowerNonlinear() instead
- deprecated SCIPgetNlRowAbspower(), use SCIPgetNlRowNonlinear() instead
- removed SCIPgetNonlinearVarAbspower(), SCIPgetLinearVarAbspower(), SCIPgetExponentAbspower(), SCIPgetOffsetAbspower(), SCIPgetCoefLinearAbspower(), SCIPgetLhsAbspower(), SCIPgetRhsAbspower()
- removed SCIPgetViolationAbspower(), use SCIPgetAbsViolationNonlinear() instead
- removed SCIPisConvexAbspower(), use SCIPhasExprCurvature() instead
- removed SCIPincludeConshdlrBivariate(), SCIPcreateConsBivariate(), SCIPcreateConsBasicBivariate()
- removed SCIPgetLinearVarBivariate(), SCIPgetLinearCoefBivariate(), SCIPgetExprtreeBivariate(), SCIPgetLhsBivariate(), SCIPgetRhsBivariate()
- removed SCIPincludeConshdlrQuadratic(), use SCIPincludeNlhdlrQuadratic() instead
- removed SCIPincludeQuadconsUpgrade()
- removed SCIPcreateConsQuadratic2(), SCIPcreateConsBasicQuadratic2()
- deprecated SCIPcreateConsBasicQuadratic(), use SCIPcreateConsBasicQuadraticNonlinear() instead
- deprecated SCIPcreateConsBasicQuadratic(), use SCIPcreateConsQuadraticNonlinear() instead
- deprecated SCIPaddConstantQuadratic(), use SCIPgetLhsNonlinear() and SCIPgetRhsNonlinear() instead
- deprecated SCIPaddLinearVarQuadratic(), use SCIPaddLinearVarNonlinear() instead
- deprecated SCIPaddQuadVarQuadratic(), use SCIPaddLinearVarNonlinear() and SCIPaddExprNonlinear() instead
- deprecated SCIPaddQuadVarLinearCoefQuadratic(), use SCIPaddLinearVarNonlinear() instead
- deprecated SCIPaddSquareCoefQuadratic(), use SCIPaddExprNonlinear() instead
- deprecated SCIPaddBilinTermQuadratic(), use SCIPaddExprNonlinear() instead
- deprecated SCIPchgLhsQuadratic(), use SCIPgetLhsNonlinear() instead
- deprecated SCIPchgRhsQuadratic(), use SCIPgetRhsNonlinear() instead
- deprecated SCIPgetNlRowQuadratic(), use SCIPgetNlRowNonlinear() instead
- removed SCIPgetNLinearVarsQuadratic(), SCIPgetLinearVarsQuadratic(), SCIPgetCoefsLinearVarsQuadratic(), SCIPgetNQuadVarTermsQuadratic(), SCIPgetQuadVarTermsQuadratic(), SCIPsortQuadVarTermsQuadratic(), SCIPfindQuadVarTermQuadratic(), SCIPgetNBilinTermsQuadratic(), SCIPgetBilinTermsQuadratic(), SCIPgetLhsQuadratic(), SCIPgetRhsQuadratic()
- removed SCIPgetLinvarMayDecreaseQuadratic(), SCIPgetLinvarMayIncreaseQuadratic()
- removed SCIPcheckCurvatureQuadratic() and SCIPisConvexConsQuadratic(), use SCIPcomputeExprQuadraticCurvature() instead
- removed SCIPisConvexQuadratic(), SCIPisConcaveQuadratic()
- removed SCIPgetViolationQuadratic() and SCIPgetFeasibilityQuadratic(), use SCIPgetAbsViolationNonlinear() instead
- removed SCIPisLinearLocalQuadratic(), SCIPaddToNlpiProblemQuadratic()
- removed SCIPchgLinearCoefQuadratic(), SCIPchgSquareCoefQuadratic(), SCIPchgBilinCoefQuadratic()
- renamed SCIPgetNAllBilinearTermsQuadratic() to SCIPgetNBilinTermsNonlinear() and changed argument from SCIP* to SCIP_CONSHDLR*
- renamed SCIPgetAllBilinearTermsQuadratic() to SCIPgetBilinTermsNonlinear() and replaced arguments by SCIP_CONSHDLR* and changed return type to SCIP_CONSNONLINEAR_BILINTERM*
- removed SCIPaddBilinearIneqQuadratic(), use SCIPinsertBilinearTermImplicitNonlinear() instead
- renamed SCIPcreateConsQuadratic() to SCIPcreateConsQuadraticNonlinear() and removed argument stickingatnode
- removed SCIPincludeConshdlrSOC()
- replaced SCIPcreateConsBasicSOC() by SCIPcreateConsBasicSOCNonlinear()
- deprecated SCIPcreateConsSOC(), use SCIPcreateConsBasicSOCNonlinear() instead
- deprecated SCIPgetNlRowSOC(), use SCIPgetNlRowNonlinear() instead
- removed SCIPgetNLhsVarsSOC(), SCIPgetLhsVarsSOC(), SCIPgetLhsCoefsSOC(), SCIPgetLhsOffsetsSOC(), SCIPgetLhsConstantSOC(), SCIPgetRhsVarSOC(), SCIPgetRhsCoefSOC(), SCIPgetRhsOffsetSOC(), use SCIPisSOCNonlinear() instead
- removed SCIPaddToNlpiProblemSOC()
- renamed SCIPincludeNonlinconsUpgrade() to SCIPincludeConsUpgradeNonlinear() and removed nodereform argument
- removed arguments nlinvars, linvars, lincoefs, nexprtrees, exprtrees, nonlincoefs, stickingatnode from SCIPcreateConsNonlinear() and added SCIP_EXPR* argument
- removed arguments nlinvars, linvars, lincoefs, nexprtrees, exprtrees, nonlincoefs from SCIPcreateConsBasicNonlinear() and added SCIP_EXPR* argument
- removed SCIPcreateConsNonlinear2(), SCIPcreateConsBasicNonlinear2()
- removed SCIPsetExprtreesNonlinear(), use SCIPchgExprNonlinear() instead
- removed SCIPaddExprtreesNonlinear()
- removed SCIPgetNLinearVarsNonlinear(), SCIPgetLinearVarsNonlinear(), SCIPgetLinearCoefsNonlinear()
- removed SCIPgetNExprtreesNonlinear(), SCIPgetExprtreesNonlinear(), SCIPgetExprtreeCoefsNonlinear(), SCIPgetExprgraphNodeNonlinear(), use SCIPgetExprNonlinear() instead
- removed argument scip from SCIPgetLhsNonlinear() and SCIPgetRhsNonlinear()
- removed SCIPcheckCurvatureNonlinear(), SCIPgetCurvatureNonlinear(), and SCIPgetExprtreeCurvaturesNonlinear(), use SCIPhasExprCurvature() instead
- renamed SCIPgetViolationNonlinear() to SCIPgetAbsViolationNonlinear()
- added arguments var and coef to SCIPgetLinvarMayDecreaseNonlinear() and SCIPgetLinvarMayIncreaseNonlinear() and changed return type to void
- removed SCIPgetExprgraphNonlinear()
- removed SCIPcomputeHyperplaneThreePoints(), use SCIPcomputeFacetVertexPolyhedralNonlinear() instead

### New API functions

- added SCIPallocClearMemory() and SCIPallocClearBlockMemory() to allocate a chunk of (block) memory
  that is initialized to zeros
- New internal functions for changing the default values of parameters:
    SCIPparamsetSetDefaultLongint(), SCIPparamsetSetDefaultReal(), SCIPparamsetSetDefaultChar(),
    SCIPparamsetSetDefaultString() and
    SCIPparamSetDefaultLongint(), SCIPparamSetDefaultReal(), SCIPparamSetDefaultChar(),
    SCIPparamSetDefaultString()
- new internal function SCIPisPackingPartitioningOrbitope() to check whether an orbitope is of
  packing or partitioning type
- new internal function SCIPcomputeOrbitVar() to compute the symmetry orbit of a variable
- added SCIPcalcFibHash(SCIP_Real) to hash a floating-point value to an unsigned integer
- added SCIPcomputeArraysIntersectionPtr() to compute intersection of two sorted arrays of pointers
- new function SCIPinterruptLP() (intended to be called from a different thread) that interrupts ongoing lp solve
- added SCIPcreateConsIndicatorGeneric() and SCIPcreateConsIndicatorGenericLinCons()
  which copy the interface of SCIPcreateConsIndicator() and SCIPcreateConsIndicatorLinCons() and
  add an activeone argument to specify whether the indicator constraint should be activated on 0 or 1.
  SCIPcreateConsIndicator() also adds a lessthanineq flag to choose whether the linear constraint is a less-than or greater-than inequality.
- added SCIPmarkDoNotAggrVar() to mark that a variable should not be aggregated
- added SCIPdoNotAggrVar() to query whether a variable should not be aggregated
- added SCIPdecompGetNBorderVars() and SCIPdecompGetNBorderConss() to get number of border variables/constraints
- added SCIPdecompGetVarsSize() and SCIPdecompGetConssSize() to get variable/constraint size for each block of a decomposition
- added SCIPincludeDialogDefaultBasic()
- added SCIPintervalAreDisjointEps(), SCIPintervalIntersectEps()
- added SCIPintervalEntropy()
- added SCIPintervalPropagateWeightedSum()
- added SCIPcalcRootNewton()
- added SCIPvarGetImplicVarBounds()
- added SCIPcreateRowprep(), SCIPfreeRowprep(), SCIPcopyRowprep(),
  SCIProwprepGetNVars(), SCIProwprepGetVars(), SCIProwprepGetCoefs(), SCIProwprepGetSide(), SCIProwprepGetSidetype(), SCIProwprepIsLocal(), SCIProwprepGetName(), SCIProwprepGetNModifiedVars(), SCIProwprepGetModifiedVars(),
  SCIProwprepReset(), SCIProwprepAddSide(), SCIProwprepAddConstant(), SCIProwprepSetSidetype(), SCIProwprepSetLocal(), SCIProwprepRecordModifications(),
  SCIPprintRowprep(), SCIPprintRowprepSol(), SCIPensureRowprepSize(), SCIPaddRowprepTerm(), SCIPaddRowprepTerms(), SCIPgetRowprepViolation(), SCIPisRowprepViolationReliable(),
  SCIPmergeRowprepTerms(), SCIPcleanupRowprep(), SCIPcleanupRowprep2(), SCIPscaleupRowprep(), SCIPscaleRowprep(),
  SCIPgetRowprepRowConshdlr(), SCIPgetRowprepRowCons(), SCIPgetRowprepRowSepa()
- added SCIPsetClockEnabled()
- added SCIPisSolveInterrupted() to check whether SCIPinterruptSolve() has been called
- added SCIPgetNPresolRounds()
- added SCIPgetNUnfixedLPCols()
- moved SCIPhistoryGetInferenceSum() and SCIPhistoryGetAvgConflictlength() from internal to public API

Expression handler:
- added SCIPincludeExprhdlr(), SCIPgetExprhdlrs(), SCIPgetNExprhdlrs(), SCIPfindExprhdlr()
- added SCIPgetExprhdlrVar(), SCIPgetExprhdlrValue(), SCIPgetExprhdlrSum(), SCIPgetExprhdlrProduct(), SCIPgetExprhdlrPower()
- added SCIPexprhdlrSetCopyFreeHdlr(), SCIPexprhdlrSetCopyFreeData(), SCIPexprhdlrSetPrint(), SCIPexprhdlrSetParse(), SCIPexprhdlrSetCurvature(), SCIPexprhdlrSetMonotonicity(), SCIPexprhdlrSetIntegrality(), SCIPexprhdlrSetHash(), SCIPexprhdlrSetCompare(), SCIPexprhdlrSetDiff(), SCIPexprhdlrSetIntEval(), SCIPexprhdlrSetSimplify(), SCIPexprhdlrSetReverseProp(), SCIPexprhdlrSetEstimate()
- added SCIPexprhdlrGetName(), SCIPexprhdlrGetDescription(), SCIPexprhdlrGetPrecedence(), SCIPexprhdlrGetData(), SCIPexprhdlrHasPrint(), SCIPexprhdlrHasBwdiff(), SCIPexprhdlrHasFwdiff(), SCIPexprhdlrHasIntEval(), SCIPexprhdlrHasEstimate(), SCIPexprhdlrHasInitEstimates(), SCIPexprhdlrHasSimplify(), SCIPexprhdlrHasCurvature(), SCIPexprhdlrHasMonotonicity(), SCIPexprhdlrHasReverseProp()
- added SCIPexprhdlrComp()
- added SCIPexprhdlrGetNIntevalCalls(), SCIPexprhdlrGetIntevalTime(), SCIPexprhdlrGetNReversepropCalls(), SCIPexprhdlrGetReversepropTime(), SCIPexprhdlrGetNCutoffs(), SCIPexprhdlrGetNDomainReductions(), SCIPexprhdlrIncrementNDomainReductions(), SCIPexprhdlrGetNEstimateCalls(), SCIPexprhdlrGetEstimateTime(), SCIPexprhdlrGetNBranchings(), SCIPexprhdlrIncrementNBranchings(), SCIPexprhdlrGetNSimplifyCalls(), SCIPexprhdlrGetSimplifyTime(), SCIPexprhdlrGetNSimplifications()
- added SCIPprintExpressionHandlerStatistics()
- added SCIPincludeExprhdlrEntropy(), SCIPcreateExprEntropy(), SCIPisExprEntropy()
- added SCIPincludeExprhdlrErf(), SCIPcreateExprErf(), SCIPisExprErf()
- added SCIPcreateExprAbs(), SCIPincludeExprhdlrAbs(), SCIPisExprAbs()
- added SCIPcreateExprExp(), SCIPincludeExprhdlrExp(), SCIPisExprExp()
- added SCIPcreateExprLog(), SCIPincludeExprhdlrLog(), SCIPisExprLog()
- added SCIPcreateExprPow(), SCIPcreateExprSignpower(), SCIPincludeExprhdlrPow(), SCIPincludeExprhdlrSignpower(), SCIPisExprSignpower(), SCIPgetExponentExprPow(), SCIPisExprPower()
- added SCIPincludeExprhdlrProduct(), SCIPcreateExprProduct(), SCIPgetCoefExprProduct(), SCIPisExprProduct()
- added SCIPincludeExprhdlrSum(), SCIPcreateExprSum(), SCIPsetConstantExprSum(), SCIPappendExprSumExpr(), SCIPmultiplyByConstantExprSum(), SCIPgetCoefsExprSum(), SCIPgetConstantExprSum(), SCIPisExprSum()
- added SCIPincludeExprhdlrSin(), SCIPcreateExprSin(), SCIPincludeExprhdlrCos(), SCIPcreateExprCos(), SCIPisExprSin(), SCIPisExprCos()
- added SCIPincludeExprhdlrValue(), SCIPcreateExprValue(), SCIPgetValueExprValue(), SCIPisExprValue()
- added SCIPincludeExprhdlrVar(), SCIPcreateExprVar(), SCIPgetVarExprVar(), SCIPisExprVar()
- added SCIPincludeExprhdlrVaridx(), SCIPcreateExprVaridx(), SCIPisExprVaridx(), SCIPgetIndexExprVaridx(), SCIPsetIndexExprVaridx()

Expression:
- added SCIPcaptureExpr(), SCIPreleaseExpr(), SCIPexprGetNUses()
- added SCIPexprGetHdlr(), SCIPexprGetData(), SCIPexprSetData(), SCIPexprGetOwnerData()
- added SCIPevalExpr(), SCIPgetExprNewSoltag(), SCIPexprGetEvalValue(), SCIPexprGetEvalTag()
- added SCIPevalExprGradient(), SCIPevalExprHessianDir(), SCIPexprGetDerivative(), SCIPexprGetDot(), SCIPexprGetBardot(), SCIPexprGetDiffTag()
- added SCIPevalExprActivity(), SCIPexprGetActivity(), SCIPexprGetActivityTag(), SCIPexprSetActivity()
- added SCIPcomputeExprCurvature(), SCIPexprGetCurvature(), SCIPexprSetCurvature()
- added SCIPcomputeExprIntegrality(), SCIPexprIsIntegral(), SCIPexprSetIntegrality()
- added SCIPcheckExprQuadratic(), SCIPfreeExprQuadratic(), SCIPevalExprQuadratic(), SCIPprintExprQuadratic(), SCIPcomputeExprQuadraticCurvature()
- added SCIPexprGetQuadraticData(), SCIPexprGetQuadraticQuadTerm(), SCIPexprGetQuadraticBilinTerm(), SCIPexprAreQuadraticExprsVariables()
- added SCIPcreateExpr(), SCIPcreateExpr2(), SCIPcreateExprQuadratic(), SCIPcreateExprMonomial()
- added SCIPappendExprChild(), SCIPreplaceExprChild(), SCIPremoveExprChildren()
- added SCIPduplicateExpr(), SCIPduplicateExprShallow(), SCIPcopyExpr()
- added SCIPparseExpr()
- added SCIPprintExpr(), SCIPdismantleExpr()
- added SCIPprintExprDotInit(), SCIPprintExprDotInit2(), SCIPprintExprDot(), SCIPprintExprDotFinal(), SCIPshowExpr()
- added SCIPcompareExpr(), SCIPhashExpr()
- added SCIPsimplifyExpr(), SCIPreplaceCommonSubexpressions()
- added SCIPgetExprNVars(), SCIPgetExprVarExprs()
- added SCIPcallExprPrint(), SCIPcallExprCurvature(), SCIPcallExprMonotonicity(), SCIPcallExprEval(), SCIPcallExprEvalFwdiff(), SCIPcallExprInteval(), SCIPcallExprEstimate(), SCIPcallExprInitestimates(), SCIPcallExprSimplify(), SCIPcallExprReverseprop()
- added SCIPexprcurvPowerInv(), SCIPexprcurvMonomialInv()

Expression iterator:
- added SCIPcreateExpriter(), SCIPfreeExpriter()
- added SCIPexpriterIsInit(), SCIPexpriterInit()
- added SCIPexpriterRestartDFS(), SCIPexpriterSetStagesDFS(), SCIPexpriterGetCurrent(), SCIPexpriterGetStageDFS(), SCIPexpriterGetChildIdxDFS(), SCIPexpriterGetChildExprDFS(), SCIPexpriterGetParentDFS()
- added SCIPexpriterGetCurrentUserData(), SCIPexpriterGetChildUserDataDFS(), SCIPexpriterGetExprUserData(), SCIPexpriterSetCurrentUserData(), SCIPexpriterSetExprUserData(), SCIPexpriterSetChildUserData()
- added SCIPexpriterGetNext(), SCIPexpriterSkipDFS(), SCIPexpriterIsEnd()
- added SCIPexprintHessianSparsity(), SCIPexprintHessian()

Constraint handlers for NLP:
- added SCIPgetCurBoundsTagNonlinear(), SCIPgetLastBoundRelaxTagNonlinear(), SCIPincrementCurBoundsTagNonlinear()
- added SCIPgetVarExprHashmapNonlinear()
- added SCIPprocessRowprepNonlinear()
- added SCIPassumeConvexNonlinear()
- added SCIPcollectBilinTermsNonlinear(), SCIPgetBilinTermIdxNonlinear(), SCIPgetBilinTermNonlinear(), SCIPevalBilinAuxExprNonlinear(), SCIPinsertBilinearTermExistingNonlinear(), SCIPinsertBilinearTermImplicitNonlinear()
- added SCIPcomputeFacetVertexPolyhedralNonlinear()
- added SCIPgetExprNonlinear()
- added SCIPcheckQuadraticNonlinear(), SCIPchgLhsNonlinear(), SCIPchgRhsNonlinear(), SCIPchgExprNonlinear(), SCIPaddExprNonlinear()
- added SCIPgetRelViolationNonlinear()
- added SCIPgetExprNLocksPosNonlinear(), SCIPgetExprNLocksNegNonlinear(), SCIPgetExprAuxVarNonlinear(), SCIPgetExprNEnfosNonlinear(), SCIPgetExprEnfoDataNonlinear(), SCIPsetExprEnfoAuxValueNonlinear()
- added SCIPgetExprNPropUsesActivityNonlinear(), SCIPgetExprNSepaUsesActivityNonlinear(), SCIPgetExprNAuxvarUsesNonlinear(), SCIPregisterExprUsageNonlinear()
- added SCIPgetExprAbsOrigViolationNonlinear(), SCIPgetExprAbsAuxViolationNonlinear(), SCIPgetExprRelAuxViolationNonlinear()
- added SCIPgetExprBoundsNonlinear(), SCIPtightenExprIntervalNonlinear(), SCIPmarkExprPropagateNonlinear()
- added SCIPaddExprViolScoreNonlinear(), SCIPaddExprsViolScoreNonlinear(), SCIPgetExprViolScoreNonlinear()
- added SCIPgetExprPartialDiffNonlinear(), SCIPgetExprPartialDiffGradientDirNonlinear()
- added SCIPevalExprQuadraticAuxNonlinear()
- added SCIPincludeNlhdlrNonlinear(), SCIPfindNlhdlrNonlinear(), SCIPgetNNlhdlrsNonlinear(), SCIPgetNlhdlrsNonlinear(), SCIPgetNlhdlrExprDataNonlinear()
- added SCIPcreateConsQuadraticNonlinear() and SCIPcreateConsBasicQuadraticNonlinear() to create a nonlinear constraint that is quadratic
- added SCIPcreateConsBasicSignpowerNonlinear() to create a nonlinear constraint that looks like the former abspower or signpower constraints

Nonlinear Handler:
- added SCIPincludeNlhdlrBilinear(), SCIPgetExprsBilinear(), SCIPgetExprsdataBilinear(), SCIPgetNExprsBilinear(), SCIPaddIneqBilinear()
- added SCIPincludeNlhdlrConvex(), SCIPincludeNlhdlrConcave(), SCIPhasExprCurvature()
- added SCIPincludeNlhdlrDefault()
- added SCIPincludeNlhdlrPerspective()
- added SCIPincludeNlhdlrQuadratic()
- added SCIPincludeNlhdlrQuotient()
- added SCIPincludeNlhdlrSoc(), SCIPisSOCNonlinear(), SCIPfreeSOCArraysNonlinear()
- added SCIPnlhdlrSetCopyHdlr(), SCIPnlhdlrSetFreeHdlrData(), SCIPnlhdlrSetFreeExprData(), SCIPnlhdlrSetInitExit(), SCIPnlhdlrSetProp(), SCIPnlhdlrSetSepa()
- added SCIPnlhdlrGetName(), SCIPnlhdlrGetDesc(), SCIPnlhdlrGetDetectPriority(), SCIPnlhdlrGetEnfoPriority(), SCIPnlhdlrIsEnabled(), SCIPnlhdlrGetData()
- added SCIPnlhdlrHasIntEval(), SCIPnlhdlrHasReverseProp(), SCIPnlhdlrHasInitSepa(), SCIPnlhdlrHasExitSepa(), SCIPnlhdlrHasEnfo(), SCIPnlhdlrHasEstimate()
- added SCIPnlhdlrComp()

NLPI:
- added SCIPgetNlpiSolverPointer(), SCIPcreateNlpiProblem(), SCIPfreeNlpiProblem(), SCIPgetNlpiProblemPointer(), SCIPaddNlpiVars(), SCIPaddNlpiConstraints(), SCIPsetNlpiObjective(), SCIPchgNlpiVarBounds(), SCIPchgNlpiConsSides(), SCIPdelNlpiVarSet(), SCIPdelNlpiConsSet(), SCIPchgNlpiLinearCoefs(), SCIPchgNlpiExpr(), SCIPchgNlpiObjConstant(), SCIPsetNlpiInitialGuess(), SCIPsolveNlpiParam(), SCIPgetNlpiSolstat(), SCIPgetNlpiTermstat(), SCIPgetNlpiSolution(), SCIPgetNlpiStatistics()
- added SCIPincludeNlpSolverAll()
- added SCIPincludeNlpSolverFilterSQP(), SCIPgetSolverNameFilterSQP(), SCIPgetSolverDescFilterSQP(), SCIPisFilterSQPAvailableFilterSQP()
- added SCIPincludeNlpSolverIpopt()
- added SCIPincludeNlpSolverWorhp()
- added SCIPnlpiOracleChgExpr()
- added SCIPcreateNlpiProblemFromNlRows()
- added SCIPnlpiOracleGetObjectiveConstant()
- added SCIPnlpiOracleIsVarNonlinear(), SCIPnlpiOracleGetVarCounts(), SCIPnlpiOracleIsConstraintNonlinear()
- added SCIPnlpiGetNProblems(), SCIPnlpiGetProblemTime(), SCIPnlpiGetNSolves(), SCIPnlpiGetSolveTime(), SCIPnlpiGetEvalTime(), SCIPnlpiGetNIterations(), SCIPnlpiGetNTermStat(), SCIPnlpiGetNSolStat(), SCIPnlpiMergeStatistics()
- added SCIPmergeNLPIStatistics(), SCIPprintNLPIStatistics()
- added SCIPnlpiOracleResetEvalTime(), SCIPnlpiOracleGetEvalTime()
- added SCIPaddNlpiProblemNlRows()

Cut Selector:
- added SCIPincludeCutsel(), SCIPincludeCutselBasic(), SCIPsetCutselCopy(), SCIPsetCutselFree(), SCIPsetCutselInit(), SCIPsetCutselExit(),  SCIPsetCutselInitsol(), SCIPsetCutselExitsol(), SCIPfindCutsel(), SCIPgetCutsels(), SCIPgetNCutsels(), SCIPsetCutselPriority()
- added SCIPcutselGetName(), SCIPcutselGetData(), SCIPcutselGetDesc(), SCIPcutselGetPriority(), SCIPcutselSetData(), SCIPcutselIsInitialized(), SCIPcutselGetSetupTime(), SCIPcutselGetTime()

### Command line interface
### Interfaces to external software

- removed GAMS interface (originally in interfaces/gams) and reading capability of gms reader;
  the removed interface was a poorly maintained copy of the GAMS/SCIP interface that is available at
  https://github.com/coin-or/GAMSlinks
- integrated AMPL interface into main SCIP executable, that is, added possibility to use SCIP executable as solver in AMPL
  (AMPL calls solver with name of .nl file and -AMPL as arguments; SCIP will then attempt to solve the problem and write an AMPL solution file)
- the ZIMPL interface has been updated to support ZIMPL 3.4.1;
  the minimal required ZIMPL version is now 3.4.1

### Changed parameters

- Extended range of parameter "misc/usesymmetry" from [0,3] to [0,7], changed default from 3 to 5
- deleted parameter "constraints/orbitope/usedynamicprop"
- changed type of parameter "propagating/symmetry/recomputerestart" from SCIP_Bool to int with range [0,2]
- deleted parameter "propagating/symmetry/disableofrestart"
- parameter "heuristics/padm/original" is now an advanced parameter
- removed constraints/nonlinear/linfeasshift, constraints/nonlinear/reformulate, constraints/nonlinear/maxexpansionexponent, constraints/nonlinear/sepanlpmincont
- removed constraints/nonlinear/upgrade/abspower
- removed constraints/nonlinear/upgrade/and, use constraints/nonlinear/reformbinprodsand instead
- removed constraints/nonlinear/upgrade/bivariate
- removed constraints/nonlinear/upgrade/quadratic, use nlhdlr/quadratic/enabled instead
- changed default of constraints/nonlinear/maxproprounds from 1 to 10
- replaced constraints/nonlinear/enfocutsremovable by constraints/nonlinear/rownotremovable
- replaced constraints/nonlinear/cutmaxrange by separating/maxcoefratiofacrowprep
- removed constraints/quadratic/sepafreq, constraints/quadratic/propfreq, constraints/quadratic/proptiming, constraints/quadratic/eagerfreq, constraints/quadratic/maxprerounds, constraints/quadratic/delaysepa, constraints/quadratic/delayprop, constraints/quadratic/presoltiming
- removed constraints/quadratic/replacebinaryprod, use constraints/nonlinear/reformbinprodsfac instead
- removed constraints/quadratic/empathy4and, use constraints/nonlinear/reformbinprodsand instead
- removed constraints/quadratic/binreforminitial, constraints/quadratic/binreformbinaryonly, constraints/quadratic/binreformmaxcoef
- removed constraints/quadratic/cutmaxrange, constraints/quadratic/mincurvcollectbilinterms, constraints/quadratic/linearizeheursol, constraints/quadratic/checkcurvature, constraints/quadratic/checkfactorable, constraints/quadratic/checkquadvarlocks, constraints/quadratic/linfeasshift
- removed constraints/quadratic/maxdisaggrsize, constraints/quadratic/disaggrmergemethod, constraints/quadratic/maxproprounds, constraints/quadratic/maxproproundspresolve, constraints/quadratic/enfolplimit, constraints/quadratic/sepanlpmincont, constraints/quadratic/enfocutsremovable
- removed constraints/quadratic/gaugecuts, constraints/quadratic/interiorcomputation, constraints/quadratic/projectedcuts, constraints/quadratic/branchscoring, constraints/quadratic/usebilinineqbranch, constraints/quadratic/bilinineqmaxseparounds,
- removed constraints/quadratic/minscorebilinterms, use nlhdlr/bilinear/enabled instead
- removed constraints/quadratic/upgrade/linear, constraints/quadratic/upgrade/abspower, constraints/quadratic/upgrade/bivariate, constraints/quadratic/upgrade/bounddisjunction
- removed constraints/quadratic/upgrade/soc, use nlhdlr/soc/enabled instead
- renamed constraints/quadratic/upgrade/setppc to constraints/nonlinear/upgrade/setppc
- removed constraints/abspower/sepafreq, constraints/abspower/propfreq, constraints/abspower/proptiming, constraints/abspower/eagerfreq, constraints/abspower/maxprerounds, constraints/abspower/delaysepa, constraints/abspower/delayprop, constraints/abspower/presoltiming
- removed constraints/abspower/cutmaxrange, constraints/abspower/projectrefpoint, constraints/abspower/preferzerobranch, constraints/abspower/branchminconverror, constraints/abspower/addvarboundcons, constraints/abspower/linfeasshift, constraints/abspower/dualpresolve, constraints/abspower/sepainboundsonly, constraints/abspower/sepanlpmincont, constraints/abspower/enfocutsremovable
- removed constraints/bivariate/sepafreq, constraints/bivariate/propfreq, constraints/bivariate/proptiming, constraints/bivariate/eagerfreq, constraints/bivariate/maxprerounds, constraints/bivariate/delaysepa, constraints/bivariate/delayprop, constraints/bivariate/presoltiming
- removed constraints/bivariate/cutmaxrange, constraints/bivariate/linfeasshift, constraints/bivariate/maxproprounds, constraints/bivariate/ninitlprefpoints, constraints/bivariate/enfocutsremovable
- removed constraints/soc/sepafreq, constraints/soc/propfreq, constraints/soc/proptiming, constraints/soc/eagerfreq, constraints/soc/maxprerounds, constraints/soc/delaysepa, constraints/soc/delayprop, constraints/soc/presoltiming
- removed constraints/soc/projectpoint, constraints/soc/nauxvars, constraints/soc/glineur, constraints/soc/sparsify, constraints/soc/sparsifymaxloss, constraints/soc/sparsifynzgrowth, constraints/soc/linfeasshift, constraints/soc/nlpform, constraints/soc/sepanlpmincont, constraints/soc/enfocutsremovable, constraints/soc/disaggregate
- removed constraints/soc/generalsocupgrade, use nlhdlr/soc/compeigenvalues instead
- changed default of presolving/qpkktref/maxrounds from -1 to 0
- changed default of propagating/obbt/onlynonconvexvars from FALSE to TRUE
- changed default of heuristics/subnlp/resolvetolfactor from 0.001 to 1.0
- removed heuristics/subnlp/nlpoptfile, use nlpi/ipopt/optfile instead
- removed separating/convexproj/nlptimelimit
- removed separating/gauge/nlptimelimit
- removed heuristics/subnlp/nlptimelimit and heuristics/subnlp/nlpiterlimit
- removed heuristics/subnlp/resolvetolfactor and heuristics/subnlp/resolvefromscratch
- changed default of heuristics/subnlp/itermin to 20
- renamed heuristics/subnlp/iteroffset to heuristics/subnlp/nodesoffset
- renamed heuristics/subnlp/iterquotient to heuristics/subnlp/nodesfactor
- removed heuristics/subnlp/runalways, use heuristics/subnlp/nodesoffset=INT_MAX and heuristics/subnlp/successrateexp = 0.0 instead
- removed heuristics/subnlp/minimprove, heuristics/multistart/nlpminimpr
- Removed parameters for strongcg separator: separating/strongcg/..., i.e.,
  maxrounds, maxroundsroot, maxsepacutsroot, maxsepacuts, dynamiccuts. One can control the
  strongcg behavior throught the parameters of sepa_gomory.
- renamed separating/{minortho,minorthoroot,objparalfac,intsupportfac} to cutselection/hybrid/{minortho,minorthoroot,objparalweight,intsupportweight}

### New parameters

- It is now possible to add orbitope constraints to handle symmetries even if not all variables
  in a component of the symmetry group are binary. This feature can be enabled using the
  parameter "propagating/symmetry/onlybinorbitope".

- new parameter "propagating/symmetry/sstleaderrule" to select a rule for selecting the
  leader in SST cuts
- new parameter "propagating/symmetry/ssttiebreakrule" to select a tiebreak rule for selecting the
  leader in SST cuts
- new parameter "propagating/symmetry/sstleadervartype" to select the possible variable types
  for a leader in SST cuts
- new parameter "propagating/symmetry/addconflictcuts" to control whether SST cuts are added if
  a binary leader variable is in conflict with a variable in its orbit
- new parameter "propagating/symmetry/sstaddcuts" to control whether SST cuts are added
- new parameter "propagating/symmetry/sstmixedcomponents" to control whether SST cuts are added
  if a symmetry component contains variables of different types
- new parameter "propagating/symmetry/detectsubgroups" to search for orbitopes defined by subgroups
- new parameter "propagating/symmetry/addweaksbcs" to add Schreier Sims cuts for a single
  variable orbit in case an orbitope subgroup is detected
- new parameter "propagating/symmetry/addstrongsbcs" to add symretope facets for a single
  variable orbit on which the symmetry group acts like a symmetric group
- new parameter "propagating/symmetry/maxnconsssubgroup" to control up to which number of
  constraints subgroups are detected
- new parameter "propagating/symmetry/preferlessrows" to control whether orbitopes with
  smallest number of rows shall be computed by the subgroup detection heuristic
- new parameter "propagating/symmetry/usedynamicprop" to control if rows of full orbitope
  shall be ordered dynamically in propagation
- new parameter "separating/filtercutpoolrel" to control whether cutpool uses
  a dynamic strategy to separate only cuts with high relative efficacy
- if run from AMPL: display/statistics to enable printing detailed solve statistics after solve
- if run from AMPL: display/logfile to specify name of file to write SCIP log to (additionally to writing to stdout)
- constraints/nonlinear/propauxvars, constraints/nonlinear/varboundrelax, constraints/nonlinear/varboundrelaxamount, constraints/nonlinear/conssiderelaxamount
- constraints/nonlinear/vpmaxperturb, constraints/nonlinear/vpadjfacetthresh, constraints/nonlinear/vpdualsimplex
- constraints/nonlinear/bilinmaxnauxexprs, constraints/nonlinear/forbidmultaggrnlvar, constraints/nonlinear/checkvarlocks, constraints/nonlinear/violscale
- constraints/nonlinear/reformbinprods, constraints/nonlinear/reformbinprodsand, constraints/nonlinear/reformbinprodsfac
- constraints/nonlinear/tightenlpfeastol, constraints/nonlinear/propinenforce, constraints/nonlinear/weakcutthreshold, constraints/nonlinear/strongcutmaxcoef, constraints/nonlinear/strongcutefficacy, constraints/nonlinear/forcestrongcut, constraints/nonlinear/enfoauxviolfactor, constraints/nonlinear/weakcutminviolfactor
- constraints/nonlinear/branching/aux, constraints/nonlinear/branching/external, constraints/nonlinear/branching/highviolfactor, constraints/nonlinear/branching/highscorefactor, constraints/nonlinear/branching/violweight, constraints/nonlinear/branching/dualweight, constraints/nonlinear/branching/pscostweight, constraints/nonlinear/branching/domainweight, constraints/nonlinear/branching/vartypeweight, constraints/nonlinear/branching/scoreagg, constraints/nonlinear/branching/violsplit, constraints/nonlinear/branching/pscostreliable
- constraints/nonlinear/linearizeheursol
- nlhdlr/default/enabled
- nlhdlr/convex/enabled, nlhdlr/convex/detectsum, nlhdlr/convex/extendedform, nlhdlr/convex/cvxquadratic, nlhdlr/convex/cvxsignomial, nlhdlr/convex/cvxprodcomp, nlhdlr/convex/handletrivial
- nlhdlr/concave/enabled, nlhdlr/concave/detectsum, nlhdlr/concave/cvxquadratic, nlhdlr/concave/cvxsignomial, nlhdlr/concave/cvxprodcomp, nlhdlr/concave/handletrivial
- nlhdlr/bilinear/enabled, nlhdlr/bilinear/useinteval, nlhdlr/bilinear/usereverseprop, nlhdlr/bilinear/maxseparoundsroot, nlhdlr/bilinear/maxseparounds, nlhdlr/bilinear/maxsepadepth
- nlhdlr/perspective/enabled, nlhdlr/perspective/maxproprounds, nlhdlr/perspective/mindomreduction, nlhdlr/perspective/minviolprobing, nlhdlr/perspective/probingonlyinsepa, nlhdlr/perspective/probingfreq, nlhdlr/perspective/convexonly, nlhdlr/perspective/tightenbounds, nlhdlr/perspective/adjrefpoint
- nlhdlr/quadratic/enabled, nlhdlr/quadratic/useintersectioncuts, nlhdlr/quadratic/usestrengthening, nlhdlr/quadratic/useboundsasrays, nlhdlr/quadratic/ncutslimit, nlhdlr/quadratic/ncutslimitroot, nlhdlr/quadratic/maxrank, nlhdlr/quadratic/mincutviolation, nlhdlr/quadratic/minviolation, nlhdlr/quadratic/atwhichnodes, nlhdlr/quadratic/nstrengthlimit, nlhdlr/quadratic/ignorebadrayrestriction, nlhdlr/quadratic/ignorehighre
- nlhdlr/quotient/enabled
- nlhdlr/soc/enabled, nlhdlr/soc/mincutefficacy, nlhdlr/soc/compeigenvalues
- propagating/obbt/createlincons
- propagating/symmetry/onlybinarysymmetry
- separating/minor/priority, separating/minor/freq, separating/minor/maxbounddist, separating/minor/delay, separating/minor/expbackoff, separating/minor/maxminorsconst, separating/minor/maxminorsfac, separating/minor/mincutviol, separating/minor/maxrounds, separating/minor/maxroundsroot, separating/minor/ignorepackingconss
- separating/rlt/priority, separating/rlt/freq, separating/rlt/maxbounddist, separating/rlt/delay, separating/rlt/expbackoff, separating/rlt/maxncuts, separating/rlt/maxunknownterms, separating/rlt/maxusedvars, separating/rlt/maxrounds, separating/rlt/maxroundsroot, separating/rlt/onlyeqrows, separating/rlt/onlycontrows, separating/rlt/onlyoriginal, separating/rlt/useinsubscip, separating/rlt/useprojection, separating/rlt/detecthidden, separating/rlt/hiddenrlt, separating/rlt/addtopool, separating/rlt/goodscore, separating/rlt/badscore, separating/rlt/objparalweight, separating/rlt/efficacyweight, separating/rlt/dircutoffdistweight, separating/rlt/goodmaxparall, separating/rlt/maxparall
- separating/interminor/usestrengthening, separating/interminor/usebounds, separating/interminor/mincutviol, separating/interminor/maxrounds, separating/interminor/maxroundsroot
- table/cons_nonlinear/active, table/nlhdlr/active, table/exprhdlr/active, table/nlpi/active, table/nlhdlr_bilinear/active, table/nlhdlr_quadratic/active
- expr/log/minzerodistance, expr/pow/minzerodistance
- benders/default/maxslackvarcoef to specify maximal coefficient for slack variables; if exceeded, slack variables are fixed to zero
- nlpi/ipopt/optfile to specify name of Ipopt options file to use for every solve with Ipopt
- nlpi/ipopt/print_level, nlpi/ipopt/hsllib, nlpi/ipopt/pardisolib, nlpi/ipopt/linear_solver, nlpi/ipopt/linear_system_scaling, nlpi/ipopt/nlp_scaling_method, nlpi/ipopt/mu_strategy, nlpi/ipopt/hessian_approximation
- nlpi/ipopt/warm_start_push
- timing/nlpieval
- heuristics/subnlp/iterinit, heuristics/subnlp/ninitsolves, heuristics/subnlp/successrateexp
- heuristics/subnlp/expectinfeas, heuristics/subnlp/opttol, heuristics/subnlp/feastolfactor
- heuristics/subnlp/presolveemphasis, heuristics/subnlp/setcutoff
- new parameters "branching/inference/conflictprio" and "branching/inference/cutoffprio" that allow
  using the different score criteria in inference branching hierarchically
- new parameters "heuristics/alns/nodesquotmin", "heuristics/alns/maxcallssamesol" and "heuristics/alns/initduringroot"
  to control neighborhoods in ALNS
- new parameter "benders/default/benderscut/optimality/mir" to control whether mixed-integer rounding procedure is applied to Benders optimality cuts
- new parameter "misc/avoidmemout" to try to avoid running into memory limit
- cutselection/hybrid/dircutoffdistweight, cutselection/hybrid/efficacyweight, cutselection/hybrid/intsupportweight, cutselection/hybrid/objparalweight, cutselection/hybrid/priority
- new parameter "decomposition/disablemeasures" to disable expensive measures in SCIPcomputeDecompStats()
- new parameter "presolving/milp/probfilename" filename to write the problem to a file before MILP presolving starts

### Data structures

- removed quadratic terms from NLROWs
- removed SCIP_NLPPAR_INFINITY from SCIP_NLPPARAM enum
- added types SYM_OPTYPE, SYM_CONSTTYPE, SYM_RHSTYPE, SYM_EXPRDATA
- removed class SCIPInterval
- removed enum SCIP_EXPROP
- removed union SCIP_EXPROPDATA, added SCIP_EXPRDATA
- removed struct SCIP_EXPRTREE, use SCIP_EXPR instead
- removed structs SCIP_QUADELEM, SCIP_EXPRDATA_QUADRATIC, SCIP_EXPRDATA_MONOMIAL, SCIP_EXPRDATA_POLYNOMIAL, SCIP_EXPRDATA_USER
- removed structs SCIP_EXPRGRAPHNODE, SCIP_EXPRGRAPH
- removed type SCIP_EXPRBOUNDSTATUS
- removed struct SCIP_USEREXPRDATA
- added enum SCIP_MONOTONE
- added structs SCIP_EXPRHDLR, SCIP_EXPRHDLRDATA
- added union SCIP_EXPRITER_USERDATA
- added enum SCIP_EXPRITER_TYPE
- added structs SCIP_EXPRITERDATA, SCIP_EXPRITER
- added type SCIP_EXPRPRINT_WHAT, struct SCIP_EXPRPRINTDATA
- removed enum SCIP_BIVAR_CONVEXITY
- removed structs SCIP_QUADVAREVENTDATA, SCIP_QUADVARTERM, SCIP_BILINTERM
- added structs SCIP_CONSNONLINEAR_AUXEXPR, SCIP_CONSNONLINEAR_BILINTERM
- added type SCIP_NLHDLR_METHOD
- added structs SCIP_NLHDLR, SCIP_NLHDLRDATA, SCIP_NLHDLREXPRDATA
- enum SCIP_NLPPARAM has been changed to a struct that holds values of parameters for an NLP solve
- removed SCIP_NLPPAR_OPTFILE/optfile from SCIP_NLPPARAM
- added SCIP_NLPTERMSTAT_INTERRUPT to SCIP_NLPTERMSTAT enum; returned from NLP solver if SCIPinterruptSolve() has been called
- renamed SCIP_NLPTERMSTAT_TILIM to SCIP_NLPTERMSTAT_TIMELIMIT
- renamed SCIP_NLPTERMSTAT_ITLIM to SCIP_NLPTERMSTAT_ITERLIMIT
- renamed SCIP_NLPTERMSTAT_LOBJLIM to SCIP_NLPTERMSTAT_LOBJLIMIT
- renamed SCIP_NLPTERMSTAT_NUMERR to SCIP_NLPTERMSTAT_NUMERICERROR
- renamed SCIP_NLPTERMSTAT_EVALERR to SCIP_NLPTERMSTAT_EVALERROR
- renamed SCIP_NLPTERMSTAT_MEMERR to SCIP_NLPTERMSTAT_OUTOFMEMORY
- renamed SCIP_NLPTERMSTAT_LICERR to SCIP_NLPTERMSTAT_LICENSEERROR
- added evaltime to SCIP_NLPSTATISTICS
- added structs SCIP_CUTSEL, SCIP_CUTSELDATA

Deleted files
-------------

- interfaces/gams/*
- interfaces/ampl/*
- src/nlpi/*
- src/scip/cons_bivariate.{c,h}
- src/scip/pub_misc_nonlinear.h
- src/scip/misc_nonlinear.c
- src/scip/scip_nonlinear.{c,h}
- src/scip/sepa_strongcg.{h|c}

Unit tests
----------

- added cons/linear/nonlinupgd.c
- added cons/nonlinear/addcons.c
- added cons/nonlinear/bilinhash.c
- added cons/nonlinear/check.c
- added cons/nonlinear/copy.c
- added cons/nonlinear/create_nlrow.c
- added cons/nonlinear/curvature.c
- added cons/nonlinear/glbconss.c
- added cons/nonlinear/hessian.c
- added cons/nonlinear/locks.c
- added cons/nonlinear/nlhdlr.c
- added cons/nonlinear/nlhdlr_bilinear.c
- added cons/nonlinear/nlhdlr_concave.c
- added cons/nonlinear/nlhdlr_convex.c
- added cons/nonlinear/nlhdlr_perspective.c
- added cons/nonlinear/nlhdlr_quadratic.c
- added cons/nonlinear/nlhdlr_quotient.c
- added cons/nonlinear/nlhdlr_soc.c
- added cons/nonlinear/parse.c
- added cons/nonlinear/presolve.c
- added cons/nonlinear/propagate.c
- added cons/nonlinear/readers.c
- added cons/nonlinear/reformbinprods.c
- added cons/nonlinear/repair.c
- added cons/nonlinear/transform.c
- added cons/nonlinear/vertexpolyhedral.c
- removed cons/nonlinear/getCoeffsAndConstantFromLinearExpr.c
- removed cons/soc/upgrade.c
- added expr/abs/estimation.c
- added expr/commonsubexprs.c
- added expr/compare.c
- added expr/copy.c
- added expr/cos/cos.c
- added expr/cos/estimation.c
- added expr/curvature.c
- added expr/derivative.c
- added expr/entropy/entropy.c
- added expr/entropy/estimation.c
- added expr/eval.c
- added expr/exp/estimation.c
- added expr/free.c
- added expr/getvarexprs.c
- added expr/hash.c
- added expr/hessian.c
- added expr/integrality.c
- added expr/iterator.c
- added expr/log/estimation.c
- added expr/monotonicity.c
- added expr/parse.c
- added expr/pow/estimation.c
- added expr/pow/pow.c
- added expr/product/estimation.c
- added expr/quad.c
- added expr/simplify.c
- added expr/sin/estimation.c
- added expr/sin/sin.c
- added expr/sum/estimation.c
- added nlpi/exprinterpret.c
- speedup test nlpi:solveQP in nlpi/nlpi.c
- added test projection:transitivity in prob/obbt.c
- added reader/nl.c
- added test intervalarith:sincos in scip/intervalarith.c
- added sepa/minor.c
- added sepa/rlt/cuts.c
- added sepa/rlt/product_detection.c
- added sepa/rlt/separation.c
- added tests test_compute_symmetry:expr{1,2,3,4} in symmetry/compute.c

Testing
-------

Build system
------------

- the separate NLPI library has been integrated into the main SCIP library;
  uses of NLPILIBFILE or NLPILIBSRC in Makefiles that use make/make.project
  should be removed

### Cmake

- replace flag PARASCIP by THREADSAFE
- option AMPL is now ON by default
- add -D_XOPEN_SOURCE=600 cflag for compilation on systems other than windows
- add compile options directly instead of modifying CMAKE_C_FLAGS and CMAKE_CXX_FLAGS

### Makefile

- prefix PKG_CONFIG_PATH with Ipopt's pkgconfig dir instead of postfixing
- replace flag PARASCIP by THREADSAFE
- flag AMPL is now true by default
- libscip has been renamed to libscipbase and libscipsolver has been renamed to libscip
  in order to have the same library names for makefiles and cmake. For downward
  compatibility libscipsolver still exists (as a link).

Fixed bugs
----------

- fixed handling of multi-aggregation in cons_symresack and cons_orbisack
- SCIPgetLowerbound() now consistently returns infinity when status is infeasible
- improved the likelihood that a solution that satisfies the nonlinear constraints in the transformed (presolved) problem is also feasible for the original problem
- worked around a problem with derivatives of pow at 0 with non-integer exponents in CppAD
- fixed that setting of feasiblity and optimiality tolerance for NLP relaxation was overwritten with defaults when solving NLP
- fixed variance computation in t-value computation in hypothesis testing of reliability branching
- fixed potential overflow in cuts.c:evaluateLiftingFunctionKnapsack()
- do not transfer dual reductions to main SCIP in sepa_rapidlearning if strong dual reductions are forbidden
- fixed a bug in cons_setppc.c:removeDoubleAndSingletonsAndPerformDualpresolve() which led to wrong variable aggregations
- added missing redundancy check to coefficient tightening routine in cons_varbound that led to wrong variable locks
- added a check of numerics to avoid wrong reductions in cons_linear.c:simplifyInequalities()
- fixed a bug in cons_logicor.c regarding fixed variables that were not removed
- presol_milp.c handles variable fixings, suggested by PaPILO, more carefully to cover all cases that can appear
- fixed several reproducability bugs that led to different solving paths across multiple runs with one SCIP environment
- fixed check of limits/absgap, which was incorrectly applied to the scaled objective of the transformed problem

Miscellaneous
-------------

- in LP, use absolute instead of relative tolerances to check whether solutions from LP solver are primal feasible
- when a restart occurs, SCIP now asserts (during EXITSOLVE) that all relaxation-only variables are unlocked and
  only captured by the transformed problem.
- Avoid redundant calls to LP solver when LP is already flushed and solved
- In SCIPdebugMsg(), SCIPsetDebugMsg(), SCIPstatDebugMsg() strip directory from filename.
- Recompute activity of rows when checking LP solutions instead of trusting the value given by the LP solver
- The define NPARASCIP has been replaced by SCIP_THREADSAFE
- Parameters are not reset to their default values before activating an emphasis setting; this now allows to combine
  different emphasis settings.
- If a lazy bound is set to a value that is tighter than the current global bound, then the global bound is now tightened accordingly.

Known bugs
----------

@page RN70 Release notes for SCIP 7.0

@section RN703 SCIP 7.0.3
*************************

Interface changes
-----------------

### New API functions

- added function SCIPwithDebugSol() to determine whether SCIP was compiled with WITH_DEBUG_SOLUTION

- New function SCIPcreateConsBounddisjunctionRedundant() and SCIPcreateConsBasicBounddisjunctionRedundant() that allow
  the input to contain redundant literals.

### Changed API functions

- added __attribute__((format(printf,,,))) to variadic SCIP message printing functions;
  this enables warnings about mismatches between format string and variadic function arguments if using GCC.

### Interfaces to external software

- removed MATLAB interface from interfaces/matlab

Build system
------------

- Compilation will now also work in a raw tarball of the scip git repository

### Cmake

- Make find_package more verbose and require packages to be found. Now enabled packages that are not found result in an error.

Fixed bugs
----------

- Fixed numerical bug by creating and checking the empty solution when problem vanishes in presolving.
- Fixed several bugs in reoptimization.
- Fixed bug in cons_bounddisjunction in which a constraint leads to a cutoff.
- Fixed bug in reoptimization by avoiding redundant literals for bound disjunctions.
- Replace wrong usage of CMAKE_BINARY_DIR by PROJECT_BINARY_DIR in CMake system
- Fixed lpi_glop to use absl flag instead of GFlags
- Fixed invalid initialization of limits/softtime parameter in cons_components
- Fixed MIN macro not defined in some cases.
- Safeguard some API methods for querying solving statistics against segmentation faults after SCIPpresolve()
- Fixed unfreed solution in concurrent solving
- Make sure that logicor constraints are enforced/separated if genlogicor is true in cons_indicator.
  Thus, do not change constraints/logicor/sepafreq anymore, but output warning.
- Fixed assert that assumed infeasibility cannot occur in presol_boundshift.
- Fixed sign bug during creation of conflict constraints with almost zero left-hand side.
- Disabled call of conflict handler for conflict sets that contain relaxation-only variables.
- Fixed bug in cons_symresack by initializing all constraint data in constrans
- Avoid allowing the upgrade of linear constraints corresponding to indicators in propagation of nodes.
- Fixed bug in computing lex. min/max faces in dynamic orbitope propagation.
- Limit vbounds propagator to one sweep through all bounds per call in order to avoid an infinite loop.
- Fixed mismatches between formatter strings and arguments in calls to SCIP message printing functions.

Miscellaneous
-------------

- To avoid performance variablity during reoptimization, the active constraints are now stored in the same order as in the
  original problem.
- Added workaround for bug in MSVS 2019 when compiling CppAD source.
- The original order of variables is now only restored after presolve if `randomization/permutevars` is set to FALSE.

@section RN702 SCIP 7.0.2
*************************

Features
--------

- Extended check for valid variable and constraint names in PIP writer.
- Indicator constraints now write the name of the linear constraint in CIP format. This avoids a complicated
  name matching during parsing. The old format is still supported.
- The objective scale and offset are now taken into account when reading/writing problems in lp/mps/fzn/pip format.
  This often changes the behavior when writing transformed problems.

Performance improvements
------------------------

Examples and applications
-------------------------

- Add c++ Sudoku example

Interface changes
-----------------

### New and changed callbacks

### Deleted and changed API methods

- deprecated SCIPsetParam(); use SCIPsetIntParam(), SCIPsetRealParam(), etc, instead

### New API functions

- new function SCIPcolGetVarProbindex() for accessing the probindex of a variable corresponding to a column
- added new sorting functions SCIPsortPtrRealRealBoolBool()

### Command line interface

### Interfaces to external software

### Changed parameters

### New parameters

### Data structures

Deleted files
-------------

Unit tests
----------

Testing
-------

Build system
------------

### Cmake

### Makefile

Fixed bugs
----------

- Fixed a sign bug occuring for some cases in the computation of the directed cutoff distance
- Fixed overflow in inference information of cumulative constraint handler
- Fixed problem with propfreq == 0 in cons_linear.c
- Fixed aggregation heuristic in sepa_aggregation.c to not use local rows when that is requested nor modifiable rows
- Fixed problem with incompatibility of symmetry handling in Benders decomposition
- Fixed parsing of small number in CIP format of nonlinear constraint
- Fixed problem in upgrading full orbitopes to partitioning orbitopes
- Fixed treatment of negated variables in parsing orbitope constraints
- Fixed potential indexing error in prop_vbounds.c
- Fixed bug in writing fzn format
- Revert to old parameter value when parameter change is rejected in PARAMCHGD callback
- Fixed order of linker flags when building AMPL interface with cmake system.
- Fixed bug with ofsymcomptiming == 0: now symmetry is actually computed
- Improved separation for SOC constraint with multiaggregated variable on right-hand-side.
- Fixed bug in presol_boundshift: do not shift non-active variables
- Fixed bug in domain propagation for SOC constraints with negative coefficient for variable on right-hand-side.
- Fixed bug with multi-aggregated integer variables in cons_xor.
- Fixed bug with changed number of variables in storing relaxation solution in probing/diving.
- Fixed issues with scip statistics
- Fixed issue with multi-aggregated variables
- Fixed issue in with buffer memory in cons_cumulative

Miscellaneous
-------------

Known bugs
----------

@section RN701 SCIP 7.0.1
*************************

Build system
------------

### Cmake

- Fixed cmake module for Ipopt to support Ipopt 3.13
- Added cmake variable BLISS_LIBRARY_DIR to pass a bliss library
- Added warning to require minimal GCC version 4.8
- Renamed FindCriterion cmake findmodule to FindCRITERION

### Makefile

- Updated make/make.project for macOS
- Add SANITZERFLAGS (only OPT=dbg) to LDFLAGS also if SHARED=true (and rename SANITZERFLAGS to SANITIZERFLAGS)
- Fixed GCC version check in make/make.linux.gnu.dbg

Fixed bugs
----------

- Fixed handling of constant term in quadratic objective of pip-reader
- Fixed incorrect value string for parameter estimation/completiontype
- Fixed initialization of first LP which led to wrong output about LPs not resolved correctly
- Fixed bug in SCIPcutpoolClear() function not clearing internal datastructures properly
- Fixed inability to set a value in a solution if it was within epsilon to the current value
- Fixed problems for linking optimized code with debug library of SCIP (and vice versa) by moving debug-only members
  to end of SCIP structs

Miscellaneous
-------------

- Variables that are marked as relaxation-only are no longer checked against debug solutions if
  they are captured by the transformed problem only.

@section RN700 SCIP 7.0.0
*************************

Features
--------

- Using the parameter "propagating/symmetry/recomputerestart" one can now decide to recompute symmetries after a
  restart or not. Previously one could just turn off symmetry computation after a restart. If orbital fixing
  has found a reduction before the restart occured, symmetries have to be updated to ensure correctness.
  To this end, the user can decide via "propagating/symmetry/disableofrestart" whether orbital fixing is disabled or
   whether symmetries are recomputed.

- extended relaxators statistics in solve statistics about information on number of cutoffs, improved bounds, etc.

- extends SMPS file reader for the stochastic information, the sto files, to read a lower bound for the discrete
  scenarios. The lower bound is used when creating the auxiliary variables for Benders' decomposition.

- extended Benders framework to solve NLPs and generate optimality and feasibility cuts from their solution
  when the subproblem is convex nonlinear.

- extended Benders framework to create copies of Benders decompositions that can be used in a multithreading environment

- additional functionality has been added to enable the transfer of Benders' decomposition cuts between different SCIP
  instances, e.g., when used in UG

- LP rows (SCIP_ROW) can now store pointer to a constraint from which the row originates

- Trust region, a new LNS heuristic, has been added to SCIP as both a standalone primal heuristic heur_trustregion.c
  and as a neighborhood inside of Adaptive Large Neighborhood Search (heur_alns.c). This heuristic is designed to improve the
  heuristic performance of the Benders' decomposition algorithm. It builds upon the successful trust region approaches
  applied to Benders' decomposition.

- Modularity of symmetry handling has been increased. It is now possible to use orbitopes (i.e., polyhedral symmetry
  handling techniques) and orbital fixing on the same instance.

- cut strengthening enabled within the Benders' decomposition framework. This uses a mix of the Improved Magnanti-Wong
  method and Kelly's method. The cut strengthening is enabled by setting the paramemter
  "benders/<bendersname>/cutstrengthenenabled" to TRUE. The parameters "cutstrengthenmult", "noimprovelimit" and
  "corepointperturb" control the behavior of the cut strengthening method. Additionally, the parameter
  "cutstrengthenintpoint" allows the user to specify the solution that is used to initialize the core point. The options
  are the first LP solution, the first integer feasible solution, a relative interior point, a solution vector of all
  ones and a solution vector of all zeros. Also, the core point can be reinitialized after each update to the incumbent
  solution.

- added option to adjust weights of different scores in relpscost (hybrid) branching rule based on degeneracy information
  and skip strong branching for very high degeneracy rates

- added new SCIP_DECOMP* object to store user decompositions. The user can specify one or several decompositions by assigning variable
  and/or constraint labels either through the API or by reading a file in DEC format (which is one of the formats that GCG writes).
  This format specifies constraint labels, variable labels are inferred from that. The decomposition is transformed after presolving.
- statistics regarding the number of blocks, the largest and smallest blocks, the border, and the constraint graph are printed for the original decomposition,
  and for each decomposition after presolving.
- the decomposition can be used as initial decomposition for the Benders functionality of SCIP.
- new subsection "How to provide a problem decomposition" in the SCIP documentation

- GINS heuristic can make use of a user-provided decomposition labels in two ways:
 1. by selecting a block of variables that maximizes the potential, and randomly selecting a start variable for the neighborhood and/or
 2. by selecting an interval of consecutive blocks as neighborhood, until fixing rate is reached. In this case, no variable is randomly selected.

- extend potential parameter of GINS to allow computation based on local LP solution, as well

- new primal heuristic Adaptive Diving, which registers all publicly available dive sets from other diving heuristics.
  At each call, it selects one of the available dive sets based on the user's score type choice (heuristics/adaptivediving/scoretype).
  During the solution process, the heuristics learns online which divesets reach the best score, and executes them more frequently.
  The statistic output for Diving heuristics has been extended to incorporate the statistics of each dive set within Adaptive diving.

- Added new penalty alternating direction method (PADM) primal heuristic that splits the problem into several sub-SCIPs
  according to a user-provided decomposition. The sub-SCIPs are solved on an alternating basis until a feasible solution of
  the original problem is found.

- Symmetry handling constraints (cons_orbisack, cons_orbitope, cons_symresack) now have an additional parameter to encode
  whether they are model constraints, i.e., define the problem, or whether they are only present to handle symmetries.

- The symmetry code has been completely restructured. The presolvers presol_symbreak and presol_symmetry as well as the propagator
  prop_orbitalfixing have been merged into the single propagator prop_symmetry to avoid storing the same information
  multiple times. This propagator is now responsible for adding symmetry handling constraints as well as activating orbital
  fixing. Moreover, the new file symmetry.c contains general functions for symmetry computations like orbit computations.

- Variables can now be marked as "relaxation-only". This flag should be used to introduce new variables that are required
  to define a relaxation, but that are not part of any checked constraints. Essentially, these variables should only be used
  in the current SCIP solve and disregarded after a restart or in SCIP copies. Hence, these variables are not copied by SCIPcopy and
  SCIPgetVarCopy, they are currently not used in conflict constraints, and cuts involving them are not upgraded to linear constraints.
  Relaxation-only variables cannot appear in the objective function.

- The OSiL reader now supports nonlinear expressions of type "signpower".

- Expressions of form abs(x)^p * x in a nonlinear constraint are now sometimes recognized and handled by abspower constraints.

- If polyhedral symmetry handling methods are used (cons_orbisack, cons_orbitope, cons_symresack), it is now possible to
  recompute symmetries if a restart occured.

- upgrade some more quadratic constraints to second-order cone constraints, that is,
  handle linear binary variables as if squared in simple upgrade and
  do not require bounds for variables that have a zero entry in the computed eigenvectors in the non-simple upgrade

- new variable event when changing the variable type

- It is no longer necessary to provide a SCIP pointer for the subproblem in SCIPaddBendersSubproblem if custom solving
  methods are defined. A NULL pointer can be supplied to SCIPaddBendersSubproblem. In this case, no internal Benders'
  cut generation methods can be used.

- Using the parameter "constraints/symresack/checkmonotonicity" one can now decide to upgrade to packing/partitioning
  symresacks even if the underlying permutation is not monotone.

- New branching rule `vanillafullstrong`, mostly for scientific purpose, with the following features:
  1) no cutoff or domain reduction: only branching;
  2) idempotent (optional): leave SCIP, as much as possible, in the same state before / after the strong branching calls
     - basically, do not update any statistic;
  3) donotbranch (optional): do no perform branching. So that the brancher can be called as an oracle only
     (on which variable would you branch ? But do not branch please);
  4) scoreall (optional): keep scoring variables, even if infeasibility is detected;
  5) collectscores (optional): store the candidate scores from the last call, which can then be retrieved by calling SCIPgetVanillafullstrongData();
  6) integralcands (optional): consider integral candidates for branching,
     i.e., get candidates from SCIPgetPseudoBranchCands() instead of SCIPgetLPBranchCands().

- If a reference value (misc/referencevalue) is given, the primal-reference and reference-dual integrals are calculated automatically and printed within the SCIP statistics.

- Locally valid cuts / rows are now considered for dual proof analysis when `conflict/uselocalrows` is set to TRUE.

- Linking variables in the linking constraint handler (cons_linking.{ch}) can now be integer or continuous. The coefficients of the binary variables are therefore now stored as SCIP_Real.

- To save memory, it is now possible to remove all variables from the internal symmetry data structures that are
  not affected by any symmetry.

- Allow to filter first variables from orbits and transfer pseudo cost information to variables in orbit

- Add integration of external MILP presolve library as a SCIP presolver plugin that runs on MILP problems

- Parallelisation can be used when applying Benders' decomposition. There are two different forms of parallelisation
  available. The first is applying Benders' decomposition within a parallel branch-and-bound. This is achieved through
  the integration with the UG framework. The second is the use of shared memory parallelisation for solving the Benders'
  decomposition subproblems. A priority queue has been added to help with load balancing.

- The Benders' decomposition framework can handle MINLPs. If a convex relaxation of the MINLP exists, then this is
  solved to generate optimality and feasibility cuts. The extensions to the framework are:
  - New generic solving methods to solve convex NLP subproblems.
  - Modification to benderscut_opt and benderscut_feas to enable the generation of cuts from convex NLPs.
  - Addition of benderscut_feasalt to generate feasibility cuts from an alternative subproblem that minimises the
    violation of infeasible problems.
  - Better handling of subproblem solution results

- Adds a feasibility phase to the Benders' decomposition subproblem solving methods. The feasibility phase adds slack
  variables to each of the constraints to ensure feasibility of the subproblem. A large coefficient is given to these
  slack variables in the objective function to penalise constraint violations. The coefficients are progressively
  increased until all slack variables take the value 0.0.

- Improved convexity check for Benders' decomposition subproblems. The constraints of the subproblem are now checked for
  convexity in the initialisation of the Benders' decomposition algorithm. This enables the solving of convex NLPs as
  Benders' decomposition subproblems.

- Benders' decomposition can be applied using decomposition supplied in the DEC format. To apply Benders' decomposition
  the parameters decomposition/benderslabels and decomposition/applybenders must be set to TRUE.

- new event handler event_estim.c/h that approximates search tree completion and estimates tree size
  to trigger restarts; many approximations of search tree completion and estimation, including WBE, SSG, and tree profile method
- new display column that reports approx. search tree completion during the search, and an overview in the statistics table
- added resources (script, tutorial, test data) to adapt tree size estimation to user instances.

- Orbital Fixing uses a list of variables that have been fixed globally since the computation of symmetries to filter
  symmetries. Previously, some plugins were disabled, which is not necessary anymore.

- A new presolver "dualsparsify" was added. It tries to combine columns (i.e. variables) to cancel nonzero coefficients in the constraint matrix.

- The presolver "tworowbnd" was implemented with better performance.

- To be able to calculate better bounds for the dual variables, the presolver "dualinfer" was extended by the ability to perform convex combinations of continuous columns.

- allow disabling of pricers during solving process

- added emphasis setting for numerically challenging instances

Performance improvements
------------------------

- Extended cut presolving by removing variables that been fixed at their bounds

- Improved branching point selection when branching on externals branching candidates. Instead of using exactly the
  LP solution, a point closer to the middle of the variables domain is chosen.

- Matrix presolvers that do not work on incomplete matrices now skip matrix creation if unsupported constraint types are detected.

- consLockBenders callback implemented to add down locks on the Benders' decomposition auxiliary variables and
  up and down locks per subproblem for all master problem variables. This allows the use of presolving and propagation
  with Benders' decomposition.

- improved performance of orbital fixing in several ways:
  store permutations in transposed form to improve cache efficency;
  reverse order to speed up filtering of permutations;
  handle variables globally fixed to 1 in list;
  use event handler to catch global fixings;
  speed up orbit computations;
  change handling of restarts;
  use only permutations that can contribute to a variable's orbit;

- allow rapid learning at local nodes

- allow to recompute cut without using fractional values for sepa_cgmip

- restrict the number of the clique table nonzeros relative to the number of problem nonzeros, which could be a performance bottleneck.

- variable fixings of LP face heuristic are now computed earlier; subproblem creation is skipped if not enough variables are fixed.

- Improved domcol presolver to not require a complete representation of all constraints in the matrix

- performance improvement of adaptive large neighborhood search heuristic on merely continuous problems. The heuristic
  stops if presolving in the sub-SCIP fixes less than 50 % of the current target fixing rate over all variables
  (including continuous).

- reduce memory usage in symmetry detection by a staggered allocation with decreasing overhead for larger instances

- improved full orbitope propagation using a static implementation or a dynamic reordering of orbitope rows by a global rank function

- improved detection of packing/partitioning orbitopes

- enable an in-tree restart if after a reasonable initialization, the estimated size of the remaining tree is large.


Examples and applications
-------------------------

- added methods to set and get hmin and hmax for optcumulative constraints

Interface changes
-----------------

### New and changed callbacks

- new optional callback `SCIP_DECL_DIVESETAVAILABLE` to check preconditions for this dive set, e.g., if an incumbent solution is available,
  which is passed as new argument to SCIPcreateDiveset(). SCIPcreateDiveset() has another new parameter "ispublic".

- new callback `SCIP_DECL_CONSHDLRCOPY` and `SCIP_DECL_CONSCOPY` in cons_orbisack and cons_symresack

- new `idempotent` argument to SCIPgetVarStrongbranchInt() and SCIPgetVarStrongbranchFrac(),
  so that statistics are not updated during the call. Likewise, new `updatecol` and `updatestat` arguments to SCIPcolGetStrongbranch().

- callback `SCIP_DECL_CONSHDLRENFOLP` can now also return SCIP_SOLVELP as *result, which indicates to the SCIP core that the LP relaxation
  should be solved again because the primal feasibility tolerance of the LP has been tightened (using SCIPsetLPFeastol())

- extension of SCIP_PQUEUE by a new callback SCIP_DECL_PQUEUEELEMCHGPOS to catch swaps as well as functionality to delete arbitrary elements from the priority queue.

### Deleted and changed API methods

- LPI:
  + now for all lp interfaces consistent requirements on SCIP_LPPAR:
    LPITLIM and BARRIERCONVTOL positive or zero; FEASTOL, DUALFEASTOL, LPTILIM strictly positive
  + now projecting SCIP_LPPAR values on feasible values for each lp interface
  + add interface to Glop
  + fixed mapping between scaling parameter values in Gurobi LPI lpi_grb
- Symmetry:
  + removed method SCIPseparateCoversOrbisack() in cons_orbisack.h since the orbitope constraint
    handler has its own implementation of this routine with advanced features now
  + renamed SCIPgetGeneratorsSymmetry() to SCIPgetSymmetry() and removed two arguments
  + extended method SCIPgetSymmetry(): It is possible to access both the original and
    transposed permutations matrix as well as the (independent symmetry) components of a permutation group now.
  + arguments of functions SCIPcreateConsOrbisack(), SCIPcreateConsBasicOrbisack(), SCIPcreateConsOrbitope(),
    SCIPcreateConsBasicOrbitope(), SCIPcreateConsSymresack(), SCIPcreateConsBasicSymresack(), and SCIPcreateSymbreakCons() extended
    by "ismodelcons" to encode whether the constraints are model constraints or not
  + the function SCIPgetSymmetry() no longer accepts the parameter recompute, but has parameter permvarmap as new input
  + removed SCIPgetPermvarsObjSymmetry(), SCIPsetSymmetryComponentblocked(), SCIPgetSymmetryComponentblocked(),
    SCIPgetSyminfoGloballyFixedVars(), SCIPcomputeGroupOrbitsSymbreak, SCIPincludePresolSymmetry(),SCIPincludePresolSymbreak(),
    and SCIPincludePropOrbitalfixing()
  + add function SCIPcomputeOrbitsComponentsSym() to compute orbits without filtering permutations and indices of orbits for each variable
- SCIPallowObjProp() and SCIPallowDualReds() are deprecated and replaced by SCIPallowWeakDualReds() and SCIPallowStrongDualReds(), respectively
- Benders' decomposition
  + changed SCIPstoreBenderscutCut() in scip_benders.c to SCIPstoreBendersCut(). Where this function used to take a
    SCIP_BENDERSCUT pointer, it now accepts a SCIP_BENDERS pointer.
  + the functions SCIPsolveBendersSubproblem() no longer accepts the parameter type. The type is not a necessary
    argument for the subproblem solving method.
  + arguments of functions SCIPbendersSolveSubproblemLP(), SCIPbendersSolveSubproblemCIP(), and SCIPbendersOnlyCheckConvexRelax() changed
  - removed SCIPbenderscutGetNAddedCuts() and SCIPbenderscutGetAddedCutData()


### New API functions

- new argument "onlyifcomplete" in SCIPmatrixCreate() to skip matrix creation right after detecting unsupported constraint types
  and new arguments to count statistics when doing a clean-up of inactive variables in the constraints before building the matrix

- new argument "threadsafe" in SCIPcopy(), SCIPcopyConsCompression(), SCIPcopyOrig(), SCIPcopyOrigConsCompression and
  SCIPcopyBenders(). This argument must only be set to TRUE if the source and target SCIP instances are to be solved in
  parallel. Setting this argument to TRUE has a performance cost.

- new argument "append" in SCIPsetModifiedDefaultSettingsIpopt()
- functions SCIPclearRelaxSolVals(), SCIPsetRelaxSolVal(), SCIPsetRelaxSolVals(), SCIPsetRelaxSolValsSol(), and SCIPmarkRelaxSolValid()
  receive an additional argument "relax" to store the relaxation handler as creator of the relaxation solution.

- LP:
  - SCIProwGetOriginCons() now returns a SCIP_CONS* instead of a SCIP_CONSHDLR*, use SCIProwGetOriginConshdlr() for the previous behavior
  - SCIPcreateRowCons() and SCIPcreateEmptyRowCons() now expect a SCIP_CONS* instead of a SCIP_CONSHDLR*,
    use SCIPcreateRowConshdlr() and SCIPcreateEmptyRowConshdlr(), respectively, for the previous behavior
  - deprecated SCIPlpfeastol() and SCIPchgLpfeastol(), use SCIPgetLPFeastol() and SCIPsetLPFeastol()

- new parameter "divecontext" for every method that queries statistics for a diveset. The context can be used to distinguish between the dive set
  as single (standalone) heuristic or within Adaptive Diving.
- new parameters "divecontext" and "iterlim" to SCIPperformGenericDivingAlgorithm() to control in which context (single,adaptive) statistics are updated.

- SCIPcopyVars, SCIPcopy, SCIPcopyConsCompression, and SCIPgetVarCopy do not copy variables that are marked as relaxation-only,
  thus it cannot be assumed anymore that each active variable from the master SCIP also has a counterpart in the copy.
  SCIPcopy, SCIPcopyConsCompression, and SCIPcopyConss can now return *valid=TRUE if some non-checked and non-enforced constraints were not copied, e.g.,
  because they involved relaxation-only variables. Thus, a copy is already regarded as valid if all checked or enforced constraints were copied successfully.

- linking constraint handler:
  - changed type of vals argument from int* to SCIP_Real* in SCIPcreateConsLinking() and SCIPcreateConsBasicLinking()
  - SCIPgetIntvarLinking() has been renamed to SCIPgetLinkvarLinking().
  - changed return value of SCIPgetValsLinking() from int* to SCIP_Real*.
  - new method SCIPgetBinvarsDataLinking().

- SCIPbendersCheckSubproblemOptimality() now returns a boolean indicating whether the subproblem is optimal or not.
  Previously this result was returned through a parameter. The change was required to facilitate the integration with
  the UG framework.

- deleted SCIPcombineTwoInt(), SCIPcombineThreeInt(), SCIPcombineFourInt(); use the appropriate SCIPhashTwo(), ..., SCIPhashSeven() method instead

- SCIPsetupBendersSubproblem takes a parameter of the enforcement type.

- SCIPcreateNlpiProb takes a hashmap to store the map between the nlrows and the index in the nlrow array.

### New API functions

- SCIPallowWeakDualReds() and SCIPallowStrongDualReds() replace the deprecated SCIPallowObjProp() and SCIPallowDualReds(), respectively
- methods have been added to facilitate the transfer of Benders' decomposition cuts between solvers in UG. These include
  SCIPapplyBendersStoredCuts(), SCIPbendersGetNStoredCuts(), SCIPbendersGetStoredCutData() and
  SCIPbendersGetStoredCutOrigData().
- added SCIPisConvexAbspower()
- new functions SCIPsolGetType(), SCIPsolGetRelax(), SCIPsolSetRelax(), SCIPsolSetLPRelaxation(), SCIPsolSetStrongbranch(),
  SCIPsolSetPseudo to set or query the new type attribute of a primal solution. The type attribute gives information
  about the origin of the solution, ie, whether it was created by a relaxation handler,
  by the LP relaxation, by strong branching, by the current pseudo solution, or by a primal heuristic.
  The meaning of the argument 'heur' in all creation methods for primal solutions such as SCIPcreateSol() stays unchanged.
- added SCIProwGetOriginConshdlr(), SCIPcreateRowConshdlr(), SCIPcreateEmptyRowConshdlr()
- new API functions SCIPsetCommonSubscipParams(), SCIPtranslateSubSol(), and SCIPtranslateSubSols() shared by several Large Neighborhood Search heuristics.
- new API function SCIPgetLPDualDegeneracy() to get two measures for the dual degeneracy of the current LP
- new API functions SCIPdivesetIsAvailable() to check preconditions of a dive set and SCIPdivesetIsPublic() to check if the dive set can be used
  by other primal heuristics.
- new API functions SCIPcomputeOrbitsSym(), SCIPcomputeOrbitsFilterSym(), SCIPgetPropertiesPerm(), SCIPdetermineBinvarAffectedSym(),
  SCIPdetermineNVarsAffectedSym(), SCIPcomputeComponentsSym(), and SCIPextendSubOrbitope(), SCIPgenerateOrbitopeVarsMatrix() for symmetry computations
- new API functions SCIPvarIsRelaxationOnly() and SCIPvarMarkRelaxationOnly() to query and set, resp., whether a variable is marked as relaxation-only
- new API functions SCIPconshdlrGetNUpdateConss() and SCIPconshdlrGetUpdateConss(), for expert users only
- new API function SCIPgetNConflictDualproofsApplied()
- new API functions SCIPeventGetOldtype() and SCIPeventGetNewtype() for the new event when changing the variable type
- new API function SCIPisConvexConsQuadratic() to check whether a quadratic constraint is convex when a given set of variables would be fixed
- new API functions SCIPgetLPFeastol(), SCIPsetLPFeastol(), and SCIPresetLPFeastol() to get, set, and reset (to the default), respectively, the primal
  feasibility tolerance for the LP relaxation
- new API functions SCIPcleanupConss{Linear,Varbound,Setppc,Logicor,Knapsack}() to clean up inactive variables from those types of linear constraints
- new API function SCIPsetBendersSubproblemComp() used to add a custom comparison method for ordering the Benders'
  decomposition subproblem solves. The comparison method is used to help with load balancing.
- new API function SCIPgetRowObjParallelism to get the objective parallelism of a row
- new API function SCIPcolGetAge to get the age of a column
- added SCIPhashThree(), SCIPhashFive(), SCIPhashSix(), and SCIPhashSeven() that complement SCIPhashTwo(), SCIPhashFour() to combine 32bit integers to
  a 32bit hash value
- new API function SCIPgenerateAndApplyBendersOptCut is used to generate a Benders' optimality cut using the dual
  solutions. This function can be supplied vectors for the primal and dual solution for generating an optimality cut.
  This avoids the need for a SCIP instance to solve the Benders' decomposition subproblem and generating cuts.
- new API function SCIPconsAddCoef used for adding a coefficient to a linear-type constraint.
- new API functions SCIPconsNonlinearGetRhs, SCIPconsNonlinearGetLhs and SCIPconsNonlinearAddLinearCoef for getting the
  RHS and LHS from a nonlinear-type constraint and adding a linear coefficient to the constraint.
- new API function SCIPbendersSolSlackVarsActive for checking whether any slack variables from the feasibility phase are
  active in the subproblem solution.
- new API functions SCIPbendersSetSubproblemType and SCIPbendersGetSubproblemType sets and gets the subproblem type.
  This is either:
  - Convex constraints with continuous variables
  - Convex constraints with discrete variables
  - Non-convex constraints with continuous variables
  - Non-convex constraints with discrete variables
- new API functions SCIPbendersSetSubproblemIsNonlinear() and SCIPbendersSubproblemIsNonlinear() for setting and
  identifying whether the Benders' decomposition subproblems contain nonlinear constraints. Similarly, the functions
  SCIPbendersSetMasterIsNonlinear() and SCIPbendersMasterIsNonlinear() sets and identifies whether the Benders'
  decomposition master problem contains nonlinear constraints.
- new API function SCIPapplyBendersDecomposition for applying Benders' decomposition given a decomposition in the DEC
  format
- new API function SCIPwasNodeLastBranchParent to query if a node has been the parent of the most recent branching in the tree
- new API functions SCIPtreemodelInit(), SCIPtreemodelFree(), SCIPtreemodelIsEnabled(), SCIPtreemodelSelectCandidate() related to the new
  treemodel way of comparing branching candidates. These functions are only currently used for reliability pscost branching, but they can be used
  in other parts of the code.
- New function SCIPcalcChildEstimateIncrease() to compute the increase in the child estimation
- new API functions SCIPisOrbitalfixingEnabled() and SCIPgetSymmetryNGenerators() to check whether orbital fixing is
  enabled and to get the number of generators of the current symmetry group, respectively
- new API function SCIPdelNlRow() to remove a row from the NLP

### Event system

- new event type SCIP_EVENTTYPE_NODEDELETE to react on nodes that are about to be deleted from the tree

### Changed parameters

- renamed parameter "propagating/orbitalfixing/enableafterrestart" to ".../symmetry/recomputerestart"
- Parameter "misc/allowdualreds" is now called "misc/allowstrongdualreds"
- Parameter "misc/allowobjprop" is now called "misc/allowweakdualreds"
- changed default values of propagation (new value: 1, old value: 5) and separation frequency (new value: -1, old value: 5) in cons_orbitope.c
- all primal heuristics that use sub-SCIPs are disabled within the heuristics fast emphasis setting
- deleted parameter heuristics/localbranching/useuct, use heuristics/useuctsubscip instead
- changed default value of "presolving/symbreak/detectorbitopes" (new value: TRUE, old value: FALSE)
- extended range of "misc/usesymmetry" (new range: [0,3], old range: [0,2])
- deleted parameter "constraints/orbisack/checkalwaysfeas"
- deleted parameter "constraints/orbitope/checkalwaysfeas"
- deleted parameter "constraints/symresack/checkalwaysfeas"
- deleted parameter "presolving/symmetry/maxgenerators"
- deleted parameter "presolving/symmetry/checksymmetries"
- deleted parameter "presolving/symmetry/displaynorbitvars"
- deleted parameter "presolving/symbreak/conssaddlp"
- deleted parameter "presolving/symbreak/addsymresacks"
- deleted parameter "presolving/symbreak/computeorbits"
- deleted parameter "presolving/symbreak/detectorbitopes"
- deleted parameter "presolving/symbreak/addconsstiming"
- deleted parameter "propagating/orbitalfixing/symcomptiming"
- deleted parameter "propagating/orbitalfixing/performpresolving"
- deleted parameter "propagating/orbitalfixing/recomputerestart"
- changed default value of "heuristics/coefdiving/freq" (old: 10, new: -1)
- changed default value of "heuristics/conflictdiving/freq" (old: -1, new: 10)
- changed default value of "heuristics/conflictdiving/lockweight" (old: 1.0, new: 0.75)
- replaced parameter "numerics/lpfeastol" by "numerics/lpfeastolfactor" to specify which factor should be applied to the SCIP feasibility
  tolerance to initialize the primal feasibility tolerance of the LP solver
- enabling aggressive presolving now activates all available presolving plugins,
  and decreases the presolving/restartfac parameter correctly with respect to default.
- changed default value of heuristics/rins/nodesquot to 0.3 (was 0.1), to compensate
  the removal of a hard coded factor of 3.0 in the code without affecting the default behavior
  of the RINS heuristic.
- changed default value of "constraints/quadratic/empathy4and" (old: 0, new: 2)
- changed default value of "propagating/redcost/useimplics" (old: TRUE, new: FALSE)

### New parameters

- the possibility to define the Benders' decomposition auxiliary variables as implicit integer is provided. This
  behavior is controlled with an additional parameter in the Benders' decomposition framework.
- added parameter benders/<bendersname>/cutcheck to enable the generation of Benders' decomposition cuts during solution
  checking.
- constraints/orbitope/usedynamicprop: the possibility to propagate orbitope constraints by reordering the rows based on the
  branching strategy is provided (only possible for non-model constraints)

- new parameters heuristics/shiftandpropagate/minfixingratelp and heuristics/locks/minfixingratelp to stop the
  heuristics after propagating integer fixings if no sufficient fixing of the all variables (including continuous)
  could be achieved. These parameters help to avoid solving LP's that are comparable in hardness to the main root LP.

- Added parameters branching/midpull and branching/midpullreldomtrig to control by how much to move
  the branching point for an external branching candidate closer to the middle of the candidates domain. The
  default of 0.75 and 0.5, respectively, uses a point that is 75*alpha% closer to the middle of the domain, where
  alpha is the relative width of the candidates domain (width of local domain divided by width of global domain),
  if the latter is below 0.5, and alpha=1.0 otherwise. That is, with the default settings, a branching point is
  chosen closer to the middle of the candidates domain if the variables local domain is still similar to its
  global domain, but is chosen closer to the LP solution if the local domain is much smaller than the global
  domain.

- Added parameter lp/minmarkowitz to set the Markowitz stability threshold (range 0.0001 to 0.9999).
  High values sacrifice performance for stability.

- Added parameters benders/<bendersname>/lnsmaxcalls and benders/<bendersname>/lnsmaxcallsroot to the Benders'
  decomposition core. These parameters limit the number of Benders' decomposition subproblem checks, for the full
  branch-and-bound tree and root node respective, when solving the auxiliary problem of LNS hueristics. These
  parameters only have effect if the lnscheck parameter is set to TRUE.

- Added parameter cons/linear/maxmultaggrquot to limit the maximum coefficient dynamism of an equation on which
  multiaggregation is performed. This replaces a compiler define of the same name.
  Default value is 1000, smaller values make multiaggregations numerically more stable.
- new global parameter heuristics/useuctsubscip that affects all LNS heuristics using common sub-SCIP parameters

- new parameter branching/relpscost/degeneracyaware to switch degeneracy-aware hybrid branching

- new parameter separation/rapidlearning/checkexec to check whether rapid learning is allowed to run locally
- new parameters separation/rapidlearning/check{degeneracy,dualbound,leaves,nsols,obj} to enable checking the respective feature for local rapid learning
- new parameter separation/rapidlearning/maxcalls to limit the number of rapid learning executions
- new parameter separation/rapidlearning/nwaitingnodes to set the number of waiting nodes before the dual bound is checked
- new parameter separation/rapidlearning/mindegeneracy to set the minimal threshold of degenerate basic-variables
- new parameters separation/rapidlearning/minvarconsratio to set the minimal ratio of unfixed variables in relation to basis size

- new parameters to control the Benders' decomposition two-phase method.
  - constraints/benderslp/depthfreq: after the maxdepth is reached, then the two-phase method will only be called at
    nodes at a depth divisible by depthfreq.
  - constraints/benderslp/stalllimit: after the maxdepth is reached, if there has been no improvement in the dual bound
    for stalllimit number of nodes, then the two-phase method is executed for the next fractional LP solution that is
    encountered.
  - constraints/benderslp/iterlimit: after the root node, only iterlimit fractional LP solutions are used at each node
    to generate Benders' decomposition cuts.

- new parameters for symmetry handling
  - new parameter "propagating/symmetry/maxgenerators"
  - new parameter "propagating/symmetry/checksymmetries"
  - new parameter "propagating/symmetry/displaynorbitvars"
  - new parameter "propagating/symmetry/conssaddlp"
  - new parameter "propagating/symmetry/addsymresacks"
  - new parameter "propagating/symmetry/detectorbitopes"
  - new parameter "propagating/symmetry/addconsstiming"
  - new parameter "propagating/symmetry/ofsymcomptiming"
  - new parameter "propagating/symmetry/performpresolving"
  - new parameter "propagating/symmetry/recomputerestart"
  - new parameter "constraints/symresack/checkmonotonicity"
  - new parameter "propagating/symmetry/compresssymmetries"
  - new parameter "propagating/symmetry/compressthreshold"
  - new parameter "propagating/symmetry/disableofrestart"
  - new parameter "propagating/symmetry/symfixnonbinaryvars"

- new parameter for enabling shared memory parallelisation for solving Benders' decomposition subproblems. The parameter
  benders/<bendersname>/numthreads sets the number of threads used for parallel subproblem solving.

- new parameters to control enhancements for solving MINLPs by Benders' decomposition
  - benders/<bendersname>/execfeasphase: enables the feasibility phase for solving the Benders' decomposition
    subproblems
  - benders/<bendersname>/slackvarcoef: the initial coefficient of the slack variable for the feasibility phase
  - benders/<bendersname>/checkconsconvexity: should the constraints be checked for convexity. This can be set to FALSE
    if you are certain that the NLP subproblem is convex.

- new parameter presolving/clqtablefac (default value 2.0) as limit on number of entries in clique table relative to number of problem nonzeros

- new parameter conflict/uselocalrows (default: TRUE) to incorporate locally valid cuts / rows for dual proof analysis

- new return code SCIP_NOTIMPLEMENTED for functions, e.g., in the LPI that have not been implemented (yet)

- new parameter separating/cgmip/genprimalsols that allows to generate initial primal solutions from Gomory cuts

- new parameter branching/relpscost/filtercandssym to allow filtering from orbits

- new parameter branching/relpscost/transsympscost to transfer pseudo cost information to orbit

- new parameters for tree size estimation and restarts:
    - estimation/restarts/restartpolicy (default value n)
    - estimation/method (default value c)
    - estimation/restarts/restartlimit (default value 1)
    - estimation/restarts/minnodes (default value 1000)
    - estimation/restarts/countonlyleaves (default value FALSE)
    - estimation/restarts/restartfactor (default value 2)
    - estimation/coefmonoprog (default value 0.3667)
    - estimation/coefmonossg (default value 0.6333)
    - estimation/restarts/hitcounterlim (default value 50)
    - estimation/reportfreq (default value -1)
    - estimation/regforestfilename (default value "-")
    - estimation/completiontype (default value a)
    - estimation/treeprofile/enabled (default value FALSE)
    - estimation/treeprofile/minnodesperdepth (default value 20)
    - estimation/useleafts (default value TRUE)
    - estimation/ssg/nmaxsubtrees (default value -1)
    - estimation/ssg/nminnodeslastsplit (default value 0)

- new parameter constraints/linear/extractcliques to turn clique extraction off

- new emphasis setting emphasis/numerics to increase numerical stability of (mostly) presolving operations such as (multi-)aggregations at the cost of performance.

- new parameters for treemodel:
  - new parameter branching/treemodel/enable to enable the treemodel in reliability pscost branching and possible
    future parts of the code where it could be used.
  - new parameter branching/treemodel/highrule to specify which branching rule to use when treemodel thinks the node
    is high in the tree.
  - new parameter branching/treemodel/lowrule to specify which branching rule to use when treemodel thinks the node
    is low in the tree.
  - new parameter branching/treemodel/height to specify at which (estimated) height a node is high or low in the tree.
  - new parameter branching/treemodel/filterhigh to specify whether to filter dominated candidates in nodes which are
    high in the tree.
  - new parameter branching/treemodel/filterlow to specify whether to filter dominated candidates in nodes which are
    low in the tree.
  - new parameter branching/treemodel/maxfpiter to specify the maximum number of fixed-point iterations to use when
    computing the ratio of a variable using the fixed-point method.
  - new parameter branching/treemodel/maxsvtsheight to specify the maximum height to compute the SVTS score exactly
    before approximating it using the ratio.
  - new parameter branching/treemodel/fallbackinf defines the fallback strategy to use when the tree size estimates
    obtained by SVTS are infinite.
  - new parameter branching/treemodel/fallbacknoprim defines the fallback strategy to use when no primal bound is known
    and thus SVTS would not be able to compute a tree size (it would be infinite).
  - new parameter branching/treemodel/smallpscost defines the value under which pscosts are considered too small to be
    the deciding factor for branching, in which case it may be better not to use the treemodel.

- new parameters for symmetry handling constraint handlers to enforce that also non-model constraint are copied:
  - new parameter "constraints/orbisack/forceconscopy"
  - new parameter "constraints/orbitope/forceconscopy"
  - new parameter "constraints/symresack/forceconscopy"


### Data structures

- small changes in constants of hash functions
- added fast 2-universal hash functions for two to seven 32bit elements with 32bit output
- extended SCIPpqueueCreate() by additional callback argument SCIP_DECL_PQUEUEELEMCHGPOS to catch position changes
- new methods SCIPpqueueDelPos() to delete elements at a specific position in the priority queue and SCIPpqueueFind() to
  find a specific position. It is recommended to track position changes using the new callback SCIP_DECL_PQUEUEELEMCHGPOS.
  In contrast, using SCIPpqueueFind() can be slow because it needs to compare the element it searches for
  with each slot in the queue.

### Build system

- The default value for DFLAGS in the non-cmake buildsystem has changed from -MM to -MMD. This will break the
  generation of depend.* files if that was done by a compiler call that relied on -MM. The new preferred way
  to handle compilation dependencies is to additionally use $(DFLAGS) when compiling the object files (.o) and
  to include the generated .d files in the Makefile, see also "Build system / Makefile" below.

Unit tests
----------
 - new unit test for treemodel.

Testing
-------

 - fixed an issue that may have lead to wrong status reports in the evaluation scripts

Build system
------------

### Cmake

- avoid problem with doubly defined object together with CPLEX

### Makefile

- Removed static object compilation dependency files (depend.*). If using a GCC compatible compiler, then dependency
  files are now dynamically created and updated during build. The new dependency files (*.d) reside next to each object
  file (.o) in the corresponding obj subdirectory.
- added support for building against Ipopt >= 3.13
- unify compiler switches for Intel compiler and avoid problem with doubly defined object together with CPLEX

Fixed bugs
----------

- fix and improve memory handling in symmetry computation
- fix shown number of applied conflicts in solving statistics
- fix wrongly skipping strong branching call and using old information if LP was solved with 0 iterations
- fix minor bug in cut score calculation
- fixed several bugs related to rounding locks of variables not being updated correctly
- small fix in cons_varbound.c to skip changing bounds of multi-aggregated variables in separation callback
- fixed issue in SCIPtightenVar* and SCIPinferVar* that occurs for small bound changes
- fixed rejecting minimal boundchange that changed sign of variable, even though SCIPisLb/UbBetter approved it
- fixed issue in generateCutNonConvex() which is triggered when adding quadratic constraints during the solving process
- fixed bug in freeing the reoptimization data if no problem exists
- fixed bug in SCIPreoptReleaseData() when freeing all stored constraints
- fixed bug when freeing the transformed problem via interactive shell if reoptimization is enabled
- fixed two issues related to (near-)redundant logicor constraints in presolving
- fixed counting of aggregations in XOR constraint handler
- fixed handling of unbounded solutions
- fixed update of LP size information when an LP error occured during probing
- handle special case of variable bound constraints during aggregating variables
- tighten sides of linear constraints before trying to upgrade them to more specialized constraints (knapsack, logic-or etc.) when calling SCIPupgradeConsLinear()
- fixed an issue in repair heuristic in the case of loose (noncolumn) variables
- allow user to correctly set heuristics/alns/(un)fixtol
- fixed an issue in heur_completesol which is triggered during bound widening of unbounded continuous variables
- fixed bug in cons_indicator if addopposite is true
- fixed bug in sepa_disjunctive: treat case that conflictgraph is empty
- added safety check in conversion to rational number to avoid overflow
- fixed bug in interval evaluation with power-operator in certain situations
- fixed behavior of SCIPmatrixCreate() regarding memory management and column generation
- SCIPmatrixCreate() returns complete=FALSE when locks do not add up
- fixed bug in sepa_oddcylce when variables are fixed
- fixed numerical issues related to tighter constraint sides in varbound constraint handler
- fixed update of watchedvars in logicor constraint handler in case of a restart during the tree
- fixed treatment of multi-aggregated variables in logicor constraint handler
- handle special case of redundant implications
- fixed numerical issue related to almost-0-values in pseudosolution conflict analysis
- fixed numerical issue related to very large greatest common dividers in linear constraint handler
- avoid using implications on multiaggregated variables when propagating implications
- fixed creation of (Lagrangian) variable bounds in the OBBT propagator
- fixed sorting of primal solutions
- fixed cleaning of clean buffer in conflict analysis
- avoid probing on variables with huge bounds in shift and propagate heuristic
- fix issue in printing solutions for variables that have been added by the dual sparsify presolver
- fix issue related to fixing redundant logic-or constraints after presolving
- fixed bug when parsing logic-or and and-constraints
- fixed wrong assert in updateLazyBounds()
- fixed bug in pricestore, which resulted in too many problem variables being added
- fixed bug in cons_knapsack where weight of clique was not reset after an infeasibility was detected
- fixed bug in presol_inttobinary which did not take into account that the aggregation could be rejected due to numerics
- fixed bug in debug solution mechanism in connection to variables created by presol_inttobinary
- fixed wrong indexing while undoing the implications from a redundant variable in SCIPshrinkDisjunctiveVarSet
- redundancy checks in SCIPnodeAddBoundinfer now take a possible change to an active variable into account
- fixed adding already added quadratic rows to NLP relaxation during solve
- fixed issue related to variable locks in the varbound constraint handler
- fixed bug in the quadratic constraint handler when changing infinite constraint sides
- fixed sorting of variables in linear constraint handler
- added additional checks to ensure numerical stability of dual proofs
- fixed a case when activities of a linear constraint got unreliable but where still used for reductions
- ensure that lhs <= rhs for linear constraints (without tolerances)
- make handling of read errors in SCIPfread() consistent between version with and without ZLIB
- correctly drop variable events in cons_indicator in restart
- fixed bug in cons_orbitope with upgrading of orbitope constraints
- additional checks in some presolvers for time limit being exceeded
- fixed bug in presolving of cons_varbound with multi-aggregated variables
- improve numerics in conflict analysis by using double-double arithmetic
- fixed bound acceptance condition to avoid inconsistencies
- fixed numerics in pseudoobj propagator by using double-double arithmetic

Miscellaneous
-------------

- modified display column for memory usage ("mem"), which reports the memory usage most of the time, but shows the creator name
  (heuristic, relaxation handler, LP relaxation, strong branching, pseudo solution) of every new incumbent solution. Together with this change,
  heuristic display characters have been unified to represent the type of the heuristic
  (diving, Large neighborhood search, propagation, etc.), see also type_heur.h.
- added assert that ensures that the locks of a variable have been decreased to 0 when it is freed
- added more output for completing a partial solution
- checks in debug mode that clean buffer memory is really clean when being freed are now disabled by default
- don't compute symmetries if reoptimization is enabled
- prefer integral values when fixing an almost-fixed continuous variable in the trivial presolver
- changed the name of the variable that is added by the OSiL reader to represent the quadratic or nonlinear parts of the objective function
- SCIP_EXPORT is now defined as __attribute__((__visibility__("default"))) if GCC and no SCIP config header is used

@page RN60 Release notes for SCIP 6.0

@section RN602 SCIP 6.0.2
*************************

Features
--------

- The abspower constraint handler now passes more accurate convexity
  information to the NLP relaxation.

Examples and applications
-------------------------

- added parsing functionality for optcumulative constraints in CIP format

Interface changes
-----------------

### Interfaces to external software

- Updated the Mosek LP solver interface to support Mosek 9.0.

Build system
------------

### Cmake

- new target to 'doc' to build documentation
- ctests now fail if parameter file not found
- add flag STATIC_GMP and improve GMP find module
- remove non-API methods from library (API methods use new macro SCIP_EXPORT)
- increase minimal required CMake version to 3.3
- correct paths and dependency information when installing SCIP

Fixed bugs
----------
- fixed SCIP-Jack presolving bug that could lead to wrong results for Steiner arborescence problems
- fixed wrong unboundedness result in case not all constraints were already in the LP and enforcement was
  skipped because an optimal solution was found
- fixed wrong enforcement of constraints in the disjunction constraint handler
- fixed wrong behavior of concurrent solve ignoring initial solutions
- fixed bug in concurrent solve when problem was already solved in presolving
- aggregate non-artificial integer variable for XOR constraints with two binary variables and delete constraint
- copy the objective offset when copying the original problem
- fixed bug in SCIPlpiGetBInvARow in lpi_cpx using wrong size of resulting vector
- fixed quadratic runtime behavior in sepa_aggregation
- fixed statistics of separators
- improve numerical stability in varbound constraint handler by using double-double arithmetic
- fixed bug in propagation of dual proofs
- fixed bugs that arise for multiaggregated indicator variables by disallowing multiaggregation for them
- improve numerical stability in SCIPcomputeBilinEnvelope* by using double-double arithmetic
- fixed bug related to releasing pending bound changes in tree.c
- set STD FENV_ACCESS pragma to on in code that changes floating-point rounding mode
- disable GCC optimizations in main interval arithmetic code to prevent wrong optimizations
- fixed wrong assert in cons_xor concerning the variable type
- fixed different behavior of SCIPisLbBetter and SCIPisUbBetter between having NDEBUG defined or not
- correctly handle bound disjunctions in symmetry detection
- fixed issue in reliability branching related to the LP error flag not being reset
- fixed treatment of near-infinite bounds in shiftandpropagate's problem transformation
- fixed handling of infinite values in SCIPcomputeHyperplaneThreePoints()
- fixed comparisons of infinite values in heur_intshifting.c and heur_shifting.c
- fixed bug related to updating unprocessed cuts in the cutpool
- fixed bug related to enabling quadratic constraints during `CONSINITLP`
- add missing SCIP_EXPORT for functions used by GCG
- fixed memory leak and wrong initialization for trival cases in cons_symresack.c
- fixed bug with upgrading to packing/partitioning orbitopes
- fixed bug with the status while upgrading in presol_symbreak.c
- fixed wrong stage while clearing the conflict store
- fixed behavior of SCIPfixVar() by setting infeasible pointer to TRUE if fixval lies outside variable domain
- allow tightenVar() in SCIP_STAGE_PROBLEM stage
- fixed bug in cumulative constraint handler when separating the LP solution
- fixed issues with integer overflow in cumulative constraint handler
- fixed bug where the convexity of Benders' decomposition subproblems was checked even when users defined subproblem
  solving methods. Now, as per the documentation, the user must explicitly state whether the subproblem is convex
- fixed wrong indexing in heur_dualval
- fixed issue with basis status in SoPlex LPi

Miscellaneous
-------------

- statistics now output primal/dual bounds if objective limit is reached
- memory check in debug mode is now disabled by default
- message is now provided to the user to inform that automatic Benders' auxiliary variable lower bound computations are
  not activated when user defined subproblem solving methods are present
- corrected documentation of the primalgap in SCIP; describe when it will be infinite

@section RN601 SCIP 6.0.1
*************************

Features
--------

- when using a debug solution every (multi-)aggregation will be checked w.r.t. this solution

Performance improvements
------------------------

- try greedy solution first before solving knapsack exactly using dynamic programming in SCIPsolveKnapsackExactly,
  compute greedy solution by weighted median selection.
- don't consider implied redcost by default in the reduced cost propagator

Interface changes
-----------------

### Deleted and changed API methods and macros

- The preprocessor macro NO_CONFIG_HEADER now needs to be defined when
  including SCIP header files from a SCIP build or installation that
  has been build via the Makefile-only build system.

- The following preprocessor macros have been renamed:
  WITH_ZLIB to SCIP_WITH_ZLIB, WITH_GMP to SCIP_WITH_GMP, WITH_READLINE
  to SCIP_WITH_READLINE, NO_SIGACTION to SCIP_NO_SIGACTION, NO_STRTOK_R
  to SCIP_NO_STRTOK_R, ROUNDING_FE to SCIP_ROUNDING_FE, ROUNDING_FP to
  SCIP_ROUNDING_FP, ROUNDING_MS to SCIP_ROUNDING_MS. Note, however, that
  the names of macros NO_RAND_R and NO_STRERROR_R have not been changed
  so far.

### New API functions

- SCIPhashmapInsertInt(), SCIPhashmapSetImageInt(), and SCIPhashmapGetImageInt() to use integer values as images in hashmaps

### Command line interface

- warn about coefficients in MPS files with absolute value larger than SCIP's value for infinity

### Changed parameters

- default clock type for timing is now wallclock

Unit tests
----------

- added unit tests for exact knapsack solving and (weighted) median selection algorithms

Build system
------------

### Cmake

- add missing GMP dependency when compiling with SYM=bliss
- add DL library when linking to CPLEX to avoid linker errors
- new config.h header defining the current build configuration, e.g. SCIP_WITH_GMP

Fixed bugs
----------

- fixed handling of weights in cons_sos1 and cons_sos2 (NULL pointer to weights)
- fixed handling of unbounded LPs in SCIP and in several LPIs; added heuristic method to guess solution
- the STO reader is capable of handling scenarios defined using lower case "rhs"
- fixed OPB reader for instances without explicit plus signs
- correct dual solution values for bound constraints
- fixed recognition of variable with only one lock in cons_bivariate, cons_quadratic, and cons_nonlinear
- fixed update of constraint violations in solution repair in cons_bivariate, cons_quadratic, and cons_nonlinear
- print error message and terminate if matrix entries of a column are not consecutive in mps format
- fixed incorrect handling of fixed variables when transfer of cuts from LNS heuristic for Benders' decomposition
- fix returning local infeasible status by Ipopt interface if Ipopt finds problem locally infeasible
- skip attempt to apply fixings in linear constraint handler during solving stage as LP rows cannot change anymore
- fixed bug when reading >= indicator constraints in MPS format
- fix issue with nodes without domain changes if we ran into solution limit in prop_orbitalfixing
- fixed unresolved reference to CppAD's microsoft_timer() function on builds with MS/Intel compilers on Windows
- ignore implications added through SCIPaddVarImplication() that are redundant to global bounds also in the
  special case of an implication between two binary variables; also, use implications instead of cliques in the case
  of a binary implied variable with nonbinary active representative
- fixed bug with aggregated variables that are aggregated in propagation of cons_sos1
- fixed some special cases in SCIPselect/SCIPselectWeighted methods
- relaxed too strict assertion in Zirounding heuristic
- fixed the upgrade routine to XOR constraints: aggregate integer variable if its coefficient has the wrong sign
- fixed handling of nonartificial parity variables when deleting redundant XOR constraints
- earlier deletion of trivial XOR constraints (at most 1 operator left)
- fixed wrong hashmap accesses and added sanity check for the correct hashmap type
- avoid copying of unbounded solutions from sub-SCIPs as those cannot be checked completely
- corrected the output of the first LP value in case of branch-and-price
- fixed possible integer overflow, which led to wrong conclusion of infeasibility, in energetic reasoning of cons_cumulative.c

Miscellaneous
-------------
- do not scale linear constraints to integral coefficients

@section RN600 SCIP 6.0.0
*************************

Features
--------

- new diving heuristic farkasdiving that dives into the direction of the pseudosolution and tries to construct Farkas-proofs
- new diving heuristic conflictdiving that considers locks from conflict constraints
- restructuring of timing of symmetry computation that allows to add symmetry handling components within presolving
- `lp/checkstability` is properly implemented for SoPlex LPI (spx2)
- new branching rule lookahead that evaluates potential child and grandchild nodes to determine a branching decision
- limits on the number of presolving rounds a presolver (maxrounds) or propagator/constraint handler (maxprerounds)
  participates in are now compared to the number of calls of the particular presolving method, not the number of
  presolving rounds in general, anymore
- new miscellaneous methods for constraints that have a one-row linear representation in pub_misc_linear.h
- a Benders' decomposition framework has been added. This framework provides the functionality for a user to solve a
  decomposed problem using Benders' decomposition. The framework includes classical optimality and feasibility cuts,
  integer optimality cuts and no-good cuts.
- add statistic that presents the number of resolves for instable LPs
- new readers for stochastic programming problems in SMPS format (reader_sto.h, reader_smps.h)

Performance improvements
------------------------

- cuts generated from certain quadratic constraints with convex feasible region are now global
- performance improvements for Adaptive Large Neighborhood Search heur_alns.c
  + all neighborhoods now start conservatively from maximum fixing rate
  + new default parameter settings for bandit selection parameters
  + no adjustment of minimum improvement by default
- improved bound tightening for some quadratic equations
- constraint handler checking order for original solutions has been modified to check those with negative check priority
  that don't need constraints after all other constraint handlers and constraints have been checked
- deactivate gauge cuts

Examples and applications
-------------------------

- new example `brachistochrone` in CallableLibrary examples collection; this example implements a discretized model to
  obtain the trajectory associated with the shortest time to go from point A to B for a particle under gravity only
- new example `circlepacking` in CallableLibrary examples collection; this example models two problems about packing
  circles of given radii into a rectangle
- new price-and-branch application for the ringpacking problem
- new stochastic capacitated facility location example demonstrating the use of the Benders' decomposition framework

Interface changes
-----------------

### New and changed callbacks

- added parameter locktype to `SCIP_DECL_CONSLOCK` callback to indicate the type of variable locks

### Deleted and changed API methods

- Symmetry:
  + removed function SCIPgetTimingSymmetry() in presol_symmetry.h since this presolver does not compute symmetries independent
    of other components anymore
  + additional argument `recompute` to SCIPgetGeneratorsSymmetry() to allow recomputation of symmetries

- Random generators:
  + the seed of SCIPinitializeRandomSeed() is now an unsigned int
  + the seed of SCIPsetInitializeRandomSeed() is now an unsigned int and it returns an unsigned int
  + new parameter for SCIPcreateRandom() to specify whether the global random seed shift should be used in the creation of
    the random number generator

- Miscellaneous:
  + additional arguments `preferrecent`, `decayfactor` and `avglim` to SCIPcreateBanditEpsgreedy() to choose between
    weights that are simple averages or higher weights for more recent observations (the previous default).
    The last two parameters are used for a finer control of the exponential decay.
  + functions SCIPintervalSolveUnivariateQuadExpression(), SCIPintervalSolveUnivariateQuadExpressionPositive(), and
    SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar() now take an additional argument to specify already
    existing bounds on x, providing an entire interval ([-infinity,infinity]) gives previous behavior

### New API functions

- SCIPintervalSolveUnivariateQuadExpressionNegative()
- SCIPvarGetNLocksDownType() and SCIPvarGetNLocksUpType()
- SCIPaddConsLocksType()
- SCIPconsIsLockedTypePos(), SCIPconsIsLockedTypeNeg(), SCIPconsIsLockedType(), SCIPconsGetNLocksTypePos() and SCIPconsGetNLocksTypeNeg()
- SCIPstrncpy(), a safe version of strncpy()

### Changed parameters

- Removed parameters:
  - `heuristics/alns/stallnodefactor` as the stall nodes are now controlled directly by the target node limit within the heuristic
  - `presolving/symmetry/computepresolved` since this presolver does not compute symmetries independent of other components anymore
  - `separating/maxincrounds`

### New parameters

- `lp/checkfarkas` that enables the check of infeasibility proofs from the LP
- `heuristics/alns/unfixtol` to specify tolerance to exceed the target fixing rate before unfixing variables, (default: 0.1)
- `propagating/orbitalfixing/symcomptiming` to change the timining of symmetry computation for orbital fixing
- `lp/alwaysgetduals` ensure that the dual solutions are always computed from the recent LP solve
- `display/relevantstats` indicates whether the small relevant statistics are displayed at the end of solving
- `propagating/orbitalfixing/performpresolving` that enables orbital fixing in presolving
- `presolving/symbreak/addconsstiming` to change the timining of symmetry computation for symmetry handling inequalities
- `propagating/orbitalfixing/enabledafterrestarts` to control whether orbital fixing is enabled after restarts
- `benders/*` new submenu for Benders' decomposition related settings. This includes the settings related to the
  included Benders' decompositions and the general Benders' decomposition settings.
- `benders/<decompname>/benderscuts/*` submenu within each included Benders' decomposition to control the Benders'
  decomposition cuts. The cuts are added to each decomposition separately, so the setting are unique to each
  decomposition.

### Data structures

- new enum `SCIP_LOCKTYPE` to distinguish between variable locks implied by model (check) constraints (`SCIP_LOCKYPE_MODEL`)
  and variable locks implied by conflict constraints (`SCIP_LOCKYPE_CONFLICT`)
- expression interpreter objects are now stored in the block memory

Deleted files
-------------

- removed presolving plugin presol_implfree
- separated scip.c into several smaller implementation files scip_*.c for better code overview; scip.c was removed,
  but the central user header scip.h remains, which contains includes of the separated headers

Fixed bugs
----------

- fixed bug in gcd reductions of cons_linear regarding an outdated flag for variable types
- fixed bug in heur_dualval regarding fixing routine for integer variables
- suppress debug solution warnings during problem creation stage
- fixed check for activated debugging solution in components constraint handler
- fixed potential bug concerning solution linking to LP in SCIPperformGenericDivingAlgorithm()
- fixed reward computation in ALNS on continuous, especially nonlinear, problems
- fixed bug in freeing reoptimization data if problem was solved during presolving
- fixed check of timing in heur_completesol
- fixed wrong propagation in optcumulative constraint handler
- fixed non-deterministic behavior in OBBT propagator
- don't disable LP presolving when using Xpress as LP solver
- fixed possible `NULL` pointer usage in cons_pseudoboolean
- ensured that SCIPgetDualbound() returns global dual bound instead of the dual bound of the remaining search tree
- fixed rare division-by-zero when solving bivariate quadratic interval equation
- use total memory for triggering memory saving mode
- fix parsing of version number in the CMake module for Ipopt
- fixed handling of implicit integer variables when attempting to solve sub-MIP in nlpdiving heuristic
- added workaround for bug when solving certain bivariate quadratic interval equations with unbounded second variable
- fixed bug with releasing slack variable and linear constraint in cons_indicator
- fixed problem when writing MPS file with indicator constraints with corresponding empty linear constraints
- fixed bug in heur_vbound triggered when new variables were added while constructing the LP
- fixed bug with unlinked columns in SCIProwGetLPSolCutoffDistance()

Miscellaneous
-------------

- updated CppAD to version 20180000.0
- remove LEGACY mode, compiler needs to be C++11-compliant

@page RN50 Release notes for SCIP 5.0

@section RN501 SCIP 5.0.1
*************************

Features
--------

- SCIP executable handles the `SIGTERM` signal. If the process receives a `SIGTERM`, SCIP terminates the solution process with a
  new `SCIP_STATUS` code `SCIP_STATUS_TERMINATE` and displays all relevant statistics before exiting.
- add number of conflict constraints found by diving heuristics to statistics
- allow output of lower bounds for visualization
- added symmetry detection for linking constraints

Performance improvements
------------------------

- disable disaggregation of quadratic constraints by changing the default for `constraints/quadratic/maxdisaggrsize` to 1
  (disaggregation can still be very helpful on some instances, but also seems hurtful on others)

- Cuts:
  - increased threshold when to scale up cuts that are generated by nonlinear constraint handlers
  - test additional scaling factors in CMIR cut generation heuristic
  - cleaned up implementation of the cut selection procedure and added new cut quality measure
  - use random tie-breaking in cut selection

Interface changes
-----------------

### New API functions

- new methods SCIPtryTerminate() and SCIPterminated() in scip/interrupt.h for handling of SIGTERM signals.
- new method SCIPselectCuts() to run SCIP's cut selection procedure on a given array of cuts

### Changed parameters

- rename parameter `constraints/orbisack/orbisack/coverseparation` to `constraints/orbisack/coverseparation`

### New parameters

- `visual/displb` that enables output of lower bounds for visualization
- `presolving/symmetry/displaynorbitvars` (whether we display the number of affected variables in the statistics)
- `separating/efficacyfac` to change the weight of the efficacy in cut score calculation
- `separating/dircutoffdistfac` to change the weight of the directed cutoff distance in cut score calculation

### Data structures

- new `SCIP_STATUS` code `SCIP_STATUS_TERMINATE` in scip/interrupt.h for handling of SIGTERM signals.

Unit tests
----------

- expanded unit tests of the lpis
- added check to unit tests that problem is not solved after every change

Fixed bugs
----------

- fixed LP status to unsolved when marking LP to be resolved if objective limit has changed
- copy parameter settings to sub-SCIPs in SCIPcopyLargeNeighborhoodSearch() also when copying only LP rows
- fixed a check for fixed variables in Binpacking example
- generate deprecation warnings when using SCIPaddCut
- fix bug in sepa_gomory if cut is a bound change
- fixed handling of infinite bounds in cons_sos1

- Constraints:
  - fixed bug while scaling linear constraints
  - don't delete conflict constraints that were transformed into model constraints during a restart
  - fixed treatment of variable aggregations in knapsack constraint handler that led to wrong propagations

- LP Interface:
  - fixed LPI status after changing objective in lpi_cpx, lpi_grb, lpi_xprs, lpi_msk
  - fixed and unified asserts in LPIs
  - retrieve interior solution instead of (possibly non-existing) basic solution from mosek after using barrier without crossover in lpi_msk
  - fixed bug with `NULL` pointer handling in LPIs

- Heuristics:
  - fixed wrong cast in LP iteration limit computation in proximity search heuristic
  - fixed check for time limit in heur_nlpdiving
  - improved numerics and fixed stop criterion in zirounding heuristic

@section RN500 SCIP 5.0.0
*************************

Features
--------

- new numerical solution violations get printed when checksol is called
- added analysis of the clique table which identifies possible aggregations via the search for
  strongly connected components and may detect infeasible assignments on the way
- added macros to do computations with a higher precision by using double-double arithmetic
- extended conflict analysis by analyzing dual solutions of boundexceeding LPs
- revised internal debugging mechanism to check against a user given debug solution (debug.h)

- Heuristic:
  - add new heuristic MPEC that solves a MPEC reformulation of a mixed-binary nonlinear problem by regularized NLP reformulations
  - new primal heuristic ALNS that orchestrates eight different LNS heuristics adaptively
    using algorithms for the multi-armed bandit problem
  - three bandit selection algorithms to face sequential decision problems under uncertainty

- Presolving and symmetry:
  - added presol_symmetry.c for computing and storing symmetry information of a MIP
  - added presol_symbreak.c to detect special symmetry structures and to add symmetry handling constraints
  - SCIP can now automatically detect and compute symmetries in MIPs (if a graph automorphism code is linked in)
  - added cons_symresack.c to handle permutation symmetries in a binary programs via inequalities and propagation
  - added cons_orbisack.c to handle special permutation symmetries in a binary programs via inequalities and propagation
  - cons_orbitope.c can now handle full orbitopes as well

- Propagator:
  - added new propagator orbital fixing
  - utilizing linear inequalities to compute stronger linearizations for bilinear terms; the inequalities are computed in
    the OBBT propagator

- Cuts:
  - added API for aggregating rows for generating cuts which uses double-double arithmetic internally
  - added filtering of parallel cuts in the cut pool

- Plugins:
  + added new plugin type `table` for adding user-defined statistics tables
  + new presolving plugin presol_sparsify that tries to cancel nonzero coefficients in linear constraints by adding
    multiples of linear equalities

Performance improvements
------------------------

- use disjoint set to reduce peak memory usage and time to compute of clique table connectedness information
- add and use RESTRICT macro for some pointers
- improved the implementation of SCIPvarGetActiveRepresentatives
- speed-up reverse propagation
- removed bestrelaxsol and directly access relaxation solution instead to decrease overhead when using relaxation handlers
- for fast presolving emphasis, disable use of implications in logicor presolving
- use limit on the total number of nonzeros added to the clique table during the greedyCliqueAlgorithm of cons_knapsack.c
- revised disaggregation of quadratic constraints: the number of created constraints can now be controlled and the
  disaggregated constraints are scaled in order to increase numerical accuracy
- disabled reformulation of products of a binary variable with a linear term that does not solely involve binary variables
- speed up creation of LP in the computation of relative interior points
- improved dual ray analysis
- drop events of disabled linear constraints to reduce event processing effort

- Separation:
  - new implementation of zerohalf separator
  - enabled cutting plane separation in the tree
  - improved cut selection and management
  - improved cut post-processing: apply coefficient tightening, enforce maximal dynamism

- Heuristics:
  - improved selection of rows in CMIR aggregation heuristic
  - generate lifted flowcover cuts in CMIR cut generation heuristic
  - faster implementation of CMIR cut generation heuristic
  - use LP solution polishing during probing and diving mode to activate it during many primal heuristics; remains disabled
    during strong branching and OBBT
  - improved versions of the clique and variable bound pre-root heuristics that are often able to fix many more variables

Interface changes
-----------------

### New and changed callbacks

- New types:
  - added new abstract selection algorithm `SCIP_BANDIT` together with callbacks
  - added new types for symmetry handling

- NLP interface:
  - dropped NLP termination status `SCIP_NLPTERMSTAT_UOBJLIM`

- NLP callbacks:
  - added parameter `objval` to `SCIP_DECL_NLPIGETSOLUTION` for returning the optimal objective value (can be set to `NULL`)

- Separation callbacks:
  - added parameter `allowlocal` to `SCIP_DECL_SEPAEXECLP` and `SCIP_DECL_SEPAEXECSOL` to switch generation of locally valid cuts
  - added parameter `dstatssize` to `SCIP_DECL_NLPIDELVARSET` and `SCIP_DECL_NLPIDELCONSSET`

### Deleted and changed API methods

- Branching rules:
  - removed parameter `allowaddcons` from SCIPselectVarPseudoStrongBranching(), SCIPselectVarStrongBranching(), and
    SCIPincludeBranchruleRelpscost()

- Constraint Handlers:
  - generalized SCIPcreateConsOrbitope() and SCIPcreateConsBasicOrbitope() method to three orbitope types (full, partitioning, packing)

- Cutting plane separation methods:
  - changed function signature of SCIPcalcMIR()
  - changed function signature of SCIPcalcStrongCG()
  - new method SCIPaddRow() to replace deprecated SCIPaddCut()
  - removed parameter `scaling` from SCIPgetRowprepViolation()
  - added parameter `allowlocal` to SCIPseparateSol()

- LP interface:
  - replaced LP parameters `SCIP_LPPARAM_LOBJLIM` and `SCIP_LPPARAM_UOBJLIM` by `SCIP_LPPARAM_OBJLIM`

- NLP interface:
  - SCIPnlpStatisticsCreate() and SCIPnlpStatisticsFree() now require a pointer to blockmemory as parameter
  - added parameter `objval` to SCIPnlpiGetSolution() of NLPIs for returning the optimal objective value (can be set to `NULL`)
  - added parameter `varnameslength` to SCIPexprParse()
  - added parameter `dstatssize` to SCIPnlpiDelVarSet() and SCIPnlpiDelConsSet()
  - added modifier const to `exprtree` parameter of SCIPnlpiChgExprtree()

- Primal heuristics:
  - SCIPheurPassIndicator() has a new parameter which allows to pass the objective of the solution

- Relaxator methods:
  - added parameter `includeslp` to SCIPmarkRelaxSolValid(), SCIPsetRelaxSolVals() and SCIPsetRelaxSolValsSol();
  - removed parameter `includeslp` from SCIPrelaxCreate() and SCIPincludeRelax()
  - removed functions SCIPrelaxIncludesLp() and SCIPrelaxSetIncludesLp()
  - replaced method SCIPgetRelaxFeastolFactor() by SCIPrelaxfeastol() and added SCIPchgRelaxfeastol()

- Misc:
  - changed return type of SCIPcliqueGetId() from `int` to `unsigned int`
  - SCIPsolveParallel() is deprecated; use SCIPsolveConcurrent() instead
  - removed SCIPvarGetCliqueComponentIdx(); the connectedness information of the clique table is now stored as a
    `SCIP_DISJOINTSET` member of the clique table and cannot be publicly accessed
  - added parameter `copytables` to SCIPcopyPlugins()
  - SCIPsolveParallel() has been deprecated, use the new method SCIPsolveConcurrent() instead
  - allowed SCIPgetNConss() in stage `SCIP_STAGE_INITSOLVE`

### New API functions

- SCIPaddRow() to replace deprecated SCIPaddCut()
- methods to display linear constraint classification types; use SCIPclassifyConstraintTypesLinear()
  after reading a problem to classify linear constraint types
- public methods SCIPvariableGraphBreadthFirst() and SCIPvariableGraph{Create,Free}() to
  perform breadth-first search on the variable constraint graph used by the GINS and ALNS heuristics
- SCIPsetProbingLPState() to install given LP state and/or norms at the current probing node
- SCIPbranchcandGetLPMaxPrio() and SCIPbranchcandGetExternMaxPrio() to query the maximal branching priority of given
  branching candidates; also added SCIPbranchcandGetNPrioLPCands() to access the number of LP candidates with this priority.
- SCIPupdateSolIntegralityViolation(), SCIPupdateSolBoundViolation(), SCIPupdateSolLPRowViolation(),
  SCIPupdateSolConsViolation() and SCIPupdateSolLPConsViolation() for updating numerical solution violations, as well as
  SCIPactivateSolViolationUpdates() and SCIPdeactivateSolViolationUpdates() for activating/deactivating violation updates globally
- SCIPsetSubscipDepth() to set the depth of SCIP as a copied subproblem during problem stage
- SCIPdivesetGetNSols() to query the number of found solutions from a diveset.
- SCIPnextafter() that wraps different nextafter methods to return the next representable value after a given value
- SCIPlinConsStats{Create,Free,GetTypeCount,GetSum}() and SCIPprintLinConsStats() to work with linear constraint classification through the C API
- SCIPgetRowNumIntCols() that returns the number of integer columns in a row
- SCIPsetSlackVarUb() to control upper bound of slack variable in cons_indicator

- Data structures:
  - methods SCIPrandomCreate() and SCIPrandomFree() are no longer public and should be replaced by SCIPcreateRandom() and
    SCIPfreeRandom(), respectively (the new methods respect the global parameter `randomization/randomseedshift` automatically)
  - methods SCIPdigraphCreate() and SCIPdigraphCopy() are no longer public and should be replaced by SCIPcreateDigraph() and
    SCIPcopyDigraph(), respectively, which receive a SCIP argument and are more robust towards future interface changes

- Bilinear:
  - SCIPgetAllBilinearTermsQuadratic() to access data of all existing bilinear terms in quadratic constraints
  - SCIPaddBilinearIneqQuadratic() to propose an inequality with two variables that appear in a bilinear term
  - SCIPcomputeBilinEnvelope{1,2}() to compute a linearization of a bilinear term when considering at most two linear inequalities

- Clique:
  - SCIPcliqueGetIndex() which returns the unique identifier for the given clique
  - SCIPgetNCliquesCreated() which returns the number of cliques created so far

- Cutting plane separation methods:
  - SCIPisCutNew() that returns whether a cut is already present in the global cut pool
  - SCIPgetSepaMinEfficacy() to access separating/minefficacy(root)

- Interfaces:
  - interface methods to create and use bandit algorithms implemented as SCIP core plugins
  - interface methods for aggregating rows and computating MIP cuts, see cuts.h
  - interface method SCIPsetRandomSeed() to (re)set a random number generator seed

### Command line interface

- new interactive shell functionality to display linear constraint classification types;
  use `display linclass` after reading a problem to classify linear constraint types
- new command line parameter `-r` to pass a nonnegative integer as random seed.

### Interfaces to external software

- added interface to the NLP solver WORHP
- added interface to the NLP solver FilterSQP
- added interface to graph automorphism algorithms in `src/symmetry/` (initially only to BLISS)
- unify handling of objective limit in LPIs by replacing LPI parameters `SCIP_LPPAR_LOBJLIM` and `SCIP_LPPAR_UOBJLIM` by
  `SCIP_LPPAR_OBJLIM`
- dropped support for MOSEK < 7.0.0.0

### Changed parameters

- changed and removed several parameters for zerohalf separator
- replaced `constraints/quadratic/disaggregate` by `constraints/quadratic/maxdisaggrsize` to bound
  the total number of created constraints when disaggregating a quadratic constraint
- new value 3 for parameter `lp/solutionpolishing` to enable LP polishing only during probing and diving mode
- parameter `conflict/useboundlp` has new values `d` (only dual solution analysis) and `b` (both, conflict and dual solution analysis)

- Heuristics:
  - fixed typo `heuristics/completesol/maxunkownrate` has changed to `heuristics/completesol/maxunknownrate`
  - replaced parameter `heuristics/{clique,vbounds}/minfixingrate` by `heuristics/{clique,vbounds}/minintfixingrate` and
    `heuristics/{clique,vbounds}/minmipfixingrate`, which check the fixing rate before LP solving and after sub-MIP presolve

- Separating:
  - parameter `separating/maxstallrounds` only applies to nodes in the tree (not the root node, anymore); use the new
    parameter `separating/maxstallroundsroot` for the root node
  - moved parameters for flowcover and cmir separators to `separating/aggregation`

- Removed parameters:
  - `constraints/{abspower,bivariate,nonlinear,quadratic,soc}/scaling`
  - `constraints/{abspower,bivariate,quadratic,nonlinear}/mincutefficacysepa`
  - `constraints/{abspower,bivariate,quadratic,nonlinear}/mincutefficacyenfofac`
  - `constraints/soc/minefficacy`
  - `conflict/usemir`
  - `conflict/prefermir`
  - `heuristics/clique/{multiplier,initseed}`
  - `separating/feastolfac`
  - `separating/orthofac`
  - `separating/cgmip/allowlocal` (use parameter passed to separation callback instead)
  - `separating/{gomory,strongcg}/maxweightrange`

### New parameters

- `conflict/prefinfproof` (prefer infeasibility proof to boundexceeding proof)
- `conflict/sepaaltproofs`
- `constraints/indicator/maxsepanonviolated` to stop separation after separation of non violated cuts
- `constraints/orbisack/coverseparation` (whether orbisack cover inequalities should be separated)
- `constraints/orbisack/orbiSeparation` (whether facet defining inequalities for orbisack should be separated)
- `constraints/orbisack/coeffbound` (maximal value of coefficients in orbisack facet inequalities)
- `constraints/orbisack/checkpporbisack` (check whether orbisacks can be strengthened by packing/partitioning constraints)
- `constraints/orbisack/checkalwaysfeas` (whether conscheck returns always `SCIP_FEASIBLE`)
- `constraints/orbitope/checkpporbitope` (check packing/partitioning orbitopes)
- `constraints/orbitope/sepafullorbitope` (separate full orbitopes)
- `constraints/orbitope/checkalwaysfeas` (whether conscheck returns always `SCIP_FEASIBLE`)
- `constraints/quadratic/{usebilinineqbranch,minscorebilinterms,bilinineqmaxseparounds}`
- `constraints/quadratic/disaggrmergemethod` to change the strategy of how to merge independent blocks of quadratic constraints
- `constraints/quadratic/mincurvcollectbilinterms` to change the minimal curvature of constraints
  to be considered when returning bilinear terms to other plugins
- `constraints/quadratic/binreformbinaryonly` to disable reformulation of products of binary and non-binary variables
- `constraints/symresack/ppsymresack` (check whether symresacks can be strengthend by packing/partitining constraints)
- `constraints/symresack/checkalwaysfeas` (whether conscheck returns always `SCIP_FEASIBLE`)
- `expbackoff` to all separators which increases the frequency exponentially over the depth in the tree
- `heuristics/completesol/{beforepresol,maxlpiter,maxcontvars}`
- `heuristics/{clique,vbounds}/maxbacktracks` to limit the number of backtracks in the fix-and-propagate phase
- `heuristics/{clique,vbounds}/uselockfixings` to enable fixing of additional variables based on variable locks
- `heuristics/vbounds/{feasvariant,tightenvariant}` to specify the fixing variants used by the vbounds heuristic
- `lp/refactorinterval` to change the refactorization interval of the LP solver
- `misc/debugsol` to specify a debug solution that should be checked during the solve
- `misc/usesymmetry` to determine whether symmetry handling should be used
- `presolving/symbreak/conssaddlp` (whether symmetry handling inequalities should be added to the LP)
- `presolving/symbreak/addsymresacks` (whether symresacks should be used to handle symmetries)
- `presolving/symbreak/computeorbits` (whether symmetry orbits should be computed)
- `presolving/symbreak/detectorbitopes` (whether it should be checked if some symmetries can be handled by orbitopes)
- `presolving/symmetry/computepresolved` (Whether symmetries are computed after presolving)
- `presolving/symmetry/maxgenerators` (maximal number of generators generated by symmetry detection)
- `presolving/symmetry/checksymmetries` (whether validity of computed symmetries should be verified)
- `propagating/obbt/{itlimitfactorbilin,minnonconvexity,createbilinineqs}`
- `propagating/vbounds/minnewcliques` to specify the minimum number of new cliques to trigger another clique table analysis
- `propagating/vbounds/{maxcliquesmedium,maxcliquesexhaustive}` to limit the number of cliques relative to the
  number of binary variable for performing clique table analysis
- `separating/maxincrounds`
- `separating/maxlocalbounddist`, `separating/maxcoefratio` and `separating/intsupportfac`
- if PaPILO >= 2.1: `presolving/milp/maxbadgesizepar` to limit the maximal badge size if PaPILO is called in parallel mode
- if PaPILO >= 2.1: `presolving/milp/maxbadgesizeseq` to limit the maximal badge size if PaPILO is called in sequential mode

### Data structures

- new type `SCIP_Shortbool` (equal to uint8_t) for storing Boolean values in a more compact manner
- new disjoint set data structure `SCIP_DISJOINTSET` to incrementally update connectedness information for a graph on nodes {0,...,n-1}
- new red black tree data structure defined in `src/scip/rbtree.{c,h}`
- new object `SCIP_LINCONSSTATS`, see type_cons.h, to work with linear constraint classification through the C API
- added new type `SCIP_TABLE` together with callbacks to output SCIP statistics

Unit tests
----------

- added several tests for the LP interface
- added tests that cover nonempty linear constraint classification types
- added tests for the double double arithmetic, the new red black tree data structure, the nlpi, obbt, interval arithmetics,
  symmetry computation, objective function changes in probing, computing envelopes of bilinear function, relaxation enforcement

Build system
------------

- added interface to the NLP solver WORHP; set `WORHP=true` in order to link to WORHP
- added interface to the NLP solver FilterSQP; set `FILTERSQP=true` in order to link to FilterSQP

### Cmake

- added support for sanitizers in debug mode and options SANITIZE_ADDRESS, SANITIZE_MEMORY, SANITIZE_UNDEFINED, SANITIZE_THREAD
- added option SYM to specify which graph automorphism package (bliss, none) should be used, if available
- disable non-standard compliant floating point optimizations in combination with intel compilers
- improve Visual Studio compilation
- only accept IPOPT version 3.12.0 or higher
- preserve correct rpath in library (e.g. path to libipopt) when installing

### Makefile

- new flag `DEBUGSOL={true,false}` to enable checks against a user given debug solution
- added flag SYM to specify which graph automorphism package (bliss, none) should be used
- default value for ZIMPL in the Makefile is now `false`

Fixed bugs
----------

- fix wrong statistic display of diving leaf solutions
- fixed order of SCIPcalcCliquePartition() in corner case where no cliques are available
- fix treatment of infinite lower bound in proximity objective cutoff
- fixed minor issue in expression graph simplification

- Separator:
  - fix linear knapsack relaxation during separation if a binary variable does not have a solution value in [0,1].
  - fixed potential ressource leaks in SCIPsolveLinearProb(), expr.c, sepa_eccuts, cons_cumulative.c, cons_nonlinear.c
  - fixed bug in cons_orbitope.c, where wrong terminating index in separation of SCIs was used
  - fixed wrong mapping of permuted basis indices in gomory separator
  - fixed integer objective separator for objective scales < 1

- Presolver:
  - fixed numerical issues in boundshift presolver when aggregating integer variables
  - fixed aggregation of variables in boundshift presolver that contain large variable bounds

- Heuristic:
  - fixed bug in feasibility pump heuristic when switching on the `usefp20` parameter
  - fixed handling of LOOSE variables in locks heuristic
  - fixed creation of conflicts in clique heuristic for incomplete LPs

- Constraints:
  - fixed bug in mps reader. Reader now prints `OBJSENSE` section and tries to generate unique names of constraints
  - fixed upgrade to a varbound constraint if abspower constraint contains a multi-aggregated variable
  - fixed several bugs related to hashing of constraints/rows in cutpool.c and cons_linear.c
  - fixed registration of almost fixed nonlinear variables in abspower constraints

- Propagator:
  - fixed releasing of variables in the genvbounds propagator in case the problem could be solved during presolving of a restart
  - fixed numerical issues in bound widening of variable bound constraint handler and vbound propagator during conflict analysis

@page RN40 Release notes for SCIP 4.0

@section RN401 SCIP 4.0.1
*************************

Features
--------

- added parsing functionality to cardinality constraint handler for CIP format
- allow to relax objective limit in reoptimization in presolved stage
- suppress excessive printing about numerical troubles in LP on default verblevel (high)

Performance improvements
------------------------

- only accept passed improving solutions in heur_indicator
- add and use RESTRICT macro for some pointers
- sorting of parents and children for some expression types is now independent of memory layout

- Constraints:
  - widened a bottleneck in simplifying long signomial sums in a nonlinear constraint
  - unified and extended code that improves numerics of cuts generated by nonlinear constraint handlers

- Separation:
  - stop separation in cons_indicator after maxsepanonviolated many non violated separated cuts
  - improve choice of variable to enter support in separation of cons_indicator

Interface changes
-----------------

### New API functions

- SCIPvalidateSolve() to compare solving result with an external primal and dual reference value
- SCIPisObjChangedProbing() to check whether the objective function has changed during probing mode
- SCIPgetDualSolVal() to get the dual solution value of a constraint
- SCIPisLPPrimalReliable() and SCIPisLPDualReliable() to check whether the current primal / dual LP solution
  were successfully checked for feasibility

### Command line interface

- New option in the interactive shell to validate the solution against an external primal and dual reference value
- added command line option `-o` and command `validatesolve` in interactive shell
  to validate the solution against an external primal and dual reference value.

### Interfaces to external software

- Updated and new interfaces to Mosek 8.1, GAMS and Gurobi
- new LP interface to Glop (Google OR tools); CMake only

### Changed parameters

- renamed parameter `heuristics/completesol/maxunkownrate` to `heuristics/completesol/maxunknownrate`

Testing
-------

- add options to make test target (see Makefile section)

Build system
------------

### Cmake

- New CMake build system alongside the usual Makefile setup

### Makefile

- added make options for specifying EXECUTABLE and OUTPUTDIR variables for the make test target

Fixed bugs
----------

- fixed unintended behavior of interrupt signal handler inside SCIP copies
- fixed uninitialized values in SCIP's digraph data structure after calling SCIPdigraphResize()
- fixed issue related to SCIPcreateFiniteSolCopy() not being able to remove all infinite fixings
- fixed issue in SCIPcopyLimits() w.r.t. soft time limit
- fixed bug in dynamic resizing of hashtables and hashmaps
- added workaround for bug in primal simplex of cplex 12.7.1.0 occuring when attempting to solve LPs without rows without presolving
- fixed bug in binpacking example that might have led to doing the same branching several times
- fixed memory issue in binpacking example
- in GAMS writer, forbid also various parenthesis characters in gams symbol names
- added missing definition of `SCIP_UNUSED` in memory.h if def.h is not included
- treat reopt bugs: Avoid numerical problems with changing objective; fix check for changed objective
- fixed reading issue in mps reader: integer variables fixed to 0 or 1 are treated as binaries now,
  allowing to use them as indicator variables
- afternode heuristics are now called even if the node limit was reached and the solving process will be stopped
  after the current node
- fixed bug when activating probing mode with a non-empty separation storage

- LP interfaces:
  - fixed guard against using old Gurobi versions in lpi_grb.c: Gurobi 7.5 was not permitted
  - fixed wrong handling of unboundedness status in lpi_grb.c
  - fixed wrong handling of row basis status in lpi_grb.c

- Propagator:
  - fixed bug in shift and propagate--variable information with a negation transformation is correctly reset after backtracking
  - fixed bug in genvbounds propagator when applying a restart after the root node

- Constraints:
  - fixed bug in varbound coefficient tightening: if a varbound constraint only contained one variable afterwards,
    it may have been deleted without applying the induced bound, if the change was too small, this is now forced
  - fixed potential wrong locks update after a varbound constraint became redundant in coefficient tightening
  - fixed potentially wrong cleanup of fixed variables in nonlinear constraint handler
  - fixed memory leak in OSiL reader when using SOS constraints

- Solution:
  - improved handling of infinite values in a primal solution in quadratic and nonlinear constraints
  - fixed bug in computing violation and cut for certain nonlinear constraints when LP solution is slightly out of bounds
  - fixed debug solution check that appeared in probing mode when the objective function has changed
  - relaxed a too strong assert concerning solutions close to the objective limit

@section RN400 SCIP 4.0.0
*************************

Features
--------

- Introduced support for partial or infeasible user solutions, which SCIP tries to complete/repair heuristically
- implemented linear time methods for (weighted) median selection for joint arrays of various types
- added adaptive solving behavior of SCIP based on solving phases and heuristic transitions, if enabled via `solvingphases/enabled`
- can now solve relaxations within probing
- in case of multiple relaxators the best solution is saved instead of the last one
- added write callback for reader_bnd
- added possibility to use a reference value for advanced analysis of the tree search. If a finite reference value
  (an objective value in original objective space) is passed via misc/referencevalue, SCIP keeps track of the
  number of nodes exceeding the reference value and the number of early backtracks -- path switches in the tree when
  a child node with lower bound smaller than the reference value was available.
- added reading capabilities for partial solutions with extension *.mst
- new global shift off all random seeds (randomization/randomseedshift) and unification of all existing random seeds
- use new macros SCIPdebugMsg(), SCIPsetDebugMsg(), SCIPstatDebugMsg() at all places where it makes sense
- new random number generator in pub_misc.h
- add check whether variables have been released when freeing SCIP
- a print callback can now be specified for user expressions

- LP Solutions:
  - will now enforce relaxation solution instead of lp or pseudosolution if lowerbound is better and the whole lp is included in the relaxation
  - new feature solution polishing to improve integrality of LP solutions

- Constraints:
  - new constraint handler for cardinality constraints
  - added interval-evaluation of sine and cosine
  - allow to create constraints of constraint handlers that don't need constraints
  - New constraint handlers cardinality and components

- Conflicts:
  - implement a storage for conflicts to have more control over active conflicts
  - Improved conflict analysis through central conflict pool and dual ray analysis for primal infeasible LPs; can now analyze dual
    unbounded rays of primal infeasible LPs

- Presolving:
  - New presolvers that disaggregate SOC constraints and reformulate QP's by adding KKT conditions
  - new presolving step for variables contained in a single quadratic constraint with proper square coefficients
  - add new presolving step to disaggregate second order cone constraints
  - new presolving method presol_qpkktref to add the KKT conditions of a QP
  - implemented and extended stuffing presolving in linear constraint handler
  - new components constraint handler which replaces the components presolver; it searches for independent subproblems
    and solves small ones as sub-SCIPs during presolve, larger ones are solved alternatingly during the main solving process
  - new presolving timing FINAL: presolving methods with this timing are only called once after all other presolvers with timings
    FAST, MEDIUM and EXHAUSTIVE are finished; during this timing only reductions are allowed that are self-contained, e.g.,
    fixing all variables and deleting all constraints of an independent component; note that reductions found in this timing
    do not trigger a new presolving round

- Separation and Cuts:
  - can now separate perspective cuts for indicator constraints
  - add sepa_convexproj, a separator which projects onto convex relaxation and build gradient cuts at the projection
  - add sepa_gauge, a separator which computes an interior point of a convex relaxation and performs a binary search in the segment joining
    the interior point and the point to separate until it finds a point in the boundary of the feasible region where to build a gradient cut
  - changed handling of coupling constraints in cons_indicator; the cuts will not be added to the pool, but are separated by default
  - concurrent solving mode that allows to run multiple SCIP instances, that share solutions and global variable bounds, in parallel
  - Revised pseudo random number generation and introduced central random seed for all plugins

- Heuristics:
  - new Graph induced neighborhood search (GINS) primal heuristic that uses neighborhoods
    based on distances in the variable constraint connectivity graph.
    In addition, the heuristic supports a rolling horizon-like procedure to solve auxiliary problems
    for neighborhoods with increasing distance from the starting neighborhood.
  - new primal heuristic LP face that tries to find an integer solution inside the optimal LP face.
  - new heuristic that tries to complete partial solutions
  - the subnlp heuristic now gives ownership of a found solution to the heuristic that constructed the starting point, if any;
    as a consequence, MIP heuristics may now be shown more frequently for having found a solution when solving MINLPs, even
    though the solutions required an additional NLP solve
  - new multistart heuristic for NLPs

- Propagator:
  - add prop_nlobbt, a nonlinear optimization-based bound propagator solving two convex NLP relaxations for each variable
  - nodes can now be postponed; currently, this can only be triggered by BEFORELP propagation callbacks

- Statistic:
  + Extended statistic output displayable via the interactive shell
  + new statistic computed: `Root LP Estimate` that shows the root LP best-estimate with every pseudo-cost update
  + added leaf statistics about LP objective limit|feasible|infeasible leaves to the statistics output and
    to the callable library: SCIPgetNObjlimLeaves(), SCIPgetNFeasibleLeaves(), SCIPgetNInfeasibleLeaves()
  + next to the number of found solution, also the number of new best solutions is now printed for each heuristic
    (and relaxation solutions) in the statistics in the `Primal Heuristic` section.

Performance improvements
------------------------

- Extended the presolving timings by an additional timing FINAL for self-contained reductions
- Randomized tie-breaking in different parts of the code to reduce performance variability
- use connectedness information of the clique table to speed up the clique partitioning algorithm
- knapsack approximation algorithms use linear-time weighted median selection instead of sorting
- improved greedy solution in SCIPsolveKnapsackApproximatelyLT() for the flow cover separation
- reduce performance variability by using random numbers as tie-breaker for external branching candidates

- Heuristics:
  - adjusted most Large Neighborhood Search heuristics such that they collect their variable fixings first in an array,
    and only create and populate a sub-SCIP if enough variables will be fixed.
  - reduce performance variability by using a small perturbation in the undercover heuristic
  - 1-opt heuristic can now be repeatedly executed as long as new incumbents are found

- Constraints:
  - Improved and extended stuffing inside of linear constraint handler
  - Changed handling of coupling constraints in cons_indicator
  - SCIP supports constraint compression for problem copies; constraint compression denotes the immediate
    removal of fixed variables from constraint data at creation time to reduce memory requirements.

- Propagation:
  - rewrote the propagate-and-cut-and-price loop so that successful propagations with DURINGLPLOOP timing, bound changes found by separation,
    and new primal solutions now trigger a new round of node solving, starting with propagation; improved tuning of propagation and heuristic timings
  - tuned propagation methods of several constraint handlers
  - make more use of SCIPmarkConsPropagate() to mark constraints for propagation and improved the internal handling of marked constraints
  - improve propagation of absolute-value expression in the case that the sign of the argument is fixed

Interface changes
-----------------

### New and changed callbacks

- Concurrent SCIP:
  - extended interface to support concurrent solving mode

- Constraint Handlers:
  - new optional callback `CONSENFORELAX` to enforce a relaxation solution, see \ref CONS
  - `CONSINITLP` callback now has a new parameter `infeasible`, which is a pointer to store whether infeasibility
    was detected while building the initial LP relaxation

### Deleted and changed API methods

- setting a parameter to a non-valid value now produces an error message instead of a warning
- bound reader uses angle bracket around variable names
- the parameters of SCIPlpiChgObj(), SCIPlpiSetBase(), SCIPlpiSetState(), SCIPlpiSetNorms() have been declared as const
- SCIPapplyHeurSubNlp() can now return the solution found by the sub-NLP heuristic

- Random:
  - methods SCIPrandomGetInt() substitutes SCIPgetRandomInt() (marked to be deprecated)
  - methods SCIPrandomGetReal() substitutes SCIPgetRandomReal() (marked to be deprecated)
  - methods SCIPrandomPermuteArray() substitutes SCIPpermuteRandomArray() (marked to be deprecated)
  - methods SCIPrandomPermuteIntArray() substitutes SCIPpermuteRandomIntArray() (marked to be deprecated)
  - method SCIPrandomGetSubset() substitutes SCIPgetRandomSubset() (marked to be deprecated)

- Conflict Analysis:
  - added parameters `conftype` and `iscutoffinvolved` to SCIPinitConflictAnalysis()
    that indicate the type of the conflict and whether the current cutoff bound is used or not

- Constraint Handlers:
  - added parameter `infeasible` to SCIPinitlpCons()

- Copying:
  - added parameters `fixedvars`, `fixedvals`, `nfixedvars` to SCIPcopyVars()
  - added parameters `fixedvars`, `fixedvals`, `nfixedvars` to SCIPcopyOrigVars()
  - renamed parameter `success` to `valid` in SCIPgetConsCopy()

- Hashmap and Hashtable:
  - removed function SCIPcalcHashtableSize() since not required anymore for `SCIP_HASHTABLE` and `SCIP_HASHMAP`
  - based on the initial size `SCIP_HASHTABLE` and `SCIP_HASHMAP` choose an appropriate size internally to allow insertion of that
    many elements without resizing
  - `SCIP_MULTIHASH` behaves like the old `SCIP_HASHTABLE` and SCIPcalcMultihashSize() should be used as replacement for
    SCIPcalcHashtableSize()

- Nonlinear Relaxation:
  - added parameter `curvature` to SCIPcreateNlRow()

- Parameters:
  - the following new methods return a bool indicating whether the given value is valid for the parameter instead of printing a warning
    message and returning an error code if the value is invalid
    - renamed method SCIPcheckBoolParam() to SCIPisBoolParamValid()
    - renamed method SCIPcheckLongintParam() to SCIPisLongintParamValid()
    - renamed method SCIPcheckCharParam() to SCIPisCharParamValid()
    - renamed method SCIPcheckStringParam() to SCIPisStringParamValid()
    - renamed method SCIPcheckRealParam() to SCIPisRealParamValid()
  - in param.c/h: the new methods return a bool whether the given value is valid for the parameter instead of printing a warning message
    and returning an error code if the value is invalid
    - rename SCIPparamCheckBool() to SCIPparamIsValidBool()
    - rename SCIPparamCheckString() to SCIPparamIsValidString()
    - rename SCIPparamCheckChar() to SCIPparamIsValidChar()
    - rename SCIPparamCheckLongint() to SCIPparamIsValidLongint()

- Primal Heuristics:
  - added parameter `initialseed` to SCIPcreateDiveset()
  - introduced new type `SCIP_HEURTIMING` for primal heuristic timing masks
  - changed type of parameter `timingmask` from unsigned int to `SCIP_HEURTIMING` in SCIPincludeHeur(), SCIPincludeHeurBasic()

- Relaxators:
  - new parameter `includeslp` for SCIPincludeRelax() and SCIPincludeRelaxBasic()
    to indicate whether relaxation includes all linear rows and can be enforced

- Reoptimization:
  - rename method SCIPgetReopSolsRun() to SCIPgetReoptSolsRun()

- Solutions:
  - added parameter `completely` to SCIPtrySol(), SCIPtrySolFree(), SCIPcheckSol() to check all constraints when
    printing violations

- Variables:
  - removed SCIPvarGetLbAtIndex() and added SCIPgetVarLbAtIndex()
  - removed SCIPvarGetUbAtIndex() and added SCIPgetVarUbAtIndex()
  - removed SCIPVarGetBdAtIndex() and added SCIPgetVarBdAtIndex()
  - removed SCIPvarWasFixedAtIndex() and added SCIPgetVarWasFixedAtIndex()
  - Removed method SCIPvarGetNBinImpls()

### New API functions

- added functions for concurrent solving mode (see concurrent.h, concsolver.h)
- SCIPcreateNlpiProb(), SCIPupdateNlpiProb() and SCIPaddNlpiProbRows() to create and update a nonlinear relaxation
- SCIPgetNObjlimLeaves(), SCIPgetNFeasibleLeaves(), SCIPgetNInfeasibleLeaves() for statistics output
  about LP objective leaves
- SCIPcheckCopyLimits() which can be used to check that enough time and memory is left to run a sub-SCIP after
  subtracting time and memory used by the main-SCIP and SCIPcopyLimits() which copies these limits accordingly and disables
  all other limits (need to be set by the plugin, if needed)
- SCIPcopyLargeNeighborhoodSearch() in heuristics.h that supports compressed copying and two kinds of problem copy: the MIP-relaxation or
  a 1-1 problem copy (by copying the constraints and not the LP relaxation)
- SCIPsolveProbingRelax() to solve a relaxation within probing
- SCIPgetLastStrongbranchingLPSolstat() to query the LP statuses after strong branching on a variable
- SCIPinitializeRandomSeed()
- SCIPswapReals() to swap two real values
- SCIPgetNNZs() to get the number of active non-zeros in the transformed/presolved problem

- Debug Messages:
  - SCIPprintDebugMessage(), SCIPsetPrintDebugMessage(), SCIPstatPrintDebugMessage() that output debug messages and also print the
    subscip depth; the first two output via the message handler; also added macros SCIPdebugMsg(), SCIPsetDebugMsg(), SCIPstatDebugMsg()
  - SCIPdebugMsgPrint()/SCIPsetDebugMsgPrint() that output a message without `[debug]` prefix via the message handler (compare SCIPdebugPrintf())

- Solution:
  - SCIPisDualSolAvailable() to query the dual solution availability
  - SCIPlpiSetIntegralityInformation() to improve SoPlex' solution polishing

- Constraints:
  - library methods SCIPcopyConsCompression(), SCIPcopyOrigConsCompression() that accept an array of variables that are immediately
    fixed in the copy. Alternatively, local instead of global bounds can be used for compression.
  - library methods SCIPenableConsCompression(), SCIPisConsCompressionEnabled(), SCIPcopyConsCompression(), SCIPcopyOrigConsCompression()
  - SCIPgetIntVarXor() to access integer variable of XOR constraints
  - SCIPcreateConsCardinality() to create a cardinality constraint
  - SCIPcreateConsBasicCardinality() to create a basic cardinality constraint
  - SCIPchgCardvalCardinality() to changes cardinality value of cardinality constraint (i.e., right hand side of cardinality constraint)
  - SCIPaddVarCardinality() to add a variable to a cardinality constraint
  - SCIPappendVarCardinality() to append a variable to a cardinality constraint
  - SCIPgetNVarsCardinality() to get the number of variables in a cardinality constraint
  - SCIPgetVarsCardinality() to get the array of variables in a cardinality constraint
  - SCIPgetCardvalCardinality() to get the cardinality value of a cardinality constraint (i.e., right hand side of cardinality constraint)
  - SCIPgetWeightsCardinality() to get the array of weights of a cardinality constraint
  - SCIPgetLinvarMay{Decrease,Increase}Quadratic() to get index of a variable in linear term of quadratic constraint that may be decreased
    without making any other constraint infeasible

- Parameters:
  - add SCIPparamIsValidInt() and SCIPparamIsValidReal() to param.c/h
  - add missing functions SCIPisIntParamValid() and SCIPisRealParamValid() to scip.c/h

### Command line interface

- new command line parameter `-v` to print detailed build options

### Interfaces to external software

- Interfaces for Python and Java are, among others, now available via http://www.github.com/scip-interfaces
- Revised documentation of the SCIP C-API to group methods more comprehensively by topics
- dropped support for Ipopt < 3.11
- Additional I/O-functionalities for debugging and logging in SCIP and in the AMPL interface
- updated CppAD to 20160000
- for users of the ampl interface, the display/logfile option has been added to set the name of a
  file to write the SCIP log to (additionally to stdout)

- LP Interfaces:
  - SCIP uses the lpi_spx2 interface by default
  - Improved Gurobi interface that can handle ranged rows (requires Gurobi >= 7.0.2)
  - the CPLEX LPI now also compiles with CPLEX 12.7.0.0

### Changed parameters

- setting a value for a fixed parameter will no longer return with an error, if the new value equals the one to which the parameter is fixed
- changed value of parameter `separating/clique/cliquedensity` to 0.0 such that the separator always constructs a dense clique table
  which proved to be faster on the benchmarks MMM and stableset.
- parameters `misc/permutationseed`, `misc/permuteconss` and `misc/permutevars` changed to `randomization/permutationseed`,
  `randomization/permuteconss` and `randomization/permutevars`
- parameters `conflict/useinflp` and `conflict/useboundlp` are now of type char (before bool)
- all parameters of the components presolver (starting with `presolving/components/`) are now parameters of the components
  constraint handler (starting with `constraints/components/`)

### New parameters

- class randomization
- `branching/sumadjustweight` to adjust branching scores by adding a sum epsilon in order to keep score differences
  near zero, which are otherwise completely disregarded (they are adjusted to at least sum epsilon)
- `concurrent/* ` and `parallel/* ` for configuring the concurrent solving mode
- `constraints/cardinality/branchbalanced` to decide whether to use a balanced branching scheme in the enforcing of cardinality
  constraints
- `constraints/cardinality/balanceddepth` to set the maximal depth until balanced branching is turned off
- `constraints/cardinality/balancedcutoff` to determine that balanced branching is only used if the branching cut off value
  w.r.t. the current LP solution is greater than a given value
- `constraints/indicator/sepaperspective` to turn on separation of perspective cuts for indicator constraints
- `constraints/indicator/sepapersplocal` to decide whether local cuts can be used for perspective cuts for indicator constraints
- `constraints/quadratic/projectedcuts` to enable convex quadratics to generate gradients cuts at the
  projection of the point onto the region described by the constraint, which is supporting
- `lp/solutionpolishing` to enable LP polishing only at the root LP or always
- `misc/referencevalue` to pass a reference value for further analysis of the tree search, see also in `features`
- `presolving/qpkktref/addkktbinary` to allow the presence of binary variables for the KKT update
- `presolving/qpkktref/updatequadbounded` to add the KKT conditions to QPs only if all variables are bounded
- `presolving/qpkktref/updatequadindef` to add the KKT conditions to QPs only if the quadratic matrix is indefinite
- `randomization/lpseed` to set the initial seed of the LP solver
- `solvingphases/enabled` to activate adaptive behavior during the solution process; several further parameters
  in the solvingphases-section to control how to switch the parameters and whether a restart should be performed between the phases.

### Data structures

- new `SCIP_REGRESSION` data structure in pub_misc.h to incrementally compute a best-fit line through pairs of observations
- add maximum branch-and-bound tree depth constant `SCIP_MAXTREEDEPTH` (replaces SCIPgetDepthLimit() and SCIPtreeGetDepthLimit())
- new files heuristics.c/heuristics.h to collect methods that are frequently used by heuristics
- merged dive.c/pub_dive.h with heuristics.c/heuristics.h, removed dive.c/pub_dive.h
- separated header pub_misc.h from repeated methods for sorting and (weighted) median selection;
  those are also available in separate headers pub_misc_sort.h
  and pub_misc_select.h, but included into pub_misc.h

Unit tests
----------

- New unit testing system built on the Criterion framework

Build system
------------

### Makefile

- All makefiles in `examples/` and `applications/` have been updated.
- `make.project` defines a variable `SCIP_VERSION` containing the SCIP version number
- revise sub-makefiles for MSVC on MinGW
- make shared libraries aware of their dependencies
- sub-makefile for CrayXC systems added

- Places:
  - All objective files are now placed in `obj/static` or `obj/shared`, depending on `SHARED=false` or `SHARED=true`, respectively.
  - All internal and external libraries are placed in `lib/static` and `lib/shared`, the include files are in `lib/include`.
  - The binaries now contain an rpath to the SCIP directory, such that shared libraries are found.

- Linking:
  - link binary to shared libs when compiling with `SHARED=true`
  - External projects (including make.project) can use the makefile variable LINKCXXSCIPALL or LINKCCSCIPALL to link all SCIP libraries.
  - Building with `SHARED=true` automatically generates the combined library libscipsolver.so for easier linking

- Targets:
  - Running `make help` lists all makefile options.
  - `make install` copies now all header files
  - new target `dll` to build Windows dlls with MSVC
  - rename `dll` target to `windowslib`

Fixed bugs
----------

- fixed bug in event system: bound change events of the new focus node must be processed, even if the bound
  is the same as at the last focus node
- avoid numerically unstable (multi-)aggregations
- fixed bug in XML reader concerning comments
- the AMPL interface now writes a solve status (solve_result_num) into the .sol file
- in the cmpres.awk (allcmpres.sh) output, the counts in the time column are now with respect to the
  whole set of processed instances (as with fail and solv), while before it was with respect to the
  set of instances where no solver failed (eval set); thus, now proc = fail + time + solv.
- writing of solutions or parameters to a file now works also with the message handler set to quiet
- ignore lower and upper bound tightenigs beyond +/-infinity during solving
- time limit of SCIP-infinity is converted to LPI-infinity when setting it
- fix LP activity of a row that has been modified

- Propagation:
  - fixed possible segmentation fault in genvbounds propagator
  - fixed bug with sorting of propagators in presolving: the order can be changed by calling probing; thus, there is a copy of the
    propagators, which is sorted by presolving priority
  - added missing capturing and releasing mechanism in genvbounds propagator
  - fix wrong propagation of product expressions

- Constraints:
  - fixed wrong representation of SOC constraints in NLP
  - fixed a few issues within redundant constraint detection of (specialized) linear constraint handlers
  - fixed issue in reader_opb concerning writing of fixed variables contained in no constraints

- Memory:
  - fixed memory bug in `SCIP_DIGRAPH`
  - improved counting of memory consumption by using more block memory and counting all allocated memory
  - fix memory leaks in TSP example
  - return `SCIP_ERROR` when a memory exception is caught in SoPlex (was `SCIP_LPERROR`)
  - fixed memory leak in OSiL reader

- Objective:
  - fixed bug while changing the objective value of an original value after transforming the problem
  - fixed bug with solutions from previous runs not satisfying an objective limit
  - SCIPisObjIntegral() now works correctly in `SCIP_STAGE_PROBLEM`

- Heuristics:
  - fixed two bugs in heur_indicator: use improvesols parameter now and update pointer to indicator constraint handler
  - fix wrong NLP representation of logic-or constraints in the dual value heuristic
  - correct handling of implicit integer variables with fractional solution value in simplerounding heuristic
  - fixed bug in heur_octane with uninitialized ray direction

@page RN32 Release notes for SCIP 3.2

@section RN321 SCIP 3.2.1
*************************

Features
--------

- new `force` parameter in (root)redcost propagator to run the propagator also with active pricers

Performance improvements
------------------------

- do not transfer solutions to original space, if SCIP is being freed
- modified implication graph analysis of SOS1 constraint handler; a new component allows to deduce zero fixings of variables
- made SOS1 constraint handler specific diving selection rule faster for the case that the SOS1 constraints do not overlap
- improved disjunctive cuts by the `monoidal cut strengthening` procedure of Balas and Jeroslow

Examples and applications
-------------------------

- several improvements of SCIP-Jack (STP application): extended presolving for STP variants, STP-specific branching
  rule, dual heuristic to generate initial LP relaxation
  SCIP-Jack is now competitive with problem specific state-of-the-art solvers on several well-known STP variants,
  e.g., the (rooted) prize-collecting Steiner tree problem.
- MultiObjective application renamed to PolySCIP; several improvements: better command line argument processing,
  overhaul of much of the source code, installation via CMake

Interface changes
-----------------

- made debug solution functionality thread safe (see debug.h for further information)

### Deleted and changed API methods

- add SCIPcomputeHyperplaneThreePoints() to compute a hyperplane containing three given 3-dimensional points
- SCIPsolveLinearProb() now uses a 1-dimensional matrix representation

### Command line interface

- added interactive shell command `display finitesolution` to print solution with infinite fixings removed,
  added reference to that method to `display solution` output if there are infinite fixings
- new interactive shell command `write history` to write the command line history (only when compiled with Readline)

### Interfaces to external software

- significantly improved Python interface to support user callbacks as well as linear and quadratic expressions

### New parameters

- `constraints/sos1/branchingrule` to decide whether to use neighborhood, bipartite, or SOS1 branching (this parameter
  replaces the old parameters `constraints/sos1/neighbranch`, `constraints/sos1/bipbranch`, and `constraints/sos1/sos1branch`)
- `constraints/sos1/depthimplanalysis` to limit the number of recursive calls of implication graph analysis
- `constraints/sos1/perfimplanalysis` to perform an implication graph analysis to deduce variable fixings and
  additional SOS1 constraints (this parameter replaces the old parameter `constraints/sos1/updateconflpresol`)
- `misc/transsolorig` for transfering transformed solutions to the original space (default: true)
- `propagating/rootredcost/onlybinary` to propagate root reduced costs of binary variables only

### Data structures

- renamed MIP matrix structure to `SCIP_MATRIX`
- changed the numeric values for `PRESOLTIMING` flags

Build system
------------

### Makefile

- new target `dll` to build Windows dlls with MSVC
- add new compiling flag OPENSOURCE to allow/forbid the usage of third party software

Fixed bugs
----------

- fixed wrong objective sense when copying the original problem
- fixed a bug in merge step of cliques during clean up phase; method did not correctly handle infeasibility in the case of multiple
  variable-negation pairs
- fixed a previously untreated case in the linear cons simplification where coefficients only differ by slightly more than an epsilon
- fixed bug in parsing emphasis parameters which formerly led to completely wrong results
- fixed bug in the computation of the Wilcoxon test
- do not use the relative and absolute gap limit if no primal solution has been found so far
- fixed bug in conflict.c with wrong reset of bounds used
- fixed bug with transferring solutions to new runs (need to recompute objective before checking)
- fixed issue with infinite values when checking cuts for redundancy
- fixed library problems on Windows operating systems

- Variables:
  - fixed wrong check when computing cuts for factorable quadratic functions bound tightening of a single variable
  - fixed wrong handling of loose variables in OBBT
  - fixed freeing of hash for binary variables
  - fixed bug during the computation of branching points for continuous variables which are almost fixed to +/- SCIPinfinity()
  - treated the case of integer variables as intermediate variables in the process of obtaining the active variable for a
    given binary variable

- LP:
  - fixed a bug in dive.c that occurred when lpsolvefreq was set to 1; after a cutoff, the solution values of the
    linked LP solution might have become invalid
  - do not analyse an infeasible LP for conflicts during diving mode when LHS/RHS of rows were changed
  - use LPi infinity when reverting bound changes in conflict analysis

- Heuristics:
  - fixed bug in heur_simplerounding in connection with relaxators
  - fixed bug in feaspump heuristic where last solution candidates were not updated correctly
  - fixed bug with infinite shift values in heur_shifting
  - fixed bug in shiftandpropagate heuristic: the heuristic did not correctly handle intermediate, global bound changes of the selected variable
    after its tentative fixing led to a cutoff.

- Propagator:
  - (root) reduced cost propagators are not run anymore when doing branch-and-price,
    since they may install upper bounds on variables which might interfere with the
    pricing (they may be enabled again by their force parameters)
  - fixed too hard assertion in pseudoobj propagator
  - fixed a bug in shiftandpropagate where column positions after sorting are now correctly linked to their variables after sorting
  - fixed potential memory leak in genvbound propagator

- Presolving:
  - fixed inconsistency in knapsack constraint handler data during presolving
  - fixed some problem with reoptimization when the problems are infeasible or have been solved in presolving
  - fixed endless loop in knapsack constraint handler when continuous variables change their types to binary during presolving
  - squares of binary variables might not have been replaced by the binary variable itself in presolve,
    if the variable was originally general integer and only became binary during presolve (due to bound tightening)
  - fixed bug in dive.c avoiding a check of constraints in the presence of indicator constraints

- Constraints:
  - fixed numerical problems in computation of cuts for bivariate functions in quadratic constraint handler
  - fixed bug in quadratic constraint handler when computing lifted-tangent inequalities
  - fixed bug in nonlinear constraint handler when replacing a violated nonlinear constraint leads to an infinite
  - fixed bug in SOS1 constraint handler with inconsistent data structure after restart
  - fixed wrong handling of negated variables in bound tightening procedure of SOS1 constraint handler
  - fixed bug in simple fixing heuristic of SOS1 constraint handler
  - fixed two bugs in pseudoboolean constraint handler with wrong sorting of and constraints
  - fixed issue: constraints being parallel to objective function (after restart) sometimes led to wrongly stating infeasible
  - fixed bug during coefficient tightening in varbound constraint handler
  - handle cutoffs in cons_indicator detected by infeasible inequalities
  - fixed late change of type of slack variables in cons_indicator, if the bounds are not integral
  - fixed initsol and exitsol of cons_indicator, if problem has already been solved
  - fixed bug in cons_indicator with changing type of slackvariable

@section RN320 SCIP 3.2.0
*************************

Features
--------

- added reoptimization feature for optimization problems with changed objective function or tighter feasible region
- the original problem can now be permuted directly after reading (if `misc/permutationseed` has value >= 0)
- added methods to compute strongly connected components with Tarjan's Algorithm
- added method to propagate implications of SOS1 variables
- convex quadratic contraints can now generate gradient cuts which are supporting to the feasible region
- SoPlex interface can now (re)store dual steepest edge weights
- extended expression parsing to support power, realpower and signpower operators; started support for user-defined operators
  in expression trees/graphs
- possibility to set a soft time limit which becomes active only after the first primal solution was found
- added matrix module for getting access to the internal mixed inter linear problem matrix
- better handling of large values returned by the LP solver
- added more checks to SCIP{alloc,realloc,duplicate}BufferArray() to handle overflows properly
- new plugin for reoptimizing a sequence of optimization problem that differ in the objective function, e.g., sequences arising from
  column generation
- new plugin `compr` for rearranging the search tree, currently this only works on the reoptimization tree
- moved assertions in comparison methods from scip.c to set.c

- Constraints:
  - we can now upgrade quadratic constraints with one bilinear term to SOC constraints
  - we can also upgrade general quadratic constraints with a single negative eigenvalue to SOC constraints

- Branching:
  - tighter reliability notions introduced for reliability branching, based on pseudo-cost relative errors
    and comparing candidates with the best pseudo-candidate using a 2-sample student-T test. These methods
    are used in disjunction with the existing reliability notion that uses a fixed number as reliability
    threshold for every variable before turning off strong-branching. This means, the classical method
    must be turned off by setting parameters minreliable and maxreliable to 0. The behavior is
    controlled through several parameters.
  - new distribution branching rule to base decisions on row activity (normal) distribution over domain space
  - can now output information for BAK: Branch-and-bound Analysis Kit
  - new score in hybrid reliability pseudocost branching that prefers nonlinear variables when solving MINLPs
  - new branching rule multaggr which allows to branch on general disjunctions defined by fractional multi-aggregated variables
  - new branching rules for SOS1 constraints for branching on a neighborhood or a complete bipartite subgraph of
    the conflict graph. In addition to variable domain fixings, it is sometimes also possible to add complementarity
    constraints to the branching nodes. This results in a nonstatic conflict graph, which may change dynamically
    with every branching node.
  - new branching rule nodereopt to reconstruct the tree after changing the objective function

- Reader:
  - the MPS reader can now read semi-integer variables, they are handled by creating bound disjunction constraints
  - the MPS reader can now handle objective constants given as (the negation of) the RHS of the objective row

- Separation:
  - obbt propagator applies now additional separation and propagation in order to learn stronger and more bound tightenings
  - extended probing mode to allow separation and objective coefficient changes
  - improved separation procedure of SOS1 constraint handler, including bound (clique) cuts and implied bound cuts
  - new disjunctive cut separator for SOS1 constraints
  - new edge-concave cut separator for quadratic constraints

- Presolver:
  - Improved coordination of presolvers. There are three timings for presolvers now, FAST, MEDIUM and EXHAUSTIVE.
    Each presolving callback can specify one or more of these timings in which it will be called later.
    Within a presolving method, the current timing can be checked and the algorithms to be performed selected based on
    the timing. In one presolving round, first all presolving methods with timing FAST are called, sorted by priority.
    If they found enough reductions, a new round is started, otherwise, all presolving methods with timing MEDIUM are
    called. Again, with enough reductions, a new presolving round is started, too few reductions lead to running
    the EXHAUSTIVE presolvers. Similar to the delay concept used before, we are not neccessarily running all EXHAUSTIVE
    presolvers but stop as soon as one of them found enough reductions, starting a new presolving round immediately.
  - new presolving components for SOS1 constraints, including bound tightening and clique extension
  - new presolver tworowbnd for improving variable bounds and detecting redundant constraints added
  - new presolver dualagg for aggregating single up-/downlocked variables by a binary variable added
  - new presolver implfree for aggregating implied free variables added
  - new presolver redvub which can detect redundant variable upper bound constraints added
  - new presolver stuffing for fixing of singleton continuous variables added

- Heuristic:
  - improved clique and variable bound heuristics
  - new heuristic distribution diving that bases its score function on the changes regarding solution density
  - variable histories can be transferred between sub-SCIPs solved by LNS heuristics and the component presolver
    and the main SCIP to reuse this information.
  - new heuristic heur_indicator that tries to make partial solutions with indicator constraints feasible. It also
    tries to improve them (or external solutions) by a one-opt local search.
  - new heuristic (heur_bound) which fixes all integer variables to their lower/upper bounds and solves the remaining LP
  - modified diving heuristics to handle SOS1 constraints
  - new primal heuristic for reoptimization 'ofins': objective function induced neighborhood heuristic
  - new heuristic for reoptimization which constructs solutions based in the changes between the objective function and the optimal
    solution before changing the objective function

- Statistic:
  - extended variable branching statistics in the interactive shell by sample variance of unit gains
  - extended statistic output of interactive shell by more information on diving heuristic behavior

Performance improvements
------------------------

- improved treatment of nonlinearities in hybrid reliability pseudo cost branching
- using sparsity information of the SoPlex LP

- Constraints:
  - improved vartype upgradability from continuous to implicit variables in cons_linear.c, depending on their objective coefficients
  - improved propagation of SOS1 constraint handler using the information from a conflict

- Heuristics:
  - zi rounding heuristic uses buffer data structures, thereby decreasing total memory usage of SCIP
  - adjusted (hard) diving heuristics to solve fewer LPs. LP's are resolved only if a parameter-defined
    percentage of the variable bounds changed through domain propagation or at a predefined frequency.
  - some of the diving heuristics additionally consider indicator variables and SOS1 variables as candidate variables and try to
    make these constraint types feasible before passing a rounded solution to SCIPtrySol()

- Presolving:
  - new presolving/propagation algorithm using the gcd for ranged rows and equations in cons_linear
  - added presolving levels (FAST, MEDIUM and EXHAUSTIVE) to allow better balancing of presolvers

- Separation:
  - improved separation procedure of SOS1 constraint handler
  - improved separation procedure for convex quadratic constraints

Examples and applications
-------------------------

- two new applications for multi-objective optimization (PolySCIP) and the Steiner Tree Problem in Graphs
- new application for solving Steiner tree problems: SCIP-Jack can handle both the classical Steiner tree problem in graphs
  and 10 of its variants

Interface changes
-----------------

### New and changed callbacks

- new callback function `SCIP_DECL_CONSGETDIVEBDCHGS` to provide
  constraint handler method to suggest dive bound changes during the generic diving algorithm, see type_cons.h for details
- new callback `SCIP_DECL_DIVESETGETSCORE` to implement scoring function to guide diving

### Deleted and changed API methods

- avoid potential comparisons of different infinity values by adjusting the LP solution value
- SCIPintervalSign(),  SCIPintervalAbs(), SCIPintervalMax(), SCIPintervalMin(), SCIPexprgraphGetNodePolynomialMonomialCurvature(),
  and SCIPexprgraphTightenNodeBounds() need an infinity value to decide whether an interval is empty or not
- SCIPgetFeasibilityQuadratic() and SCIPgetActivityQuadratic() returns now a `SCIP_RETCODE` and needs an additional `SCIP_Real*` to
  store the result
- methods which support statistical tests in pub_misc.h, SCIPstudentTGetCriticalValue(), SCIPcomputeTwoSampleTTestValue() etc.
- SCIPsolveLinearProb() solves a linear problem of the form Ax=b for a regular square matrix A
- Added parameter `freesubscip` to SCIPapplyProximity()

- Data structures:
  - Renamed method SCIPdigraphGetSuccessorsDatas() to SCIPdigraphGetSuccessorsData()
  - Renamed method SCIPdigraphGetNodeDatas() to SCIPdigraphGetNodeData()
  - Renamed method SCIPdigraphSetNodeDatas() to SCIPdigraphSetNodeData()

- Constraint Handlers:
  - Renamed method SCIPconshdlrGetPropTimingmask() to SCIPconshdlrGetPropTiming()
  - new method SCIPconshdlrSetPropTiming()
  - Removed method SCIPconshdlrIsPresolvingDelayed()
  - Removed method SCIPconshdlrWasPresolvingDelayed()
  - SCIPmakeSOS1sFeasible() based on solution values, fixes variables to zero to turn all SOS1 constraints feasible
  - removed `delay(presol)` parameter from SCIPinclude{Conshdlr,Presol,Prop}() and added `(presol)timing` parameter
  - new parameter `presoltiming` for method SCIPpresolCons()
  - SCIPvarIsSOS1() returns whether some variable is involved in an SOS1 constraint
  - SCIPgetConflictgraphSOS1() gets conflict graph of SOS1 constraints
  - Added parameter `presoltiming` to SCIPpropCumulativeCondition()
  - Removed parameter `delaypos` from SCIPsetConshdlrPresol()
  - Added parameter `presoltiming` to SCIPsetConshdlrPresol()
  - Removed parameter `delaypos` from SCIPincludeConshdlr()
  - Added parameter `presoltiming` to SCIPincludeConshdlr()
  - Added parameter `consgetdivebdchgs` to SCIPincludeConshdlr() to provide a divebdchg-callback for the constraint handler
    to include

- Branching Rules:
  - Added parameter `forcestrongbranch` to SCIPselectVarStrongBranching()
  - Added parameter `executebranching` SCIPexecRelpscostBranching()
  - Added parameters `ndomredsdown` and `ndomredsup` to SCIPgetVarStrongbranchWithPropagation()

- LP and Cutting Planes:
  - Added parameters `inds` and `ninds` to SCIPgetLPBInvRow(), SCIPgetLPBInvCol(), SCIPgetLPBInvARow(), SCIPgetLPBInvACol(), and
    SCIPcalcStrongCG()
  - Added parameters `maxweight`, `weightinds`, `nweightinds`, and `rowlensum` to SCIPcalcMIR()

- Variables:
  - SCIPvarGetNodeSOS1() returns node of SOS1 variable in the conflict graph
  - SCIPnodeGetVarSOS1() returns SOS1 variable associated to some given node in the conflict graph
  - Removed method SCIPvarGetNBinImpls()

- Presolving:
  - Removed parameter `delaypos` from SCIPincludePresolBasic()
  - Added parameter `presoltiming` to SCIPincludePresolBasic()
  - Removed parameter `delaypos` from SCIPincludePresol()
  - Added parameter `presoltiming` to SCIPincludePresol()
  - Removed parameters `presoldelay` and `presoltiming` from SCIPincludePresol()
  - Removed parameters `presoldelay` and `presoltiming` from SCIPsetPropPresol()

- Misc:
  - Added parameter `isequation` to SCIPaddClique()
  - Removed parameter `writeimplications` from SCIPwriteCliqueGraph()
  - Removed method SCIPallocBufferSize()
  - Removed method SCIPduplicateBufferSize()
  - Removed method SCIPreallocBufferSize()
  - Removed method SCIPfreeBufferSize()
  - Removed method callback SCIPdialogExecConflictgraph()

### New API functions

- started support for user-defined operators in expression trees/graphs (see SCIPexprCreateUser()),
  interface will likely change again in future SCIP versions
- new methods for mixed inter linear matrix access (see pub_matrix.h) added
- SCIPcomputeArraysIntersection() to compute the set intersection of two ordered arrays
- SCIPcomputeArraysSetminus() to compute the set difference of two ordered arrays
- SCIPcutGetLPActivityQuot() in pub_cutpool.h to get the potion of LP's where this cut was sharp in an optimal basis.
- SCIPpresolGetTiming(), SCIPpresolSetTiming(), SCIP{conshdlr,prop}GetPresolTiming(), and SCIP{conshdlr,prop}SetPresolTiming()
- SCIPdigraphSetNSuccessors() sets the number of successors of some digraph node to a given value

- Diving:
  - SCIPcreateDiveset() to add a diveset to a heuristic. Heuristics may have multiple divesets under different names
  - SCIPperformGenericDivingAlgorithm() that performs diving with periodic LP resolve according to the diveset argument.

- Constraints:
  - new setter function SCIPsetConshdlrGetDiveBdChgs() in scip.h to set dive bound change callback for this constraint handler
  - SCIPaddDiveBoundChange() to add a diving bound change to the diving bound change storage of SCIP together with the information if this is a
    bound change for the preferred direction or not, to be used by constraint handlers inside the getDiveBdChgs-callback
  - SCIPchgCoefLinear() and SCIPdelCoefLinear() to modify linear constraint during problem creation

- Memory:
  - BMSallocClearBlockMemoryArray()/SCIPallocClearBlockMemoryArray() and
    BMSallocClearBufferMemoryArray(), SCIPallocClearBufferArray() to allocate arrays that are initialized to 0
  - SCIPbuffermem() to get buffer memory;

- Sort:
  - added new sorting functions SCIPsortRealRealRealBoolBoolPtr(), SCIPsortDownRealRealRealBoolBoolPtr()
  - added new sorting functions SCIPsortIntIntIntReal(), SCIPsortDownIntIntIntReal(), SCIPsortRealIntInt(), SCIPsortDownRealIntInt()

- Param:
  - SCIPwriteParam() to write a single parameter to a file
  - SCIPcheckParam{Bool,Char,...}() to check whether a parameter value is within the feasible domain

- Quadratic:
  - SCIPchgLhsQuadratic(), SCIPchgRhsQuadratic(), SCIPchgLinearCoefQuadratic(), SCIPchgSquareCoefQuadratic(),
    and SCIPchgBilinCoefQuadratic() to modify quadratic constraints during problem creation
  - SCIPgetFeasibilityQuadratic() and SCIPgetActivityQuadratic() to get the feasibility and activity of a quadratic constraint in a given solution
  - SCIPaddSquareLinearization(), SCIPaddSquareSecant(), SCIPaddBilinLinearization() and SCIPaddBilinMcCormick()
    in cons_quadratic.h to compute linear under- and overestimation for bilinear and quadratic terms

### Command line interface

- extended variable branching statistics and statistic output in the interactive shell (see Statistic section)
- submenu for setting `vbc` settings renamed to `visual`
- at the end of a command line run the best solution can now be output in the orignal space

### Interfaces to external software

- in the AMPL interface, variable and constraint attributes (flags) can now be set via suffixes, where 0 (unset) stands
  for the default, 1 for TRUE and other values for FALSE; see SCIPcreateVar() and SCIPcreateCons() for their meaning;
  for variables, `initial` and `removable` are recognized;
  for constraints, `initial`, `separate`, `enforce`, `check`, `propagate`, `dynamic` and `removable` are recognized
- the AMPL interface now passes an initial guess, if specified, as a solution (that will be checked for feasibility) to SCIP

### Changed parameters

- rowrepswitch set to 2.0, so row representation is activated if LP has at least 2 times more rows than columns
- one can now set emphasis parameters at the beginning of a settings file; it should start with `emphasis:` and
  the contain the emphasis string, e.g., `emphasis: feasibility` or `emphasis: heuristics off`.

- Renamed parameters:
  - `vbc/filename` to `visual/vbcfilename`
  - `vbc/realtime` to `visual/realtime`
  - `vbc/dispsols` to `visual/dispsols`

### New parameters

- added parameter to switch pseudo cost update in diving heuristics (enabled by default)
- `branching/relpscost/confidencelevel` to set the confidence level to be used by statistical tests
- `branching/relpscost/higherrortol` to define the highest reliability threshold for relative error based reliability
- `branching/relpscost/lowerrortol` to define a lower reliability threshold for relative error based reliability
- `branching/relpscost/nlscoreweight` for weight of nonlinear score when branching on MINLPs
- `branching/relpscost/usedynamicconfidence` to use a dynamic confidence level based on the amount of
  strong-branching simplex-iterations compared to the overall simplex iterations (default is FALSE)
- `branching/relpscost/usehyptestforreliability` to enable strong branching decisions based on a 2-sample student-T test of all prior
  pseudo-cost observations between the best pseudo-candidate and the candidate for which to decide whether strong-branching should be applied
- `branching/relpscost/userelerrorreliability` to enable relative error based reliability
- `branching/relpscost/skipbadinitcands` for skipping strong-branching candidates whose estimated gain
  is significantly worse than the one of the locally best (sb or pseudo) candidate
- `constraints/linear/multaggrremove` to perform multi-aggregations in linear constraint handler only if the constraint can be removed afterwards
- `constraints/linear/rangedrowpropagation` to disabled newly implemented propagtion algorithm for ranged rows and equations
- `constraints/quadratic/advanced/interiorcomputation` to select the way of computing and interior point for gauge cuts
- `constraints/quadratic/gaugecuts` to enable convex quadratics to generate gradients cuts which are supporting
- `constraints/soc/generalsocupgrade` to allow general quadratics to be upgraded to soc
- `constraints/SOS1/addcomps` to add local complementarity constraints to the branching nodes (can be used in combination
  with neighborhood or bipartite branching)
- `constraints/SOS1/addbdsfeas` to define a minimal feasibility value for local bound (clique) inequalities in order to be
  added to the branching node
- `constraints/SOS1/addcompsdepth` to define the maximal depth for adding complementarity constraints
- `constraints/SOS1/addcompsfeas` to define a minimal feasibility value for local complementarity constraints in order to be
  added to the branching node
- `constraints/SOS1/autocutsfromsos1` to automatically switch to separating bound cuts from SOS1 constraints if the SOS1
  constraints do not overlap
- `constraints/SOS1/autosos1branch` to switch to SOS1 branching if the SOS1 constraints do not overlap
- `constraints/SOS1/conflictprop` to define whether to use conflict graph propagation
- `constraints/SOS1/bipbranch` to branch on a complete bipartite subgraph of the conflict graph
- `constraints/SOS1/boundcutsdepth` to define the node depth of separating bound (clique) cuts
- `constraints/SOS1/boundcutsfreq` to define the frequency for separating bound (clique) cuts
- `constraints/SOS1/boundcutsfromgraph` to define whether to separate bound (clique) inequalities from the conflict graph
- `constraints/SOS1/boundcutsfromsos1` to define whether to separate bound (clique) inequalities from SOS1 constraints
- `constraints/SOS1/fixnonzero`: If neighborhood branching is used, then fix the branching variable (if positive in sign)
  to the value of the feasibility tolerance
- `constraints/SOS1/implcutsdepth` to define the node depth of separating implied bound cuts
- `constraints/SOS1/implcutsfreq` to define the frequency for separating implied bound cuts
- `constraints/SOS1/implprop` to define whether to use implication graph propagation
- `constraints/SOS1/maxaddcomps` to define the maximal number of complementarity constraints added per branching node
- `constraints/SOS1/maxboundcuts` to define the maximal number of bound (clique) cuts separated per branching node
- `constraints/SOS1/maxboundcutsroot` to define the maximal number of bound (clique) cuts separated per iteration in the root node
- `constraints/SOS1/maximplcuts` to define the maximal number of implied bound cuts separated per branching node
- `constraints/SOS1/maximplcutsroot` to define the maximal number of implied bound cuts separated per iteration in the root node
- `constraints/SOS1/maxextensions` to define maximal number of extensions that will be computed for each SOS1 constraint in presolving
- `constraints/SOS1/maxsosadjacency` to define that the adjacency matrix of the conflict graph is not created in presolving if
  the number of SOS1 variables is too large
- `constraints/SOS1/maxtightenbds` to define the maximal number of bound tightening rounds per presolving round
- `constraints/SOS1/neighbranch` to branch on a neighborhood of the conflict graph
- `constraints/SOS1/nstrongiter` to define the maximal number LP iterations to perform for each strong branching round
- `constraints/SOS1/nstrongrounds` to define the maximal number of strong branching rounds to perform for each node (only
  available for neighborhood and bipartite branching)
- `constraints/SOS1/sos1branch` to branch on a single SOS1 constraint, i.e., a clique of the conflict graph
- `constraints/SOS1/sosconsprop` to define whether to use SOS1 constraint propagation
- `constraints/SOS1/strthenboundcuts` to define whether to strengthen bound (clique) cuts in case bound variables are available
- `constraints/SOS1/updateconflpresol` to update the conflict graph during the presolving procedure
- `display/allviols` to print all violated constraints of the best solution during checksol in the scip shell
- `heuristics/indicator/improvesols` that turns on the improvement of external solutions by one-opt
- `heuristics/*diving/lpresolvedomchgquot` to determine the percentage of changed domains since previous LP to trigger
  an LP resolve [default: 0.15] (* stands for eight diving heuristics to support this feature)
- `heuristics/*diving/lpsolvefreq` to determine the frequency for resolving LP's during the execution of
  this heuristic [default: 1, use 0 for a dynamic setting based on the number of domain reductions]
  (* stands for eight diving heuristics to support this feature)
- `heuristics/shiftandpropagate/binlocksfirst` to set if binaries without locks should be preferred in ordering
- `heuristics/shiftandpropagate/maxcutoffquot` to select a maximum percentage of allowed cutoffs before stopping the heuristic (default is 0.0)
- `heuristics/shiftandpropagate/selectbest` to trigger if shiftandpropagate should select the best candidate in every round
  (set to FALSE for static order) (default is FALSE)
- `limits/autororestart` for triggering an automatic restart after this many nodes, or -1 for no auto restart [default is -1]
- `limits/softtime` to set a soft time limit (active only after first primal solution was found)
- `misc/allowobjprop` to allow objective function propagation
- `misc/allowdualreds` to allow dual reductions
- `misc/outputorigsol` to control whether at the end of a command line run the solution should be output in the orignal space
- `numerics/checkfeastolfac` to scale feasibility tolerance when checking the feasibility of best found solution
  after the solving process finished (e.g., checksol in scip shell)
- `separating/cutselrestart` for cut selection during restart copy process (`a`ge, activity `q`uotient) [default is `a`]
- `separating/cutselsubscip` for cut selection for sub SCIPs (`a`ge, activity `q`uotient) [default is `a`]
- `separating/disjunctive/maxconsdelay` to delay separation of disjunctive cuts if number of SOS1 constraints is larger than predefined value
- `separating/disjunctive/maxdepth` to define the node depth of separating disjunctive cuts
- `separating/disjunctive/maxinvcuts` to define the maximal number of disjunctive cuts investigated per iteration in a branching node
- `separating/disjunctive/maxinvcutsroot` to define the maximal number of disjunctive cuts investigated per iteration in the root node
- `separating/disjunctive/maxrank` to define the maximal permissible rank of a disjunctive cut that could not be scaled to integral coefficients
- `separating/disjunctive/maxrankintegral` to define the maximal permissible rank of a disjunctive cut that could be scaled
  to integral coefficients
- `separating/disjunctive/maxrounds` to define the maximal number of separation rounds of disjunctive cuts in a branching node
- `separating/disjunctive/maxweightrange` to define the maximal valid range of simplex tableau row weights

### Data structures

- new enum `SCIP_CONFIDENCE_LEVEL` for different levels of confidence for statistical tests.
- new struct `SCIP_DIVESET` that bundles options for SCIP's diving heuristics; all hard diving heuristics (those
  without `obj` at the beginning) include diveset and implement only the scoring callback.
- rename all file `*_vbc.?` to the more generic `*_visual.?`
- moved buffer memory handling to blockmemory/memory.?;
  remove files type_buffer.h, struct_buffer.h buffer.h buffer.c;
  removed functions SCIP*buffer*() from scip.? and replaced them by macros;
  redesigned buffer interface to be similar to block memory; added checks for strange sizes

Testing
-------

- added scripts and targets for testing with xpress (see Makefile section)

Build system
------------

### Makefile

- new parameter `DELHEADERS` for `uninstall`-target: scip headers are only removed when invoking `make uninstall DELHEADERS=true`
- added scripts check_xpress.awk, check_xpress.sh, evalcheck_xpress.sh and check_cluster_xpress.sh and target
  `testclusterxpress` and `testxpress`

Fixed bugs
----------

- fixed bug in primal.c and tree.c by using SCIPinfinity() as a cutoffbound to delete child nodes
- fixed bug in lp.c which leads to wrong primal and dual feasibility
- fixed wrong handling of infinite activities and primal values in sepastore.c and lp.c
- fixed bug that led to an erroneous warning about the clock type
- fix behavior of `make install` which now sets symbolic links and short links to binaries and libraries
- fix bug which lead to wrong global bound tightenings in prop_genvbounds.c
- fix call to random generator for Windows operating systems in misc.c
- fixed again a bug in backward propagation of linear expressions in expression graph
- fixed bug in prop_symmetry.c, where an incorrect weak symmetry handling constraint got added.

- NLP:
  - fixed bug in heur_nlpdiving.c: wrong counting of fix variables
  - fix wrong handling of `SCIP_NLPSOLSTAT_LOCALINFEASIBLE` solution status in nlp.c
  - fix characterization of logic or constraints in SCIP's NLP relaxation

- Branching:
  - fixed wrong comparison when executing branching rule for external branching candidates
  - fix spatial branching on implicit integer variables
  - fix wrong comparisons of values larger/less than +/- SCIPinfinity() in branch.c, lp.c and sol.c
  - fixed problem with lpisrelax flag in probing mode when doing branch-and-price

- Constraint Handlers:
  - try to handle fixings of multi-aggregated variable in cons_sos1 presolving and avoid error
  - fixed bug in pseudoboolean constraint handler about negated variables
  - fixed assert in cons_soc.c: now soc with 1 lhs variable are allowed
  - fixed wrong assert in cons_indicator (slack variables might be replaced by active variables that have nonzero objective)
  - fix late creation of auxiliary LP in cons_nonlinear.c, which lead to a segmentation fault with lpi_spx2.cpp
  - fixed bug in cons_abspower.c: do not generate cuts with infinity right-hand-side anymore
  - fixed setting of enforcement flag for constraints created by reformulation in nonlinear constraint handlers
  - fixed bug in cons_indicator with handling local bounds

- Memory:
  - fix potential memory leak in SoPlex LP interfaces when setting invalid basis
  - fix potential memory leak in method SCIPgetConsCopy()
  - fix potential memory leak in method detectRedundantConstraints() of the knapsack constraint handler

- Interval arithmetic:
  - fix handling of infinite intervals in SCIPintervalIsEmpty()
  - fixed bug in intervalarith.c: bivariate quadratic equations may have been solved wrongly if second variable is unbounded

- Quadratic Constraints:
  - fix wrong sorting of bilinear terms in cons_quadratic
  - fix potentially tightening of LB/UB of a variable to +/- infinity in cons_quadratic
  - fixed bug in cons_quadratic.c which leads to an overflow when SCIP allocates memory for a dense matrix
  - fixed bug in cons_quadratic.c: do not generate linearization cuts for disabled constraints
  - fix missing clean phase of bilinear terms with zero coefficient in cons_quadratic.c

@page RN31 Release notes for SCIP 3.1

@section RN311 SCIP 3.1.1
*************************

Features
--------

- use clock average to reduce number of system calls via `timing/rareclockcheck` parameter
- added copy mechanism for conjunction constraints
- added revised lpi_xprs for using XPRESS as LP solver

Performance improvements
------------------------

- improved solving of LPs in OBBT propagator
- improved activity-delta computation and thereby propagation for linear constraints
- improved memory management of proximity heuristic
- disabled statistic timing in all subscips via new parameter `timing/statistictiming`

Interface changes
-----------------

### New and changed callbacks

- rename array arcdatas in digraph to arcdata
- changes in clock type are now transferred to SoPlex
- corrected wrong primal bound in statistics for unbounded problems
- forbid to call SCIPfixVar() in `SCIP_STAGE_PRESOLVED` stage, which is not allowed since it calls SCIPchgVarLb/Ub()

### Deleted and changed API methods

- rename SCIPdigraphGetNodeDatas() to SCIPdigraphGetNodeData();
- rename SCIPdigraphSetNodeDatas() to SCIPdigraphSetNodeData()
- SCIPapplyProximity() has an additional parameter freesubscip, which causes the method to free
  the created subscip automatically at the end.

### New API functions

- SCIPhasPerformedPresolve() to check, e.g., whether LP duals are accessible
- SCIPconvertRealTo[Long]Int() to convert reals that represent integers to [long] ints.
- SCIPisDualfeasEQ() and related to perform checks w.r.t. to the dual feasibility tolerance
- SCIPdeleteSubproblemProximity() to free proximity subproblem manually as external caller

### Command line interface

- added dialog for writing the finite solution (calling SCIPcreateFiniteSolCopy() before writing)

### Interfaces to external software

- AMPL interface now returns dual multipliers if problem is an LP and presolving was turned off

### Changed parameters

- changed default value of parameter `heuristics/proximity/minimprove` to 0.02; previous value was 0.25
- changed default value of parameter `heuristics/proximity/usefinallp` to FALSE

### New parameters

- `timing/rareclockcheck` to call the system time less frequently, based on the current average time interval
  between two calls to SCIPsolveIsStopped(); the default value is FALSE
- `timing/statistictiming` to enable/disable all timers for statistic output of SCIP; the default value is TRUE

### Data structures

- renamed MIP matrix structure to `SCIP_MATRIX`
- changed the numeric values for `PRESOLTIMING` flags

Build system
------------

### Makefile

- added Makefile support for cygwin 64 Bit
- allow to turn off block and buffer memory by the makefile parameters NOBLKMEM, NOBUFMEM, NOBLKBUFMEM;
  also remove the now superfluous makefiles for noblkmem, nobufmem, noblkbufmem

Fixed bugs
----------

- fixed wrong conversion of reals representing negative integer values
- in debug mode, SCIP checks that no NaN's are introduced in SCIPsolSetVal()
- fixed bug 697 (and 699), calling SCIPsolve() after the problem was already solved and SCIPfreeSolve() was called now
  does nothing anymore
- added support for character `#` in variable names in old non-linear CIP format (i.e., names without `<` and `>`)
- fixed bug 702, removed too hard assert when casting too big values into `SCIP_Longint`
- branching for continuous variables with unbounded intervals now takes `branching/clamp` into account
- forbid aggregations with scalar smaller feastol or larger 1/feastol
- fixed bug 683, not recognizing errors/segfaults especially in free stage of SCIP by improving the check scripts
- fixed bug where quieting a message handler also disabled writing to files other than stdout
- fixed bug 708, special case of implications led to a fixing
- fixed bug, variable bounds detected wrong infeasibility
- another bug fix when computing the original variable sum of a given variable in SCIPvarGetOrigvarSum()
- fixed setting solution value of multi-aggregated var in xml-solution case
- fixed bug changing the variable type of an negated variable
- fixed numerical troubles in SCIPcreateFiniteSolCopy()
- fixed bug in SCIPpermuteProb(): if called before transforming the problem, data structures were not initialized yet
- fixed bug in aggregation procedure if two variables were of non-binary type but for one of the variables
  SCIPvarIsBinary() returned true
- treat activities of pseudo solutions as invalid when containing positive and negative infinity contributions
- fixed bug in GMI example: fractionality of slack variable is now computed correctly
- fixed LP interface of CPLEX: functions getBInv* return the correct sign of the coefficients.
- fixed bug in SCIPpermuteProb(), when called in transformed stage and non-active constraints exist

- Dual:
  - use dual feasibility tolerance for comparisons regarding reduced costs
  - fixed bug in prop_dualfixing: don't fix variables to infinite values during solving
  - fixed sign of the dual multipliers returned by AMPL interfaces for maximization

- Objective and Time Limit:
  - fixed wrong output of status when an objective limit was imposed but not reached yet
  - fixed the rare case that branching was performed even though strong branching found global bound changes leading to
    an infeasible/objlimit LP
  - fixed bug that objective limit was not reset correctly during SCIPfreeTransform() for maximization problems
  - fixed bug that hitting the time limit while solving a pure LP and then continuing the solving process lead to
    not solving the LP, but always creating a single child node until maximum depth is reached

- Heuristic:
  - fixed bug leading to an incorrect dual bound when solving probing LPs within a DURINGPRICINGLOOP heuristic
  - fixed bug in proximity heuristic which attempted to enter diving mode even at nodes without a constructed LP
  - fixed wrong pseudo cost updates during diving heuristic execution after backtracking
  - fixed bug in heur_oneopt: avoid bound violations if shift value is negative due to infeasibilities
  - fixed bug that reaching a solution limit by beforenode heuristics lead to disregarding the current node if the
    optimization process was restarted later
  - fixed bug in trysol heuristic not saving the best solution in maximization problems

- Presolve:
  - fixed bug in presolving of abspower constraints that lead to wrong variable locks
  - allow to call SCIPmarkConsPropagate() in INITPRESOLVE stage
  - fixed bug in components presolver with handling of dual fixable variables: unboundedness was not detected,
    better handle components with single variables by dual fixing propagator
  - issues in component solving by presol_components do not lead to stopping the overall process, anymore, the component
    is just disregarded

- Memory:
  - fixed bug with freeing problem: need to reset objective limit
  - fixed memory leaks in case of erroneous parsing of constraints, e.g., non-linear constraints
  - fixed missing memory allocation for node data in digraphs

- Constraints:
  - fixed bug in cons_quadratic which leads to wrong min/max activities
  - removed wrong break in cons_pseudoboolean
  - fixed bug in cons_varbound.c using the wrong constraint side for updating an upper bound
  - fixed bug in presolve of cons_nonlinear: wrong constraint upgrades may have been performed due to outdated bound
    information in expression graph
  - fixed bug in cons_setppc, wrongly aggregating variables if dual-presolving was disabled
  - fixed bug in cons_sos1: locks and events were not initialized if constraint was added to transformed problem
  - fixed bug in cons_setppc with dual presolving disabled
  - corrected copy of disjunction constraints

- Reading:
  - allow to read numbers like `42856.` in lp-format
  - fixed bug(?) in reader_mps: variables are now written in columns section even of they occur in no constraint
    and have an objective coefficient of 0 (otherwise, CPLEX and Gurobi cannot read the file)
  - fixed bug with reading `>=1` indicator constraints in LP-files
  - fixed bug in reader_lp which created two indicator constraints with the same name to trigger an equality
  - fixed bug when reading indicator constraints for linear constraints (equations/ranged rows) from MPS files

@section RN310 SCIP 3.1.0
*************************

Features
--------

- added breadth first search node selection
- new node selection rule UCT which balances exploration and exploitation by considering node visits
- added possibility to not set a cutoff bound in the LP solver (can be enabled by setting `lp/disablecutoff` to TRUE)
- added missing debugging solution check for cliques
- added a data pointer to each node of the `SCIP_DIGRAPH`
- SCIPgetVarCopy() will now copy the original bounds when called for an original variable
- added upgrade of continuous variables to implicit variables for linear equations even if the coefficient is
  not equal to 1
- probing supports implicit binary variables
- added scaling to computation of relative interior point in SCIPcomputeLPRelIntPoint()

- Solution:
  - added two methods to iterate over a sparse solution (`SCIP_SPARSESOLUTION`), see pub_misc.h
  - it is now possible to add an offset for the original problem instance, all original solutions will be initialized with
    this value and updated, when the offset is changed
  - extended and corrected dual feasibility checks for LP solution (controlled by parameter `lp/checkdualfeas`)

- Cuts and Separation:
  - the rank of cuts is now stored and taken into account to improve numerical stability
  - added possibility to separate a cutpool w.r.t. a given solution (instead of LP-solution)

- Branching:
  - new branching rule `cloud branching` that considers several alternative LP optima
  - additional vbc output added: branching information is printed earlier and also for nodes which were cut off
  - added support for strong branching with domain propagation in full strong and reliability pseudo cost branching
  - added strong branching with domain propagation support: in SCIPstartStrongbranch(), support for propagation can
    be enabled (uses the probing mode, some overhead compared to standard strong branching), after that
    SCIPgetVarStrongbranchWithPropagation() can be used to perform strong branching on a variable with previous domain
    propagation; similar to probing, valid bounds for variables are collected
  - strong branching with propagation can be enabled in fullstrong and relpscost branching rule
  - added possibility to store pricing norms of the LP solver (in addition to basis information) to speed up LP solving
    after a backtrack, e.g. in probing or strong branching with domain propagation
  - a pricer can now return that no further pricing should be done but rather early branching, even if it added variables

- LP interface:
  - SoPlex (>= 1.7.0.5) can compute condition number of current basis matrix via LP interface
  - LPI files (lpi*.[h|c]) all moved from src/scip to src/lpi

- Constraints:
  - added propagation method to cons_xor relying on Gaussian elimination, which can also produce feasible solutions
  - added first implication detection in cons_linear
  - cons_indicator can now try to construct feasible solutions from a cover
  - added possibility to forbid upgrading of linear constraints
  - new initial constraints are now added to the LP before solving a probing LP
  - first implementation of parsing for nonlinear constraints in CIP format
  - added upgrade from varbound constraints to set-packing constraints
  - added upgrade from bounddisjunction constraints to set-packing/logicor constraints
  - cumulative constraint handler adds disjunctive constraints (cumulative with capacity 1) for all jobs which cannot
    be processed in parallel
  - added new clique extraction algorithm for linear constraints
  - the slack variables of indicator constraints can now be scaled
  - added redundancy check of sides of ranged row varbound constraint
  - added coefficient tightening for ranged row varbound constraint
  - XOR constraint handler can add two extended formulations (flow/asymmetric, parameter `addflowextended/addextendedform`)
  - added multi-aggregation for binary variables with at most two uplocks and two downlocks, which emerge from set-
    partitioning or set-packing constraints
  - added upgrade from quadratic constraints to set-packing constraints
  - generalized the linking constraint handler

- Reader:
  - can now read and write CIP-files with (multi-)aggregated variables
  - all readers now take the global parameters `reading/dynamic{conss|cols|rows}` and `reading/initialconss` into account
  - added reader_pbm, which writes the constraint-variable incidence matrix in pbm format (possibly scaled to given size)
  - reader_osil can now read SOS1 and SOS2 constraints
  - reader_lp and reader_mps are now able to write and-constraints in form of their (weak/strict) relaxation
  - added reading capability to GAMS reader (if compiling with GAMS=true, requires a GAMS system)
  - added capability of writing SOS1/2 constraints to GAMS reader (introduces extra variables and equations)

- Heuristic:
  - new primal heuristics dual value
  - new LNS heuristic called `proximity`, which solves a problem in which a local branching constraint replaces the
    objective function which in turn is treated as additional constraint
  - new LP-based rounding heuristic (heur_randround) whose randomized rounding is biased towards the LP solution value;
    the heuristic uses the probing mode of SCIP to generate conflict clauses on the fractional variables

- Presolving:
  - added new dual presolving for setppc-constraints
  - changed dualfix presolver to propagator such that dual fixing can also be applied during repropagation of the root node
  - added full-dual presolving step in setppc constraint handler
  - dual solution can now be displayed for pure LPs when no presolving was performed
  - added clique presolving for xor constraints
  - added presolving using pairs of variable bound constraints that use the same variables
  - added more presolving to cons_indicator, checking whether indicator/slack variables are aggregated
  - added presolve.{c,h} which should be used for all preprocessing mechanisms executed from within SCIP, corresponding to
    solve.{c,h} and also for presprocessing methods which can be called from different plugins or from the core to avoid
    code doubling
  - return error if variable should be fixed to infinity after presolving (LP-solvers do not handle this consistently)
  - in verblevel `SCIP_VERBLEVEL_FULL`, the number of non-zeros will be output for the original and presolved model
  - new presolving step for tightening logicor constraints using implication and clique information
  - several new presolving steps for linear and knapsack constraints, using gcd information and many more

- Statistic:
  - added average gap based on primal-dual integral to solution statistics; can be disabled via parameter
    `misc/calcintegral`
  - the statistics now include the value of the first LP solved at the root node (without cuts)
  - added new statistic which distinguishes between internal nodes and leaves which got processed
  - new section `Root Node` in statistics, listing objective value, iterations and solving time for the first LP solved
    at the root node as well as final dual bound of the root node and LP iterations for processing the root node
    (those where listed in the `Solutions` section before, named `Root Dual Bound` and `Root Iterations`)

Performance improvements
------------------------

- allow multiaggregation of binary variables
- shorten conflicts and deriving global boundchanges from conflicts
- apply lowerbound provided by pricers already during pricing loop, stop pricing if the lower bound computed by pricing
  already exceeds the cutoff bound
- improved performance of SCIPcliquelistDel(), SCIPcliquetableAdd(), SCIPcliquetableCleanup()

- LP Solution:
  - strong branching LP solutions are checked for integrality
  - improved LP reoptimization for branch-and-price applications
  - improved numerical stability checks for LP solution
  - faster feasibility check of LP solutions (controlled by parameters `lp/checkprimfeas` and `lp/checkdualfeas`)

- Presolver:
  - improved methods SCIPlpiGetBInv{Row,Col,ACol} for row representation in SoPlex LP interface
  - improved performance of method SCIPsolRetransform() when called during presolving with many aggregations
  - minor presolving performance improvements in cons_logicor.c and cons_knapsack.c
  - dual fixing presolver was turned into a propagator
  - many presolving improvements in constraint handlers
  - improved dual-presolving for setppc constraints in special cases

- Constraints:
  - major improvements in pseudo-boolean constraint handler
  - performance improvement in domain propagation by marking constraints for propagation
  - added more constraint upgrading possibilities
  - improved handling of initial constraints created during solving
  - disabled scaling in feasibility check of nonlinear constraint handlers
  - conflict consisting of exactly two binary variables will be handled as set-packing constraint instead of an logicor
    constraint and the corresponding clique information is globally added
  - fasten repropagation for set-packing and -partitioning constraints
  - improved merging of and-constraints
  - disabled multi-aggregation in linear constraint handler when coefficients differ too much
  - improved multi-aggregation in linear constraint handler when only one variable in the aggregation has infinity
    contribution
  - added upgradability for implicit binary variable cases for linear constraints

Examples and applications
-------------------------

- new textbook Gomory mixed integer cuts example

Interface changes
-----------------

- removed all message length parameters in message.c and for printing error messages (not needed anymore)

### New and changed callbacks

- Domain Propagation:
  - added parameter `nmarkedconss` to SCIP_DECL_CONSPROP() callback which gives the number of constraints marked
    for propagation (these constraints are listed first in the conss array given as parameter).

- Primal Heuristics:
  - Added parameter `nodeinfeasible` to SCIP_DECL_HEUREXEC() callback which states whether the current subproblem was
    already detected to be infeasible. In this case, the current LP solution might not respect local bounds and the
    heuristic must not assume that it does.

- Variable Pricers:
  - Added parameter `stopearly` to callback method SCIP_DECL_PRICERREDCOST(). This boolean pointer should be used by the pricer
    to state whether early branching should be performed, even if new variables were added in the current pricing round.

- Branching Rules:
  - new possible return value `SCIP_DIDNOTFIND` for SCIP_DECL_BRANCHEXECLP(), SCIP_DECL_BRANCHEXECPS(), and
    SCIP_DECL_BRANCHEXECEXT() callbacks to state that the branching rule searched, but did not find a branching.

### Deleted and changed API methods

- SCIPcalcMIR() takes an additional parameter sidetypes to determine which side of the rows to use
  (relevant for ranged rows)
- SCIPvarParseOriginal() and SCIPvarParseTransformed() now return the end of the parsed string
- SCIPgetConsCopy() now always captures the created constraint

- Branching:
  - Added parameter `nfracimplvars` to SCIPgetLPBranchCands()
  - SCIPgetLPBranchCands() can be used to retrieve the number of implicit integer variables with fractional LP solution
    value via an additional pointer; the corresponding implicit integer variables can be accessed together with their
    fractionalities and solution values in the same way as binary and integer variables before; the arrays are sorted such
    that binary and integer variables precede the implicit integer variables; the method SCIPbranchcandGetLPCands()
    has been modified in the same way

- LP and Cutting Planes:
  - Added parameter `sidetypes` to SCIPcalcMIR() to specify the specify row side type to be used.
  - Added parameter `cutrank` to SCIPcalcMIR() and SCIPcalcStrongCG() which stores the rank of the returned cut;
     via SCIProwChgRank() the rank of a cut can be changed (default rank is 0)
  - Added parameter `infeasible` to SCIPaddCut() which is a pointer to store whether the cut is infeasible for the
    local bounds.
  - SCIPgetLPObjval() now returns the LP value of the current (suboptimal) basis if the iteration limit is hit during LP
    solving (instead of -infinity); this value is not necessarily a valid dual bound and must not be used as such, but can
    be used as an objective estimate, e.g., if strong branching is simulated using the probing mode
  - removed parameter `normtype` from function SCIPcomputeLPRelIntPoint()

- Misc:
  - Added parameter `lazyconss` to SCIPwriteMIP() to swith writing removable rows as lazy constraints.
  - Added parameter `enablepropagation` to SCIPstartStrongbranch(), which can be used to enable strong branching
    with domain propagation.
  - SCIPstartStrongbranch() has a new parameter `propagate` to enable or disable propagation support for strong branching
  - New method SCIPgetVarStrongbranchWithPropagation() which performs strong branching with propagation on a variable.
  - Added parameter `endptr` to SCIPparseVar() which stores the final string position after parsing.

### New API functions

- added SCIPdebugCheckConss() to the debugging mechanism and therefore created a `SCIP_SOL` (in original space) in debug.c
- before copying solutions to the original solution candidate storage, infinite solution values can now be removed using SCIPcreateFiniteSolCopy()
- SCIPsortLongPtrRealBool(), SCIPsortLongPtrRealRealBool(), SCIPsortLongPtrRealRealIntBool() and corresponding
  methods for sorting, insertion and deletion
- SCIPstoreSolutionGap() in scip.c, to store the gap when the first and last solution is found
- SCIPwriteCliqueGraph() which allows to write a graph with node weights for fractional variables

- Separation:
  - SCIPconshdlrIncNCutsFound(), SCIPsepaIncNCutsFound() and SCIPsepaIncNCutsFoundAtNode() to increase the number of found cuts
  - SCIPseparateSolCutpool() to separate a cutpool w.r.t. a given solution

- Constraint Handlers:
  - New method SCIPconshdlrGetStrongBranchPropTime() which returns the time used for domain propagation methods
    of the constraint handler during strong branching.
  - New method SCIPconsIsMarkedPropagate() which returns whether a constraint is marked for propagation.
  - New methods SCIPconsAddUpgradeLocks() and SCIPconsGetNUpgradeLocks() to increase or get the number of upgrade
    locks of a constraint.
  - New method SCIPgetNCheckConss() which returns the number of checked constraints.

- Data structures:
  - New methods SCIPsparseSolGetFirstSol() and SCIPsparseSolGetNextSol() to get the first sparse solution
    or iterate over the sparse solutions, respectively.
  - New methods for the `SCIP_QUEUE` data structure in pub_misc.h to handle a (circular) queue, e.g., SCIPqueueCreate(),
    SCIPqueueFree(), SCIPqueueInsert(), SCIPqueueRemove(), SCIPqueueFirst(), SCIPqueueIsEmpty(), SCIPqueueNElems()
  - New method SCIPgmlWriteNodeWeight() to write a node section including weight to a .gml graph file.
  - New methods for hash tables: SCIPhashtableRemoveAll(), SCIPhashtableGetNElements(), SCIPhashtableGetLoad()
  - New methods in pub_misc.h to handle a resource activity, e.g., SCIPactivityCreate(), SCIPactivityFree(),
    SCIPactivityGetVar(), SCIPactivityGetDemand() ...
  - New methods for digraphs: SCIPdigraphResize() to resize the graph and SCIPdigraphSetNodeDatas() and
    SCIPdigraphGetNodeDatas() to set and get the data attached to the nodes.

- Domain Propagation:
  - New method SCIPpropGetStrongBranchPropTime() which returns the time spent by a domain propagator during strong branching.
  - New methods SCIPmarkConsPropagate() and SCIPunmarkConsPropagate() to (un)mark a constraint for propagation.

- LP and Cutting Planes:
  - New methods SCIPchgRowLhsDive() and SCIPchgRowRhsDive() to change left and right hand side of a row during diving.
  - Added parameter `cutoff` to SCIPsolveDiveLP(), SCIPsolveProbingLP(), and SCIPsolveProbingLPWithPricing()
    which is a pointer to store whether the diving/probing LP was infeasible or the objective limit was reached.
  - SCIPgetFirstLP{Dual/Lower}boundRoot() which return the value of the first LP solved at the root node
  - SCIPgetNRootFirstLPIterations() which returns the number of LP iterations for the first LP solved at the root node
  - SCIPlpiGetNorms(), SCIPlpiSetNorms() and SCIPlpiFreeNorms() for getting the LP pricing norms from the LP
    solver, loading them back into the solver and freeing the data
  - New method SCIPgetFirstLPTime() and SCIPgetNRootFirstLPIterations() to return time and iterations for the first LP solve
    and SCIPgetFirstLPDualboundRoot() and SCIPgetFirstLPLowerboundRoot() to return the first root LP dual and lower bound.
  - New method SCIPprintDualSol() which prints the dual solution for a pure LP (works only with preprocessing disabled).
  - New method SCIPisCutApplicable() which returns whether a cut is good enough to be applied.

- Message Handler:
  - the main output routine of message.c (`bufferMessage` now handleMessage) has been rewritten: it now does not need
    a copy of the string to be output anymore, which makes the code much simpler (and also faster); it is passed a
    function pointer to the output function and uses it to directly output the (buffered) messages
  - New generic messagehandler output callback method SCIP_DECL_MESSAGEOUTPUTFUNC().
  - Removed parameter `msglength` from callback method SCIP_DECL_ERRORPRINTING().
  - New method SCIPmessageVPrintError() to print an error message.
  - Removed method SCIPmessagePrintWarningHeader().

- Parameters:
  - New method SCIPparamGetCharAllowedValues() to get the allowed values for a char parameter.
  - New method SCIPgetParam() to get the parameter with a given name.

- Variables:
  - SCIPapplyProbingVar() in prop_probing.h
    without deteriorating its objective value
  - SCIPshrinkDisjunctiveVarSet(), which takes an set of variables with corresponding bounds and boundtypes, and
    tries to derive global boundchanges and also to shorten this set of variables by using cliqe, implication and
    variable bound information
  - SCIPselectVarStrongBranching() to get the variable that fullstrongbranching would select
  - New method SCIPvarGetValuehistory() to get the value-based history of a variable.

- Misc:
  - New method SCIPdoNotMultaggr() which returns whether multi-aggregation was disabled.
  - New method SCIPcreateFiniteSolCopy() to create a copy of a solution with infinite fixings removed.
  - New method SCIPadjustImplicitSolVals() which sets implicit integer variables to an integer value in the given
    solution without deteriorating its objective value.
  - New method SCIPcopyOrig() to copy the original problem. Analoguosly, use SCIPcopyOrigProb(), SCIPcopyOrigVars(),
    and SCIPcopyOrigConss() to copy original problem data, variables, or constraints, respectively.
  - New method SCIPwriteCliqueGraph() to write the clique graph in GML format into a given file
  - New method SCIPaddOrigObjoffset() to add an offset to the objective function.
    in original space and updates all orignal solutions correspondingly
  - New method SCIPcopyImplicationsCliques() to copy implications and cliques to a copied SCIP instance.
  - New method SCIPgetOpenNodesData() which returns all unprocessed nodes.
  - Added parameter `endline` to SCIPprintDisplayLine() to switch printing a newline symbol at the end of the line.
  - New method SCIPgetNLimSolsFound() returning the number of feasible primal solution respecting the objective limit.

### Command line interface

- allow dialog option to write clique graph
- dual solution values can now be obtained in the interactive shell after solving a pure
  LP without presolving

### Interfaces to external software

- new SoPlex 2.0 interface, can be enabled with `LPS=spx2`
- add support for SOS1 and SOS2 constraints to AMPL interface (see `interfaces/check/testset/SOS/sos?a.mod` for example)
- added copy of GAMS interface from COIN-OR/GAMSlinks project; GAMS-reader in SCIP can now read model instances from .gms files
- beta version of a python interface for the scipoptsuite is now available under interfaces/python
- beta version of a Java native interface is now available under `interfaces/jni`

### Changed parameters

- parameter `branching/scorefunction` has new value `q` for for `q`uotient branching score function
- replaced parameter `lp/checkfeas` by two parameters `lp/checkprimfeas` and `lp/checkdualfeas` to decide on primal and dual
  feasibility checks individually
- removed all local parameters `reading/(READER)/dynamic{conss|cols|rows}` and replaced them by global parameters
  `reading/dynamic{conss|cols|rows}`
- changed default value of parameter `numerics/dualfeastol` to 1e-7 for safer dual bounds from LP solver
- new possible values for parameter `heuristics/shiftandpropagate/sortkey` for sorting variables w.r.t. their norm,
  default changed from `u` to `v`, which means sorting downwards by violations

- Constraints:
  - changed type of parameters `constraints/bivariate/scaling`, `constraints/quadratic/scaling`, `constraints/soc/scaling`
    from boolean to character
  - changed default for `constraints/{abspower,bivariate,nonlinear,quadratic,soc}/scaling` to off
  - changed default max coefficient for big-M constraint to be initial from 1e6 to 1e9

- Separation:
  - changed default value of gomory cut separation parameter `separating/gomory/maxrank` from 0 to 3, to take also gomory
    cuts that could not be scaled to integral coefficients, with maximal rank 3 into account
  - remove parameter `separating/closecuts/relintnormtype`

### New parameters

- `branching/checksol` and `branching/heursbsol` to specify whether the strong branching LP solution
  should be checked for feasibility and whether a simple rounding heuristic should be run on this solution
- `branching/firstsbchild` and `branching/forceall` to specify the first child node to be
  investigated during strong branching (`u`p, `d`down, `a`uto) and whether always both children should be solved (only for
  strong branching with domain propagation, per default, the second child is not looked at when the first is infeasible)
- `conflict/fullshortenconflict` to decide whether we want to stop shortening a conflict set, when no
  global bound changes can be found anymore
- `conflict/maxvarsdetectimpliedbounds` to decide whether the a valid conflict of what maximal length
  will be used to derive global bound changes
- `constraints/{linear,knapsack}/detectcutoffbound` and `constraints/{linear,knapsack}/detectlowerbound`
  to enable/disable detection of constraint parallel to the objective function that will add an cutoffbound or an
  lowerbound respectively and these constraints will be prevented from entering the LP
- `constraints/and/upgraderesultant` to upgrade resultants of and constraints from binary to implicit binary variables, default is TRUE
- `constraints/abspower/scaling` and `constraints/nonlinear/scaling`
- `constraints/indicator/scaleslackvar` for scaling of the slack variable in indicator constraints
- `constraints/indicator/trysolfromcover` for trying to construct a feasible solution from a cover
- `constraints/linear/checkrelmaxabs` for checking linear constraints with a side of 0.0 relative to
- `constraints/linear/detectpartialobjective` to enable/disable the detection of sub-equations of the objective function
- `constraints/logicor/strengthen`, should pairwise constraint comparison try to strengthen constraints by removing superflous non-zeros?
- `constraints/xor/addextendedform` to add an extended formulation in XOR-constraints
- `constraints/xor/addflowextended` to add use the extended flow formulation in XOR-constraints
- `heuristics/<heurname>/lplimfac` for LNS heuristics to limit the number of LPs solved in a subproblem
  the maximum absolute value in the activity instead of 1.0
- `heuristics/shiftandpropagate/fixbinlocks` for fixing binary variables with no locks in one direction to the corresponding bound
- `heuristics/shiftandpropagate/collectstats` which decides whether variable statistics are collected
- `heuristics/shiftandpropagate/impliscontinuous` to decide whether implicit integer variables are treated as continuous variables
- `heuristics/shiftandpropagate/preferbinaries` and `heuristics/shiftandpropagate/stopafterfeasible`,
  which decide whether binaries should be shifted first and the shifting should be stopped when no violations are left
- `lp/disablecutoff` to toggle usage of LP cutoff bound (0: enabled, 1: disabled, 2: auto = disabled if pricers are used)
- `misc/calcintegral` (default TRUE) to trigger calculation of primal-dual integral
- `misc/finitesolutionstore` to switch whether infinite fixings should be removed from solutions before
  copying them to the original solution store
- `misc/permuteconss` and `misc/permutevars` to control whether variables and/or constraints should be permuted, if permutationseed != -1
- `presolving/components/feastolfactor` to increase the feasibility tolerance in all sub-SCIPs, when solving a component
- `propagating/obbt/conditionlimit` to discard instable LP bases
- `reading/(READER)/initialconss` that determines whether model constraints are initial
- `reading/cipreader/writefixedvars` for disabling printing of fixed variables in CIP format
- `reading/lpreader/aggrlinearization-ands` and `reading/mpsreader/aggrlinearization-ands` to enable/disable
  the printing of the weak or strict relaxation of and-constraints in LP and MPS format, respectively
- `reading/lpreader/linearize-and-constraints` and `reading/mpsreader/linearize-and-constraints` to
  allow and-constraints to be linearized when printing in LP and MPS format, respectively
- `separating/feastolfac` to allow dynamic decrease of relaxation feasibility tolerance depending on feasibility to applied cuts,
  i.e., allow relaxation solutions to have a primal infeasibility of at most this factor times the infeasibility of applied cuts
- `separating/gomory/sidetypebasis` to decide whether the sides of ranged rows should be determined from the basis status
- `separating/oddcycle/cutthreshold` to run odd cycle separation if not enough cuts have been found
- `separating/zerohalf/delayedcuts` to use the delayed cutpool for the zerohalf separator
- `write/allconss` to enable that all constraints are written
- `write/genericnamesoffset` when writing a generic problem to define an offset on the variable numbering

### Data structures

- New structure to store value-based branching and inference history (see pub_history.h).
- new data structure for (circular) queues (`SCIP_QUEUE`)
- hash tables will now increase dynamically
- Moved LP solver interfaces to subdirectory `src/lpi`.

Testing
-------

- added McNemar tests and Wilcoxon signed rank tests to cmpres.awk evaluation scripts
- added passing MEM option of testgams(cluster) target as workspace option to GAMS jobs
- extended test scripts by statistical tests

Build system
------------

### Makefile

- default flag for ZIMPL is now `auto`, which means that it is built if and only if GMP is available (GMP=true)
- fixed make install for older Mac systems where install command does not have option -t
- dropped support for Ipopt < 3.10

Fixed bugs
----------

- fixed bug when adding (global) clique, implications or variable bound information in solving stage that lead to
  global bound changes which contradict local bounds and therefore need to be stored as pending bound changes
- unlinking a solution now copies solution values smaller than SCIPepsilon() avoiding some feasible solution in the
  transformed problem to be infeasible in the original problem
- fixed bug when flushing the warning buffer when SCIP is closed
- fixed bug when a bound change contradicts a local bound and is stored as pending, but the contradicting local
  bound becomes global afterwards (--> node where pending bound change is valid can be cut off)
- fixed statistics bug: externally given solutions and new solutions found while transforming existing ones
  are now listed in line `other solutions` of primal heuristics statistics
- fixed bug in random generators SCIPgetRandomInt() and SCIPgetRandomReal() for large intervals
- make sure that bound changes of negated original variables are correct

- Branching:
  - fixed bug w.r.t. changing the variable branching priority beyond the problem stage
  - allow again branching on continuous variables with huge bounds

- Separation:
  - fixed bug in sepa_cgmip computeObjWeightSize() w.r.t. equal sized rows
  - fixed wrong bound calculation in sepa_rapidlearning
  - fixed bug in flowcover separator to exclude unconstrained rows in aggregation

- LP and Interfaces:
  - fixed bug that lead to resolving the LP after diving instead of restoring the buffered solution
  - fixed rare bug with conflict analysis and LP/LPI having different states after diving
  - fixed several bugs in lpi_grb
  - fixed wrong strong branching results in lpi_grb.c and an invalid write
  - fixed bug in handling max-function in ampl interface; added support for min-function

- Presolving:
  - fixed bug in prop_dualfix w.r.t. to fixing of variables to infinity after presolving
  - fixed wrong presolving finished status which sometimes occurred when the time limit was hit during presolve
  - fixed bug where a limit on presolving rounds was exceeded by 1
  - fixed minor bugs in presolving in cons_setppc.c and cons_logicor.c
  - fixed minor bug in cons_linear w.r.t. disabled presolving

- Propagators:
  - fixed bug in genvbounds propagator occurring when objective offset or scale changes after a restart
  - fixed bug in genvbounds propagator by replacing non-active variables on right-hand side after presolving

- Readers:
  - fixed memory bug in reader_mps
  - fixed several minor bugs with handling of memory when writing aggregated variables (reader_lp, reader_mps)
  - fixed bug in reader_lp when writing bilinear terms (product sign was missing)
  - fixed bug in reading indicator constraints in mps-format
  - nonlinear readers now create auxiliary objective variables and constraints always as initial and not removable
    in order to avoid unbounded LPs due to loose variables with infinite best bound

- Constraints:
  - fixed several bugs where variables or constraints were not freed correctly
  - do not multi-aggregate variables if the constant would be a huge value in order to avoid numerical troubles
  - fixed bug with infinite multi-aggregation constants
  - fixed output of aggregated variables in indicator constraints in lp and mps-format
  - improved handling of initial constraints: constraints which are initial, but added during the search to an already
    treated node are kept and added to the LP at every node where they are active
  - fixed bug in cons_superindicator concerning names of upgraded constraints
  - fixed bug in cons_indicator with trying to create solution in problem stage
  - fixed bug in cons_orbitope with fixing upper right triangle in non-root nodes

Miscellaneous
-------------

- new SCIP Optimization Suite homepages

@page RN30 Release notes for SCIP 3.0

@section RN302 SCIP 3.0.2
*************************

Features
--------

- reading erroneous CIP files can now output some indication of syntax errors
- can now run splint on core files
- cons_xor now uses the integral variable in propagation
- allowed to switch on/off the solution debugging

Performance improvements
------------------------

- improved SCIPlpiAdd{Cols,Rows}() in SoPlex LPi

Examples and applications
-------------------------

Interface changes
-----------------

### New API functions

- SCIPmarkColNotRemovableLocal() and SCIPmarkRowNotRemovableLocal() to forbid removal of an column/row
  from the LP in the current node
- SCIPmessageVPrintError()

### Command line interface

- can now output the solutions in the solution pool in the interactive shell

### Interfaces to external software

- updated Mosek LP interface to compile with Mosek 7

Fixed bugs
----------

- fixed bugs in solution counting
- fixed fieldtypes in sorting template
- fixed bug concerning the userinterrupt flag, which was not reset
- fixed solution collection when counting solutions
- fixed bug with storing original solutions
- fixed bug with infinite multi-aggregation constants
- fixed bug that removing reverse implication did not reset closestvblpcount
- fixed bug that duplicate solutions stopped copying of solutions to original solution candidate store
- forbid branching on variables with huge bounds; such huge values cannot be enumerated with fixed precision
  floating point arithmetics
- fixed bug that Ipopt's error message was not fully shown due to exiting before the message handler buffer was emptied
- unlinking a solution now copies solution values smaller than SCIPepsilon() avoiding some feasible solution in the
  transformed problem to be infeasible in the original problem
- allow to add columns (rows) with nonzero indices beyond current number of rows (columns) in SoPlex LPi
- updated get.ASL script to cope with broken ftp access to netlib server

- Memory:
  - fixed bugs with freeing C++ object data for problem and variables
  - fixed memory leak in lp.c (probably never occurred so far since array was not used)
  - fixed bug in sepa_zerohalf.c where the maxcuts(root) parameters led to an invalid memory allocation call

- LP:
  - fixed assert in solve.c with branched status and LP reached the objective limit
  - fixed bug in heur_oneopt.c and heur_clique.c which was caused by side-effects when calling SCIPconstructLP(); when
    adding new variables in this method (e.g. adding new variables needed for a relaxation), this changes the variables
    array of SCIP
  - fixed problem that diving did not save status for infeasible LPs
  - fixed bug in SCIPlpComputeRelIntPoint() with wrong iteration limit and with wrong recompution
  - fixed bug that old LP size was not updated for deadend if no LP was solved

- Expressions:
  - fixed issues with ungraceful termination when encountering unsupported expression operands in AMPL interface
  - fixed bug in backward propagation of linear expressions in expression graph

- Propagation:
  - fixed potential performance issue with tree depth always assumed to be zero when propagating in probing mode
  - fixed bug in prop_vbound w.r.t. creation of variables during the search
  - fixed several bugs in propagation of cons_xor: need to take integral variables into account
  - fixed bug in cons_abspower.c handling infinity values in propagation
  - fixed bug in cons_and.c when a constraint was not correctly propagated which led to wrong dual-presolve reductions
  - fixed bug in cons_abspower: wrong infinity check when propagating bounds

- Presolving:
  - fixed bug that the number aggregated variables were not counted in presol_inttobinary.c
  - fixed bug in presol_domcol: locks are now checked to see whether rounding was forbidden for a variable

- Reader:
  - fixed bug in reader_gms.c w.r.t. writing nonlinear expressions with polynomials with constants
  - fixed bugs in parsing bounds from CIP-files, in reader_gms and AMPL interface
  - fixed bug when reading a mps formated file with a missing bound in the bound section

- Constraints:
  - fixed bug in cons_bounddisjunction with satisfied literal of multi-aggregated variable
  - fixed bug in upgrade method of cons_soc
  - fixed issue with negated variables in cons_xor.c
  - fixed several asserts in cons_xor presolving
  - fixed bug in cons_xor.c calling method on null pointer row
  - fixed bug using a too hard comparison on the objective-infeasible-decision in constraint enforcement
  - fixed possible cycling in enforcement of nonlinear constraints due to too early removal of newly added cuts from LP
  - fixed bug wrongly removing constraints locally while counting
  - fixed bugs in cons_bivariate.c when the nonlinear function is not differentiable on the boundary of the domain
  - fixed bug in cons_indicator.c:SCIPmakeIndicatorFeasible() with handling fixed variables
  - fixed bug in cons_integral: check integrality of implicit integer variables when a solution is checked for feasibility
  - fixed bug in Undercover with `pseudo-`quadratic constraints
  - fixed bug with quadratic constraints not being upgraded
  - fixed bug in intervalarith.c: bivariate quad. equations may have been solved wrongly if second variable is unbounded

- Separation:
  - fixed bug in sepa_zerohalf.c not copying the displays to the subscip, but still changing a display parameter there
  - fixed iteration limit determination in sepa_closecuts
  - fixed bug in sepa_closecuts: need to make sure that variable values of separation point satisfy bounds
  - fixed bugs in sepa_oddcylce: number of arcs have to be adjusted, handle implicit binary variables,
    fixed bug in heuristic separation method, fixed asserts
  - fixed wrong bound calculation in sepa_rapidlearning

@section RN301 SCIP 3.0.1
*************************

Features
--------

- added delayed cutpool which only gets separated if the sepastore is empty after a separation round
- sepa_cgmip can now take the objective row into account
- added possibility to run clang compiler
- statistics now include output on number of solutions that respect objective limit

Performance improvements
------------------------

- also copying active tight cuts from the delayed cut pool when calling SCIPcopyCuts()
- sort genvbounds only when root node is finished; apply more often

Examples and applications
-------------------------

Interface changes
-----------------

- when using an objective limit, heuristic characters are not displayed any longer for worse solutions

### Deleted and changed API methods

- fixed spelling in the method name SCIPgmlWriteClosing()

### New API functions

- SCIPgetNLimSolsFound() to get number of solutions that respect the objective limit

Fixed bugs
----------

- fixed issue with applying the effective root depth during the search
- fixed bug concerning usage of dualbound and lowerbound
- fixed bug trying to color probing nodes, which are not added to the vbc output anymore
- fixed bug in sorting template
- fixed bug leading to removing a ranged row parallel to the objective function, although one of the sides was still needed
- fixed a bug correcting the binvarssorted flag in cons_linear.c
- fixed bug in cons_varbound.c not resolving multi-aggregated variables
- relaxed assert in SCIPvarCh{Lb,Ub}{Global,Local} that new bound must be tighter to feastol
- fixed contra-intuitive behavior when using SCIP with objective limits and solution limit at the same time;
  SCIP now only stops when sufficiently many solutions better than the objective limit have been found
- fixed bug when adding binary implications with non-vartype binary variables
- fixed bug adding binary implications on binary variables with type != `SCIP_VARTYPE_BINARY`
- fixed bug concerning different tolerances for reached objective limit in case of pricing with fastmip

- LP:
  - fixed bug which disabled iteration limit in SCIPlpSolveAndEval()
  - ensure consistency of LP bounds during OBBT diving, i.e., that lower <= upper holds exactly
  - set lpsolstat to `SCIP_LPSOLSTAT_NOTSOLVED` in SCIPchg{Lp,Dual}feastol()
  - use tighter dual feasibility tolerance for LPs solved during optimization-based bound tightening
  - fixed bug with unflushed LP arising from global bound changes in strong branching

- Constraints:
  - fixed issue with deleting varbound constraints in case the bound change was not applied
  - fixed bugs in parsing dis-/conjunctive constraints
  - fixed bug with handling of empty logicor and bounddisjunction constraints
  - fixed issue in cumulative constraint and separation
  - fixed bug when sorting knapsack constraints with the same weights
  - fixed bug resulting in trying to delete an upgraded linear constraint a second time in exitpre callback
  - fixed minor bug in conjunctive constraint handler printing wrong constraint
  - fixed bug in disjunctive constraint handler when enforcing a constraint
  - fixed behaviour change of indicator constraint handler when solving another instance after solving one using the
    interactive shell
  - fixed several issues in cumulative constraint handler
  - fixed bug in cumulative constraint handler w.r.t. getting active variables
  - fixed bug in cumulative constraint handler concerning conflict analysis

- LPI and Interfaces:
  - fixed bug in CppAD in connection with abspower constraints
  - fixed bug in CppAD when using signpower functions with expression pointers that do not fit into an unsigned int
  - better handling of generalized (Lagrangian) variable bounds that are not in the LPI
  - fixed wrong basis rstat values in CPLEX LPI
  - fixed bug with LP not being flushed after bound changes on columns that are not in the LPI
  - methods SCIPlpiIs{PrimalFeasible,DualFeasible,DualUnbounded}() in SoPlex LPi now check that the LP is not perturbed,
    which may happen when stopping due to iteration or time limit
  - fixed inconsistencies between methods SCIPlpiIs{PrimalFeasible,DualFeasible,Optimal,...} in SoPlex LPi

- Propagation:
  - fixed bug when adding linear constraints with non active variables in solving process, during propagation this
    resulted in changing the row, which is not possible for unmodifiable constraints/locked rows
  - fixed small issue in pseudo objective propagator w.r.t. propagating the lower bound globally
  - fixed bug in cons_orbitope: in rare cases one cannot repropagate
  - fixed bug of wrong result code in propagation in prop_genvbound.c

- Presolve:
  - fixed bug in copying nonlinear constraints during presolve (resulted
    in wrongly declaring instances as infeasible when using component presolve)
  - fixed bug in copying nonlinear constraints during presolve (nonlinear part was not copied)

- Heuristics:
  - fixed wrong solving status (OPTIMAL) in case an unbounded solution was provided or found by heuristic before presolve
  - fixed bug in heur_subnlp running with tightened tolerances: sumepsilon must be tightened like feastol and epsilon
  - fixed bug in nlp diving heuristic for fractional variables with values slightly outside of their domain

- Numerics:
  - fixed several numeric issues
  - fixed numerical bug in conflict.c relaxing bounds while keeping an infeasibility proof
  - fixed feasibility decision bug when replacing inactive variables by their active counterparts, which might change the
    redundancy status of a bounddisjunction constraint due to numerics
  - fixed numerical bug adding a relaxed bound for conflict analysis in cons_varbound
  - fixed numerical bug in conflict analysis of genvbounds propagator

@section RN300 SCIP 3.0.0
*************************

Features
--------

- SCIPcomputeLPRelIntPoint() with normtype=`s` now uses homogenized LP for computing rel.int. point too and allow to
  set relaxrows = FALSE
- new column showing the pseudo objective value
- digraph structure added to misc.c and pub_misc.h that can be used to handle directed graphs, compute undirected
  components in the graph and sort these components (almost) topologically
- SCIP does now print an info message when the root LP could not be solved or is unbounded
- added counter and clock for SCIPcopy() calls
- correct initialization of steepest edge weights with SoPlex 1.6.0.4
- parameters can now be fixed, which means that their value cannot be changed unless they are unfixed, first;
  the fixing status of a parameter is copied to sub-SCIPs, which allows to ensure that certain parameters
  are also not changed when, e.g., heuristics change emphasis settings or also specific parameters
- automatic transfer of original solutions (e.g., provided by the user, from solution pool, after restart, from heuristic
  adding original solution during solve) to the transformed space (might fail due to, e.g., dual fixings)
- added possibility to use GUBs for lifting knapsack cuts (disabled)
- added pre- and post-conditions in doxygen documentation for all methods of scip.{c,h}
- added zeroobj heuristic that solves a copy of the problem without an objective function and with quite strict limits
  on the number of nodes and LP iterations
- complete reworking of the vbounds propagator: it now takes into account variable bounds, cliques and implications,
  stores bounds of variables which were changed and performs a forward propagation from these bounds, i.e., tries to
  derive new bounds for other variables; during propagation, bound changes are propagated in an (almost) topological order

- Constraints:
  - full version of cumulative constraint handler
  - new constraint handler `superindicator` for indicator constraints with slack constraints of arbitrary type
  - implemented first clique lifting procedure in cons_setppc.c (by default is off)
  - the conjunction and disjunction constraint handlers are now able to parse their CIP output format

- Memory:
  - better handling of memory limits, in particular for large problems
  - estimate memory consumption for sub-SCIP and do not copy them if close to memory limit

- Presolve:
  - time for initpre and exitpre methods is now also measured in presolving time
  - added dual presolving for and-constraints difficult instances (no guarantees)
  - oneopt can now be called before presolving
  - added a presolving step in the disjunctive constraint handler, removing disjunction, where a sub-constraint was
    deleted, which means this sub-constraint is redundant, which again means it is always TRUE or will be enforced by
    another constraint
  - added new presolver convertinttobin, which converts bounded integer variables to their binary representation, e.g.
    for integer variable 0 <= x <= 10 the binary variables y0, y1, y2 and y3 are created, such that
    1 y0 + 2 y1 + 4 y2 + 8 y3 <= 10 and x = 1 y0 + 2 y1 + 4 y2 + 8 y3
  - added new presolver gateextraction, which tries to find and-gates/constraints which are linearized
    e.g. (x + y + z >= 1, x + y <= 1 and x + z <= 1 => x == AND(~y,~z)), in special cases it also detects set-partitioning
    constraints e.g. (x + y + z >= 1, x + y <= 1, x + z <= 1 and y + z <= 1 => x + y + z == 1));
    gate-extractor is also able to detect logicor constraints and set-packing/-partitioning constraints with the same
    variables, to upgrade these both constraints to a set-partitioning constraint
  - added new presolver components, that searches for independent components in the problem structure and solves
    these components as sub-SCIPs when they are small enough (per default <= 20 discrete variables, nodelimit of 10000)
  - added new presolver domcol that looks for dominated columns in a MIP and tries to fix them

- Reader:
  - CNF reader now creates feasibility instances per default, usage of an objective has to be set by a parameter
  - added reader for MI(NL)Ps in OSiL (Optimization Services Instance Language) format

- Statistic:
  - new statistics and new statistic output messages
  - number of presolving calls of plugins is counted and displayed in the statistics,
    can be accessed via SCIPpresolGetNCalls() and SCIP{prop/conshdlr}getNPresolCalls()
  - the statistics shows for a branching rule the number of calls for LP, extern and pseudo candidates
  - new switch `SCIP_STATISTIC` and new macros SCIPstatisticMessage(), SCIPstatisticPrintf() and SCIPstatistic() to output
    statistic and execute code lines which are only needed therefor. Works as `SCIP_DEBUG` and SCIPdebugXyz()
  - added statistics on the number of cuts/rows that have actually been applied to the lp for each constraint handler and separator;
    use SCIPcreate(Empty)RowCons() and SCIPcreate(Empty)RowSepa() to support the statistics.

- NLP:
  - new propagators obbt and genvbounds for MINLP
  - new NLPI parameter `SCIP_NLPPAR_FASTFAIL` to enable convergence checks in NLP solver to stop early on seemingly
  - added nlpdiving heuristic that comprises several diving heuristics using an NLP relaxation

Performance improvements
------------------------

- improved scaling by choosing the smallest scaler
- if first root lp is solved and the optimality is rejected by SCIP, there won't be an unnecessary solving of the lp
  from scratch again
- several performance improvements for Pseudo-Boolean optimization, pseudo objective propagator
- streamlined initlp functions in cons_indicator, cons_sos1, cons_sos2 (add rows only if needed)
- improved time used for adding implications
- speed up in SCIPboolarrayExtend() in misc.c replacing a for loop with BMSmoveMemoryArray() call
- speed up in var.c changing some recursive calls into iterative calls and reducing the number of VARFIX event that are
  thrown for fixation, aggregation or multi-aggregations
- revised reduced cost propagator
- increased performance in SCIPcliqueAddVar(), adding a variable to a clique
- tighten primal and dual feasibility tolerances independently if they are not reached in LP solving

- Probing:
  - if probing reached the end of all variables it will restart the probing cycle correctly
  - improved probing by ordering the variables differently and applying the one-branch before the zero-branch

- Constraints:
  - improved scaling of linear constraints, linear constraints with integral variables will now be scale with
    1e+06/MAX(maximal absolute coefficient, 1.0) instead of 1e+03/MAX(maximal absolute coefficient, 1.0);
    if all coefficients are in absolute value equal they will be scaled by that
  - added clique presolving for and-constraints, which checks if two operands or one operand and the resultant are in a
    clique and then fixes the resultant to 0 and in the former case we can delete the and-constraint too
  - speed up in linear constraint handler replacing aggregated variables
  - when all nonlinearities have been fixed and the number of nonfixed variables is 1 in cons_nonlinear/cons_quadratic/
    cons_bivariate, handle it by a bound change instead of adding a linear constraint

- Separation:
  - automatically turn off separation in sepa_oddcycle if it was too unsuccessful within the last calls
  - use faster Dijkstra variants in sepa_oddcycle
  - improved tcliquegraphAddImplicsVars() in sepa_clique.c to faster add possible variables
  - changed emphasis settings: knapsack disaggregation is now allowed in fast presolving, CG-MIP separator disabled in
    aggressive separation

- Reader:
  - improved lp-, mps-, opb-reading time
  - speed up mps reader asking parameters only once

- Heuristics:
  - added parameters mincoveredrel and mincoveredabs to heur_undercover to only run if problem is sufficiently nonlinear
  - improved intdiving heuristic by activating backtracking to a different fixing value
  - heur_undercover treats indicator constraints as nonlinear and fixes the binary variable for linearization

Examples and applications
-------------------------

- new examples for scheduling and usage of the callable library with nonlinear problems
- the error messages are not handled via the message handler anymore; per default the error message a written to stderr

Interface changes
-----------------

- introduced basic inclusion and creation methods to simplify usage of the SCIP library
- allowed to start diving mode even if LP is not flushed, not solved, or not solved to optimality
- changed the message handler system within SCIP heavily such that it is thread save
- the resolve propagation methods for the constraint handler and propagator getting a new parameter called relaxedbd;
  explaining/resolving this relaxed bound is sufficient
- default integer comparer SCIPsortCompInt() (see pub_misc.h)

- LP interface:
  - SoPlex LPI supports setting of `SCIP_LPPAR_DUALFEASTOL` when using SoPlex version 1.6.0.5 and higher.

- Problem:
  - Forbid problem modifications in `SCIP_STAGE_{INIT,EXIT}PRESOLVE` (see pre-conditions for corresponding methods in scip.h).

- Miscellaneous:
  - New macro SCIPdebugPrintCons() to print constraint only if `SCIP_DEBUG` flag is set.
  - all objscip *.h file now use the default SCIP interface macros (this should avoid errors when changing the interface)

### New and changed callbacks

- Constraint Handler:
  - Added a propagation timing parameter `proptiming` to SCIP_DECL_CONSPROP(), giving the current timing at which
    this method is called (also to the corresponding c++ wrapper classes).
  - New optional callback methods in constraint handlers: `SCIP_DECL_CONSGETVARS` and `SCIP_DECL_CONSGETNVARS`.
    These callbacks, if implemented, should return an array of all variables and the number of all variables used
    by the given constraint, respectively. (This method might, e.g., be called by a presolver)

- NLP Solver Interface:
  - New NLPI callback SCIP_DECL_NLPISETMESSAGEHDLR() to set message handler in NLP solver interfaces.

- Propagator:
  - Added a propagation timing parameter `proptiming` to SCIP_DECL_PROPEXEC(), giving the current timing at which this method is
    called (also to the corresponding c++ wrapper classes).

- Plugin management:
  - added `basic` inclusion methods which have only fundamental data of the plug-ins as arguments; added setter functions
    for all non-fundamental callbacks of the plug-ins; the plug-in types with basic inclusion functions are:
    readers, constraint handlers, conflict handlers, presolvers, propagators, heuristics, separators, relaxation handlers,
    branching rules, node selectors and pricers; these methods should make the usage easier, sparing out optional callbacks and
    parameters: e.g., SCIPincludeConshdlrBasic();
  - To extend the basic functionalities, there are setter method to add
    optional callbacks. For example SCIPsetConshdlrParse(), SCIPsetPropCopy() or SCIPsetHeurInitsol().

- Constraint Handlers:
  - Added basic creation methods for all constraints types, e.g., SCIPcreateConsBasicLinear(); these methods should make the usage easier,
    sparing out optional callbacks and parameters.

### Deleted and changed API methods

- SCIPcomputeCoverUndercover() now has an additional parameter coverbd
- tcliqueMaxClique has an additional parameter to store the number of used branch-and-bound nodes
- the code in `src/dijkstra` and `src/xml` has been changed to (increasingly) conform to the SCIP coding style;
  all function (and variable) names have been changed (do not contain `_` anymore).
- renamed SCIPstairmap*Core() to SCIPstairmap*Stair()

- Conflict Analysis:
  - Added parameter `relaxedbds` to conflict handler callback method SCIP_DECL_CONFLICTEXEC(). This array contains
    bounds which are sufficient to create a valid conflict

- Constraint Handler:
  - Added a parameter `restart` to the SCIP_DECL_CONSEXITSOL() callback method, indicating whether this call was
    triggered by a restart.
  - Added a parameter `relaxedbd` to SCIP_DECL_CONSRESPROP() callback method. If explaining a given bound change
    (index), it is sufficient to explain the reason for reaching the `relaxedbd` value, see above
  - Removed parameters `isunbounded`, `isinfeasible` and `result` from SCIP_DECL_CONSINITPRE() and SCIP_DECL_CONSEXITPRE()
    callback methods. It is not allowed to determine unboundedness or infeasibility in these callbacks, anymore.
  - added a `SCIP_CONS*` parameter to SCIPcreateConsDisjunction() which can represent the linear relaxation of the whole
    disjunction constraint as a conjunction constraint, or `NULL`
  - remove problematic function cons_indicator:SCIPsetSlackVarIndicator()
  - Renamed SCIPgetCountedSparseSolutions() to SCIPgetCountedSparseSols() in cons_countsols.{c,h}.

- Counting:
  - Changed the counting system within SCIP heavily. New method for `SCIP_SPARSESOL` usage, SCIPsparseSolCreate(),
    SCIPsparseSolFree(), SCIPsparseSolGetVars(), SCIPsparseSolGetNVars(), SCIPsparseSolGetLbs(), SCIPsparseSolGetUbs()
    in (pub_)misc.{c,h}.

- Cuts and Separation:
  - removed `targetscip` parameter from SCIPconvertCutsToConss(), now this function can only convert cuts on one instance,
    otherwise use SCIPcopyCuts()
  - added `ncutsadded` parameter to SCIPcopyCuts() to be able to store the number of copied/converted cuts
  - New functions SCIPcreateEmptyRowCons(), SCIPcreateEmptyRowSepa(), SCIPcreateRowCons(), and SCIPcreateRowSepa() that allow
    to set the originating constraint handler or separator of a row respectively; this is, for instance, needed for statistics
    on the number of applied cuts. If rows are created outside a constraint handler or separator use SCIPcreateRowUnspec() and
    SCIPcreateEmptyRowUnspec(). The use of SCIPcreateEmptyRow() and SCIPcreateRow() is deprecated.
  - New functions SCIProwGetOrigintype(), SCIProwGetOriginCons(), and SCIProwGetOriginSepa() to obtain the originator
    that created a row.

- LP:
  - new parameter numerics/lpfeastol for primal feasibility tolerance used in LP solver
  - SCIPcomputeLPRelIntPoint() takes two new arguments giving a time and iteration limit
  - SCIPcolGetStrongbranchLPAge(), SCIPgetVarStrongbranchLPAge(), SCIPgetNLPs(), SCIPgetNPrimalLPs(), SCIPgetNDualLPs(),
    SCIPgetNBarrierLPs(), SCIPgetNResolveLPs(), SCIPgetNPrimalResolveLPs(), SCIPgetNDualResolveLPs(), SCIPgetNNodeLPs(),
    SCIPgetNNodeInitLPs(), SCIPgetNDivingLPs(), SCIPgetNStrongbranchs(), SCIPgetNRootStrongbranchs() now return a longint
    instead of an integer

- Message Handler and Printing:
  - New callback method SCIP_DECL_MESSAGEHDLRFREE() which is called when the message handler is freed.
  - The old callback method SCIP_DECL_MESSAGEERROR() was replaced by the callback method SCIP_DECL_ERRORPRINTING().
  - the follwing methods additionally need the SCIP pointer as parameter to make the output thread save:
    SCIPprintVersion(), SCIPsetMessagehdlr(), SCIPgetMessagehdlr() and SCIPwarningMessage()
  - the error printing method can be replaced using the method SCIPmessageSetErrorPrinting(); the default error message
    printing can be recoverd via SCIPmessageSetErrorPrintingDefault() (see pub_message.h)
  - Changed the message handler system within SCIP heavily such that it is thread-safe. SCIPcreateMessagehdlr() in
    scip.{c,h} was replaced by SCIPmessagehdlrCreate() in pub_message.h/message.c with a changed parameter list;
    see pub_message.h and type_message.h.
  - removed method SCIPcreateMesshdlr(), please use SCIPmessagehdlrCreate() (see pub_message.c)
  - removed method SCIPfreeMesshdlr(), please use SCIPmessagehdlrRelease() (see pub_message.c)
  - Error messages (SCIPerrorMessage()) are not handled via the message handler anymore; per default the error
    message is written to stderr.
  - the following methods need an additional message handler: SCIPdispLongint(), SCIPdispInt(), SCIPdispTime(), all message
    handler methods (see pub_message.h), SCIPhashtablePrintStatistics(), SCIPhashmapPrintStatistics(), SCIPlpiCreate()
  - SCIPprintCons() does not print termination symbol `;\n` anymore; if wanted, use SCIPinfoMessage() to print `;\n` manually
  - remove SCIPcolPrint() and SCIProwPrint(), please use SCIPprintCol() SCIPprintRow() see scip.h
  - method SCIPprintError() does not need the file stream anymore. The error is written via the error message callback.

- Nonlinear expressions, relaxation, and solver interface:
  - Method SCIPexprtreeRemoveFixedVars() is not public anymore.
  - Renamed SCIPmarkNonlinearitiesPresent() to SCIPenableNLP()
  - Renamed SCIPhasNonlinearitiesPresent() to SCIPisNLPEnabled().
  - removed SCIPmarkContinuousNonlinearitiesPresent(),
    renamed SCIPhasContinuousNonlinearitiesPresent() to SCIPhasNLPContinuousNonlinearity() and allow call only during
    initsolve and solve,

- Parameters:
  - Replaced SCIPparamSet*() by SCIPchg*Param()
    + replaced SCIPparamSetBool() by SCIPchgBoolParam()
    + replaced SCIPparamSetInt() by SCIPchgIntParam()
    + replaced SCIPparamSetLongint() by SCIPchgLongintParam()
    + replaced SCIPparamSetReal() by SCIPchgRealParam()
    + replaced SCIPparamSetChar() by SCIPchgCharParam()
    + replaced SCIPparamSetString() by SCIPchgStringParam()

- Presolving:
  - Removed parameters `isunbounded`, `isinfeasible` and `result` from SCIP_DECL_PRESOLINITPRE() and
    SCIP_DECL_PRESOLSEXITPRE(). It is not allowed to determine unboundedness or infeasibility in these callbacks, anymore.

- Propagator:
  - changed parameters of function SCIPpropagateCutoffboundVar() in prop_pseudoobj.{c,h}
  - Added a parameter `restart` to SCIP_DECL_PROPEXITSOL() callback method, indicating whether this call was triggered
    by a restart.
  - Added a parameter `relaxedbd` to SCIP_DECL_PROPRESPROP() callback method. If explaining a given bound change
    (index), it is sufficient to explain the reason for reaching the `relaxedbd` value.
  - Removed parameters `isunbounded`, `isinfeasible` and `result` from SCIP_DECL_PROPINITPRE() and
    SCIP_DECL_PROPEXITPRE() callback methods. It is not allowed to determined unboundedness or infeasibility in
    these callbacks, anymore.

- Sort and Copy:
  - The methods SCIPsortedvecInsert*() have an additional parameter which can be used to receive the position where
    the new element was inserted, if this is not of interest a `NULL` pointer can be given
  - new parameter in SCIPcopyPlugins() to indicate whether the message handler from the source SCIP should be passed to the
    target SCIP (only the pointer is copied and the usage counter of the message handler is increased)
  - New parameter in SCIPcopy() to indicate whether the message handler from the source SCIP
    should be passed to the target SCIP (only the pointer is copied and the usage counter of the message handler is
    increased). In multi theaded enviroment this parameter needs to be set to FALSE.

- Variable usage:
  - rename SCIPvarGetBestBound() to SCIPvarGetBestBoundLocal()
  - rename SCIPvarGetWorstBound() to SCIPvarGetWorstBoundLocal()
  - Method SCIPvarGetProbvarSum() is not public anymore, use SCIPgetProbvarSum() instead.
  - Replaced method SCIPvarGetRootRedcost() by SCIPvarGetBestRootRedcost().

### New API functions

- setup timer to all plugins and therefore SCIP<plugin-type>GetSetupTime() methods in all pub_plugin-type.h to ask
  for this time (, e.g. SCIPeventhdlrGetSetupTime() in pub_event.h)
- new GML(Graph Modeling Language) methods SCIPgmlWriteOpening(), SCIPgmlWriteCosing(), SCIPgmlWriteArc(), SCIPgmlWriteEdge(),
  SCIPgmlWriteNode() that write to a given GML file
- new LPI method SCIPlpiGetObjsen() to query objective sense
- SCIPpermuteIntArray() in pub_misc.h and misc.c for permuting an integer array
- SCIPcalcBinomCoef() in pub_misc.h and misc.c which calculates a binomial coefficient up to 33 over 16
- SCIPheurPassSolAddSol() in heur_trysol.c; solution which are passed via this method are just without any feasibility check
- SCIPgetGlobalPseudoObjval() which returns the global pseudo objective value which is all variables
  set to their best (w.r.t. the objective function) global bound
- SCIPhashGetKeyStandard() which returns the element itself as the key, SCIPhashKeyEqPtr(),
  SCIPhashKeyValPtr() which do the hash-comparison/-conversion on a pointer in pub_misc.h
- SCIPhashtableClear() which removes all elements of a hash table
- SCIPisUpdateUnreliable() to check whether an iteratively updated value should be recomputed from scratch
  (e.g., for activities; uses new parameter `misc/num_recompfac`)
- SCIPisHugeValue() to check whether a value is huge and should be handled separately from other values
  (e.g., in activity computations) and SCIPgetHugeValue() to get the smallest value counting as huge
- SCIPfixParam() and SCIPunfixParam() to fix and unfix a parameter, respectively;
  the fixing status of a parameter can be requested by SCIPparamIsFixed();
- SCIPsetBasePointClosecuts() to set the base point for close cut separation
- SCIPchgCutoffboundDive() to change the cutoffbound in diving mode
- SCIPupdateCutoffbound() which can be used to pass a cutoff bound

- Presolving:
  - SCIPpropIsPresolDelayed() which return if a propagator is delay during presolving
  - Added method SCIPisPresolveFinished() which returns whether the presolving process would be stopped after the
    current presolving round, given no further reductions will be found, can be used to ensure that a presolver is called very late

- Memory:
  - added forgotten implementation of SCIPfreeMemorySize(), SCIPfreeMemorySizeNull() in scip.h and BMSfreeMemorySize(),
    BMSfreeMemorySizeNull() in memory.h
  - SCIPmemccpy() in pub_misc.h and misc.c which copies either a specified number of charcters of a source
    string to a destination string or until it hits a stoping character
  - BMSmoveMemory(), BMSmoveMemoryArray(), BMSmoveMemorySize() and corresponding  BMSmoveMemory_call() in
    memory.{h,c} too move memory elements

- Conflict Analysis:
  - SCIPisConflictAnalysisApplicable() which return FALSE is the conflict will not runs; can be used
    to avoid unnecessary initialization of the conflict analysis
  - SCIPaddConflictRelaxedLb(), SCIPaddConflictRelaxedUb() and SCIPaddConflictRelaxedBd(); these methods
    can be used to give for a bound change which is part of an explanation a relaxed bound; this means the relaxed bound
    is already efficient to be part of a valid explanation
  - SCIPisConflictVarUsed() returns TRUE if the given bound change is already part of the conflict set;
    that is the bound change is redundant;
  - SCIPgetConflictVarLb() and SCIPgetConflictVarUb() returning the lower/upper bound of the given
    variable within the current active conflict set

- Variable usage:
  - SCIPvarsGetProbvar() in pub_var.h and var.c, which returns for a given array of variables the active, fixed
    or multiaggregated representation
  - SCIPgetActiveVars() in scip.{h,c}, which returns for a given array of variables the active counterparts
  - SCIPgetNObjVars() which returns the number of variables which have a non-zero objective coefficient
  - SCIPenableVarHistory() and SCIPdisableVarHistory() which can be used to turn off and on the collection
    of variables statistics which is used for example for branching
  - SCIPbranchVarHole() which branches a variable w.r.t. a given domain hole
  - SCIPvarGetAggregatedObj() which computes for a (not active) variable the corresponding objective value
  - SCIPsolIsOriginal() that returns whether a solution is defined on the original variables
  - SCIPgetVarImplRedcost() which returns the implied reduced costs
  - SCIPvarGetBestRootSol(), SCIPvarGetBestRootRedcost(), SCIPvarGetBestRootLPObjval() which return the best
    combination for a variable w.r.t. root solution value, root LP objective value and root reduced cost
  - SCIPhaveVarsCommonClique() in scip.{h,c}, to check for common clique information on two given variables
  - added basic creation methods SCIPcreateVarBasic() and SCIPcreateProbBasic() and setter functions for
    non-fundamental callbacks of variables and problems.
  - added new methods SCIPvarGetBestBoundGlobal() and SCIPvarGetWorstBoundGlobal().

- Constraint Handler:
  - added public wrapper functions for calling constraint handler callback methods for a single constraint:
    SCIPactiveCons(), SCIPdeactiveCons(), SCIPinitlpCons(), SCIPsepalpCons(), SCIPsepasolCons(), SCIPpropCons(),
    SCIPrespropCons(), SCIPenfopsCons(), SCIPenfolpCons()
  - added basic creation methods for all constraint handlers
  - SCIPchgCapacityKnapsack() which can be used to change the capacity of a knapsack constraint
  - SCIPconsIsAdded() which returns whether a constraint was already to a SCIP instance
  - SCIPconshdlrGetNCutsApplied() in pub_cons.h to get the number of cuts applied to the lp
  - SCIPconshdlrIncNAppliedCuts() in cons.h to increase the number of applied cuts (used by sepastore.c)
  - SCIPchgVarName() and SCIPchgConsName() which can be used to change name of variables and
    constraints in problem creation stage
  - New methods SCIPgetConsVars() and SCIPgetConsNVars() which return for a given constraint the involved variables and
    the number of variables if the corresponding constraint supports this (optional) callbacks
    (corresponding callbacks need to be implemented, see above)

- Message Handler:
  - SCIPmessagehdlrCapture() which captures a given message handler (increases number of uses)
  - SCIPmessagehdlrRelease() which releases and possibly frees a given message handler (decreases number of uses)
  - SCIPsetMessagehdlrLogfile() which can be used to write into a log file
  - SCIPsetMessagehdlrQuiet() which can be used to turn the screen output on and off

### Command line interface

- in the interactive shell, parameters can be fixed and unfixed with `fix` (instead of `set`), e.g., `fix heuristics rens freq TRUE`;
- new shell command `change minuc` to minimize the number of unsatisfied constraints

### Interfaces to external software

- beta-version of a MATLAB interface can be found under interfaces/matlab
- beta-version of a AMPL interface can be found under interfaces/ampl

### Changed parameters

- `branching/fullstrong/reevalage` changed from an integer to a longint parameter

- Removed parameters:
  - `separating/closecuts/separootonly`
  - `constraints/quadratic/defaultbound`
  - `separating/cgmip/nodelimit`

### New parameters

- `constraints/%s/timingmask` for changing the timingmask for calling the propagtion method of all constraint plugins
- `constraints/and/dualpresolving` by default set to TRUE, enabling dual-presolving on and-constraints
- `constraints/indicator/{sepacouplingcuts,sepacouplinglocal}` to enable separation of (local) cuts
- `constraints/indicator/{maxsepacuts,maxsepacutsroot}` to restrict the number of separated cuts
- `constraints/indicator/dualreductions` to enable dual presolving/propagation steps
- `constraints/setppc/cliquelifting`, `constraints/setppc/addvariablesascliques`,
  `constraints/setppc/cliqueshrinking`, first for enabling/disabling the clique lifting algorithm in cons_setppc.c,
  second parameter is for trying to create extra clique constraints in lifting algorithm, third parameter is for trying
  to decrease the number of variable in a clique constraint in the lifting algorithm
- `limits/totalnodes` that allows to stop at the correct node if a restart occured; therefore the new
  `SCIP_STATUS_TOTALNODELIMIT` is added
- `lp/{rootiterlim,iterlim}` to set a limit on the LP iterations spend in the initial root LP and each
  LP resolve, respectively
- `misc/transorigsols` by default set to TRUE, that switches whether SCIP tries to transfer original
  solutions into the transformed space (in initsol and if a heuristic adds an original solution during solving)
- `numerics/hugeval` that defines the smalles value counting as huge (see new method SCIPisHugeValue())
- `numerics/recompfac` which denotes the factor, by which the absolute of an iteratively updated value has
  to be decreased in order to recompute the value from scratch
- `presolving/convertinttobin/maxdomainsize` by default is set to `SCIP_LONGINT_MAX`, which deternmines
  the domainsize for which integers are converted to their binary representation
- `presolving/convertinttobin/onlypoweroftwo` by default is set to FALSE, that parameter allows you to
  only convert integer variables with a domainsize of 2^p-1 to their binary representation
- `presolving/convertinttobin/samelocksinbothdirections` by default is set to FALSE, that parameter allows
  you to convert only integer variables to their binary representation, which have the same amount of up- and downlocks
- `presolving/gateextraction/sorting` by default is set to 1, that parameter determines if you want to try
  to extract big-gates(-1) or small-gates(1) at first by ordering bigger/smaller logicor constraint up front, or use
  them as they are (0)
- `presolving/gateextraction/onlysetpart` by default is set to FALSE, that parameter allows you to
  only extract set-partitioning and no and-constraints
- `presolving/gateextraction/searchequations` by default is set to TRUE, that parameter allows you to
  search for logicor constraints and set-packing/-partitioning constraints with same variables
- `propagating/%s/timingmask` for changing the timingmask for calling the propagtion method of all propagator plugins
- `propagating/probing/maxdepth` to set the maximal depth until the probing propagation is executed
- `reading/cnfreader/useobj` to state whether an artificial objective, depending on the number of clauses
  a variable appears in, should be used, by default set to FALSE, old default behavior of reader corresponds to TRUE
- `separating/cgmip/{minnodelimit,maxnodelimit}` to determine node limit.
- `separating/closecuts/maxlpiterfactor` for iteration limit in relative interior point computation
- `separating/oddcycle/maxunsucessfull` to automatically turn off separation
- `oncepernode` in Rounding and Simple Rounding heuristic

### Data structures

- new data structure for binary trees (`SCIP_BT` and `SCIP_BTNODE` in pub_misc.h)
- renamed data structure `SCIP_STAIRMAP` to `SCIP_PROFILE`
- added new stages `SCIP_STAGE_INITPRESOLVE`, `SCIP_STAGE_EXITPRESOLVE` and `SCIP_STAGE_FREE`; renamed `SCIP_STAGE_FREESOLVE`
  to `SCIP_STAGE_EXITSOLVE`
- Changed the counting system within SCIP heavily. `SPARSESOLUTION` was renamed to `SCIP_SPARSESOL` and moved
  from cons_countsols.h to struct_misc.h

Testing
-------

- the check script now recognizes MIQCP and MINLP instances
- make test now also checks instances in wbo, cnf, osil and fzn format
- renamed parameter SCRDIR of `make testgams` to CLIENTTMPDIR and changed its default to `/tmp`

Build system
------------

### Makefile

- CppAD source code is now distributed with SCIP (`src/cppad`), so that `lib/cppad` is not used anymore;
  the default for EXPRINT has changed from none to cppad

Fixed bugs
----------

- fixed bug with strong branching with the LP status for conflict analysis
- fixed bug w.r.t. adding a value to the objective offset of the transformed problem
- fixed wrong assert in feasibility pump stage 3
- fixed bug in solve.c, applied bounding for the initial lp was only done if root-lp-solution was valid but another
  solution could also have been added
- primal solutions with infinite objective value are now automatically discarded
- all plugins that solve sub-SCIPs now do not stop the whole solution process if there has been an error
- fixed bug in cip reader, wrong use of SCIPstrtok()

- Variables:
  - fixed bug in shiftandpropagate w.r.t. SCIPconstructLP() which can have the side effect that variables are created
  - method SCIPvarGetProbvarSum() (and thus also SCIPgetProbvarSum()) returns +/-infinity if the variable resolves to a
    variable fixed to +/-infinity (depending on the sign of the scalar) but does not multiply with the scalar, anymore
  - better handling of infinite solution values for aggregated and negated variables
  - fixed bug that disabled multi-aggregation of two integer or implicit integer variables
  - fixed bug in sol.c with requesting values of transformed variables in original solution; previously this had only
    been handled in SCIPgetSolVal(), now the handling has been moved to SCIPsolGetVal()
  - fixed several bugs writing an mps file in the reader_mps.c, e.g. writing fixed variables which are not (yet) removed
    and writing integer variables even with an objective value of 0, if they only exist in non-linear constraints

- Separation:
  - fixed minor bugs with respect to counting generated and lifted cuts in sepa_oddcycle
  - fixed bug in sepa_clique.c, could not handle only empty cliques, that were not removed

- Heuristics:
  - fixed potential bugs in shiftandpropagate heuristic concerning the transformation update of a variable with free status
  - fixed bug in heur_zirounding with computation of up/downslacks
  - fixed bug in mutation heuristic with unnecessary aborts due to a wrong memory limit
  - fixed potential bug in fix-and-infer heuristic with variables being fixed to infinite value
  - fixed bug in diving heuristics with variables being fixed to values outside their domain
  - fixed bug in simple rounding heuristic with column generation for variables with strictly positive lower bound
  - made Octane heuristic numerically more stable to avoid asserts being caused by cancellation
  - fixed bug in mutation heuristic with variables being fixed to infinite values
  - do not run heur_shiftandpropagate if there is no LP

- LP Interface:
  - fixed bug in Cplex LPI: after running simplex, solisbasic flag was always true, which might be wrong if Cplex hit a
    time limit
  - fixed bug in SCIP probing mode with cleared LPI state but solved LP
  - fixed assert with `LPI=none` (need to count rows/cols in lpi_none)
  - fixed bug in SoPlex LPI where objective sense was not correct after reading LP from file in SCIPlpiReadLP()

- Constraints:
  - fixed bug in scip.c adding a constraint in SCIPgetConsCopy() to the constraint hashmap
  - fixed bug in cons_linear w.r.t recalculation of unreliable activities
  - fixed bug in cons_linear concerning huge activity values: besides infinite contributions, we now also treat huge
    contributions separately, count their occurences in a constraint and provide a relaxed activity value
  - fixed bug in cons_xor.c parsing a constraint
  - fixed count of propagations in cons_indicator and only try to propagate if variables are not yet fixed
  - fixed some bugs in cons_disjunction.c (wrong assert, forgotten deletion of constraint, wrong SCIPreleaseCons() call)

Miscellaneous
-------------

- first release of GCG, a generic branch-cut-and-price solver built on top of SCIP
- first release of UG, a framework for solving mixed integer programs, mixed integer
  nonlinear programs and constraint integer programs in parallel
- new SCIP T-shirts
- renamed ZIB Optimization Suite to SCIP Optimization Suite

@page RN21 Release notes for SCIP 2.1

@section RN212 SCIP 2.1.2
*************************

Performance improvements
------------------------

- fixed performance issue in debug mode, where SCIPvarGetLPSol_rec() calculated a value to often, which in the end lead
  to exponential growth in running time
- force cuts from linearizations of convex constraint in NLP relax solution into LP, thus allowing faster proving of
  optimality for convex NLPs

Fixed bugs
----------

- fixed bug in varAddTransitiveImplic() in var.c, when adding implications on special aggregated, namely negated, variables
- fixed issue if a primal solution leads to a cutoff of the current focus node
- fix compilation issues with zlib 1.2.6
- fixed bug in SCIPsolveKnapsackExactly(), trying to allocate too much memory which led to an overflow and later to a segmentation fault
- fixed bug in sepa_rapidlearning, carrying on the optimization process, when already solved

- Heuristics:
  - fixed bug in heur_undercover.c, where a variable with fixed bounds but not of status `SCIP_VARSTATUS_FIXED` was wrongly handled
  - fixed bug in heur_oneopt.c which forgot to check LP rows if local rows are present

- Constraints:
  - fixed bug in SCIPsolveKnapsackExactly()
  - fixed bug in cons_quadratic where bounds on activity of quadratic term were not always invalidated when quadratic variables were removed
  - fixed bug in cons.c, where after a restart the arrays for all initial constraints were corrected in the initsol process
    instead of the initpre process, this was to late because you might change the status in presolving which lead to an assert()
  - fixed bug in NLP representation of abspower constraints handling (x+a)^2 with nonzero a
  - fixed bug parsing an and-constraint in cip format
  - fixed bug in cons_setppc, did not handle new constraints with inactive variables
  - fixed bug in cons_xor.c which did not copy the artificial integer variable (used for the lp relaxation)

@section RN211 SCIP 2.1.1
*************************

Features
--------

- the pseudo objective propagator can be forced to propagate if active pricers are present; this can be done
  if for all (known or unknown) variables follows that: they have positive (negative) objective coefficient
  and the global lower (upper) bound is zero.

Performance improvements
------------------------

- improvements in undercover heuristic
- improve SCIPintervalSolveBivariateQuadExpressionAllScalar() for ax=0 case if x has 0 in the interval for the linear coef.
- better domain propagation for quadratic constraints that consist of `non-overlapping` bilinear terms only
- ensure that a fixing of a variable in an abspower constraint is propagated to a fixing of the other variable
- improvements in undercover heuristic, e.g., bound disjunction constraints are considered when setting up the covering problem

Interface changes
-----------------

### Changed parameters

- changed parameter `propagating/pseudoobj/maxcands` to `propagating/pseudoobj/minuseless` (see prop_pseudoobj.c)
  due to revision of the pseudo objective propagator

### New parameters

- added parameters `heuristics/undercover/coverbd` and `heuristics/undercover/fixingorder`

Fixed bugs
----------

- fixed numeric issue in aggregations
- fixed pseudo cost computation
- fixed bug with setting type of slack variables to be implicitly integral
- fixed bug when copying problem data in c++ case returned with the result `SCIP_DIDNOTRUN`
- fixed computation of counter which state the changes since the last call of a presolver
- fixed handling of unbounded solutions, including double-checking their feasibility and that the primal ray is a
  valid unboundedness proof and reoptimizing the LP with modified settings if the solution is not feasible
- fixed compilation issues with negate() function in intervalarith.c on exotic platforms
- fixed bug in SCIPsortedvecDelPos...() templates
- pseudo objective propagator does not propagate it active pricers are present
- fixed bug in heur_shiftandpropagate.c concerning the treatment of unbounded variables
- workaround for trying to add variable bounds with to small coefficients

- Reading and Writing:
  - gams writer now also substitutes $-sign from variable/equation names
  - fixed bug in reader_mps.c: INTEND marker is now also written, if COLUMNS section ends with non-continous variables
  - fixed bug in flatzinc reader w.r.t. boolean expressions

- Constraints:
  - fixed constraint flags evaluation within the ZIMPL reader (reader_zpl.c)
  - fixed bug in SCIPmakeIndicatorFeasible() in cons_indicator.c
  - fixed bug with conflict clause modification in cons_indicator
  - fixed bug in cons_bounddisjunction with uninitialized return values
  - fixed bug in cons_orbitope with calling conflict analysis
  - fixed bug in nlpi_oracle w.r.t. changing linear coefs in a NLP constraint

@section RN210 SCIP 2.1.0
*************************

Features
--------

- New original solution storage capability, which allows transfering solutions between SCIP runs
- SCIP-CPX is now threadsafe
- comparison of solutions now also works for original solutions
- can now compute the relative interior point of the current LP
- interval arithmetics for power, log, exp, bivariate quadratic expressions should be rounding safe now
- LP iterations in resolving calls can now be limited w.r.t. the average number of LP iterations in previous calls
  (after the root node); this is currently only done for the initial LP solve at a node and the corresponding parameter
  resolveiterfac is set to -1 (no limit) per default
- it is now possible in `SCIP_STAGE_TRANSFORMED` to call SCIPaddVarLocks() (i.e. to lock variables in initialization methods)
- changed computation of optimality gap which is now done in the same way as described in the MIPLIB 2010 paper: the gap
  is 0, if primalbound (pb) and dualbound (db) are equal (within tolerances), it is infinity if pb and db have opposite
  signs and (this changed), if both have the same sign, the difference between pb and db is devided by the minimum of
  the absolute values of pb and db (instead of always the dual bound)
- functionality to use the bound flipping ratio test of SoPlex is available (requires at least version 1.5.0.7)
- there exists now a solution candidate store for the original problem; during transformation these solutions are tried;
  during free the transformed problem the best feasible solution of the transformed problem are copied to the solution
  candidate store of the original problem; this useful if you solve several problems iteratively, solutions get now
  carried over automatically.
- reworked concept of lazy bounds: they can now also be used for problems where constraints and objective together
  ensure the bounds; to allow this also for diving heuristics that might change the objective and thus destroy this
  property, lazy bounds are explicitly put into the LP during diving and removed afterwards
- `SCIP_HASHMAP` now works also without block memory
- The variable deletion event is now a variable specific event and not global, anymore.
- All timing flags are now defined type_timing.h.
- all C template files are now called <plugintype>_xyz.{c,h} instead of <plugintype>_xxx.{c,h}

- Separators and Cuts:
  - reorganized computation of scores in cut filtering: instead of the computation at the time of addition, scores are now
    only computed w.r.t. the current LP solution and when cut filtering is performed; one can now fill the cut storage
    with cuts that were separated for different solutions
  - New separator for close cuts and a new function to compute relative interior points of the LP
  - added first version of sepa_closecuts.{c,h} to separate cuts w.r.t. a point that is closer to the integral polyhedron

- Constraints:
  - implement possibility to force a restart in cons_indicator if enough indicator variables have been fixed
  - the xor constraint handler can now parse its constraints
  - the bounddisjunction constraint handler can now parse its constraints
  - the knapsack, setppc and soc constraint handler can now parse their constraints
  - the varbound constraint handler can now parse its constraints
  - added beta version of variable deletion: for branch-and-price application, variables can now be completely deleted
    from the problem; variables that are deletable have to be marked with SCIPvarMarkDeletable(), constraint handlers can
    implement the new `SCIP_DECL_DELVARS` callback that should remove variables from the constraints; at the moment, only
    the linear, the setppc and the knapsack constraint handler support this callback; furthermore, when using this
    feature, all used plugins have to capture and release variables they store in their data, this is currently only done
    for the aforementioned constraint handlers as well as the and, the varbound and the logicor constraint handler; for
    more details about this feature, see the FAQ
  - added pseudoboolean constraint handler (cons_pseudoboolean.{c,h})
  - added first version of cons_disjunction.{c,h} which allows a disjunction of constraints
  - added constraint handler for (absolute) power constraints (cons_abspower.{c,h}) to handle equations like z = sign(x)abs(x)^n, n > 1

- Heuristics:
  - new heuristic vbounds which use the variables lower and upper bounds to fix variable and performs a neighborhood search
  - added vbound heuristic (heur_vbounds.{c,h})
  - added clique heuristic (heur_clique.{c,h})

- Reading and Writing:
  - added writing for wbo files
  - added writing for pip files (linear, quadratic, polynomial nonlinear, polynomial abspower, polynomial bivariate, and
    and constraints)
  - CIP format variable characters defined, e.g. `SCIP_VARTYPE_INTEGER_CHAR`
  - Improved support for wbo format for weighted PBO problems, IBM's xml-solution
    format and pip and zimpl format for polynomial mixed-integer programs
  - New reader for (standard) bounds on variables
  - Extended reader for CIP models to handle various new constraints, including all types of linear constraints
  - flatzinc reader is now capable to read cumulative constraints
  - changed opb(/wbo) reader which now creates pseudoboolean constraints instead of linear- and and-constraints, only a
    non-linear objective will create and-constraints inside the reader and while reading a wbo file the topcost constraint
    is created as well
  - added clock for determine the time for reading
  - added reader for variable bounds (reader_bnd.{c,h})
  - Removed method SCIPreadSol(); call solution reading via SCIPreadProb() which calls the solution reader for .sol files.

- Nonlinear:
  - Major extensions for nonlinear CIP, new option for n-ary branching on nonlinear variables (within pseudocost branching rule)
  - added BETA version of constraint handler for nonlinear constraints (cons_nonlinear.{c,h}) to handle nonlinear
    equations given by algebraic expressions using operands like addition, multiplication, power, exp, log, bivariate
    nonlinear constraints; currently no trigonometric functions
  - added BETA version of constraint handler for bivariate nonlinear constraints (cons_bivariate.{c,h}) to compute tight
    estimators for 1-convex and convex-concave bivariate nonlinear functions (given as expression tree)
  - the gams writer can now write nonlinear, abspower and bivariate constraints
  - Extended writer for GAMS and pip format to write more types of nonlinear constraints
  - the pip and zimpl reader now create nonlinear constraints for polynomials of degree > 2

- Presolving:
  - new dual presolving methods in cons_setppc and cons_logicor
  - new presolving step `removeConstraintsDueToNegCliques` in locigor constraint handler which updates logicor constraints
    to setppc constraints if a negated clique inside this constraint exist, by default is off
  - new presolving step in cons_knapsack (detectRedundantVars, deleteRedundantVars) which determines redundant variables
    in knapsack constraint with or without using clique information
  - cons_logicor is now able to replace all aggregated variables in presolving by there active or negation of an active
    variable counterpart
  - prop_pseudoobj is now working in presolving as well
  - implement presolving in exitpre() in cons_orbitope and cons_indicator

- Propagators:
  - added counter for number calls and timing for resolve propagation calls for constraint handler and propagators
  - Propagators are now also called in node presolving
  - the probing presolver presol_probing.{c.h} is now a propagator prop_probing.{c,h}, all corresponding parameters moved as well
  - the redcost separator sepa_redcost.{c.h} is now a propagator prop_redcost.{c,h}, all corresponding parameters moved as well
  - outsourced propAndSolve() method in solve.c which calls domain propagation and solving of the lp and relaxation

- Statistic:
  - solutions which are given by the user from the outside are now marked by `#` in the output
  - the `Solving Time` is now spitted into presolving, solving and reading time
  - Presolvers section has new column `AddCons` which states the number of added constraint
  - Constraints section has new column named #ResProp which show the number of resolve propagation calls of certain
    constraint handler
  - Constraint Timing section has a new column #ResProp which states the time spend in resolve propagation method of the
    constraint handler
  - improved output of propagators in display statistics
  - new section `Propagator Timing` which shows the time spend in different callbacks of the propagator
  - rearranged first two columns of Propagators section; #Propagate and #ResProp stating the number of call for
    propagation and resolve propagation; the Time column is moved into the new section Propagator Timings
  - Constraints section has new column named `MaxNumber` which the maximum number of active constraint of a certain
    constraint handler
  - added two columns `Time-0-It` and `Calls-0-It` in the LP section which states the number of LP call and time spend for
    solving LPs with zero iterations (only refactorization)
  - The display of statistics for presolvers, propagators, constraints and LP solving has changed.

Performance improvements
------------------------

- Reorganized filtering process of separation storage (allows adding cuts for different solutions)
- Improved presolving for various constraint handlers
- Improved propagation methods for variable bound constraints
- Improved performance for quadratic constraints
- performance improvements in prop_vbounds
- child selection rules now get also applied when the relaxation value is equal to the bound changed in branching
- added dual reduction to cons_cumulative.c
- for continuous variables, the pseudo costs update and the pscost branching rule now use the same strategies for
  updating the pseudo costs and estimating the improvement in the LP bound
- only perform probing if the variables are locked
- performance and memory consumption improvements in xmlparse.c
- Improved knapsack cover cuts
- avoid very long separation times of LEWIs in cons_knapsack for very large minimal covers
- used SCIPallocMemoryArray() instead of SCIPallocBlockMemoryArray() which leads to fewer memory consumption in
  getLiftingSequence() in cons_knapsack, also improved cache use bei using an extra array instead blockmemory chunks
- switched FASTMIP from 1 to 2 for CPLEX and changed default pricing rule back to steepest edge pricing instead of
  quickstart steepest edge pricing
- made sorting method more robust
- LNS heuristics now use SCIPcopy() by default
- considering inactive variables in undercover heuristic; limiting effort for solving covering problem
- if during probing mode the LP relaxation is solved from scratch, e.g., when calling the shiftandpropagate heuristic
  before root node solving, then we clear the resulting LP state, since it might be a bad starting basis for the next
  solve of the LP relaxation (controlled by new parameter `lp/clearinitialprobinglp`)
- included LP simplifier into SoPlex LP interface, applied when solving from scratch (lpi_spx.cpp)
- new presolving steps in varbound constraint handler, tightening bounds, coefficients, sides and pairwise presolving

Interface changes
-----------------

- Miscellaneous:
  - The emphasis setting types now distinguish between plugin-type specific parameter settings (default, aggressive, fast, off),
    which are changed by SCIPsetHeuristics/Presolving/Separating(), and global emphasis settings (default, cpsolver, easycip,
    feasibility, hardlp, optimality, counter), which can be set using SCIPsetEmphasis().

### New and changed callbacks

- added propagator timings `SCIP_PROPTIMING_BEFORELP`, `SCIP_PROPTIMING_DURINGLPLOOP` and `SCIP_PROPTIMING_AFTERLPLOOP` for
  all propagation callbacks (see propagators and constraint handlers) which lead to calling the propagation methods of a
  propagator before the lp is solved, during the lp loop and after the lp solving loop

- Conflict Analysis:
  - Added parameter `separate` to conflict handler callback method SCIP_DECL_CONFLICTEXEC() that defines whether the conflict
    constraint should be separated or not.

- Constraint Handler:
  - The new constraint handler callback SCIP_DECL_CONSDELVARS() is called after variables were marked for deletion.
    This method is optional and only of interest if you are using SCIP as a branch-and-price framework. That means,
    you are generating new variables during the search. If you are not doing that just define the function pointer
    to be `NULL`.
    If this method gets implemented you should iterate over all constraints of the constraint handler and delete all
    variables that were marked for deletion by SCIPdelVar().

- NLP Solver Interface:
  - The callbacks SCIP_DECL_NLPIGETSOLUTION() and SCIP_DECL_NLPISETINITIALGUESS() got new parameters to get/set values of
    dual variables.
  - The callback SCIP_DECL_NLPICOPY() now passes the block memory of the target SCIP as an additional parameter.

- Presolving:
  - New parameters `isunbounded` and `isinfeasible` for presolving initialization (SCIP_DECL_CONSINITPRE(),
    SCIP_DECL_PRESOLINITPRE(), SCIP_DECL_PROPINITPRE()) and presolving deinitialization (SCIP_DECL_CONSEXITPRE(),
    SCIP_DECL_PRESOLEXITPRE(), SCIP_DECL_PROPEXITPRE()) callbacks of presolvers,
    constraint handlers and propagators, telling the callback whether the problem was already declared to be
    unbounded or infeasible.  This allows to avoid expensive steps in these methods in case the problem is already
    solved, anyway.

    Note, that the C++ methods
    - scip::ObjConshdlr::scip_presol() corresponding to SCIP_DECL_CONSPRESOL()
    - scip::ObjConshdlr::scip_initpre() corresponding to  SCIP_DECL_CONSINITPRE()
    - scip::ObjPresol::scip_initpre() corresponding to SCIP_DECL_PRESOLINITPRE()
    - scip::ObjProp::scip_initpre() corresponding to SCIP_DECL_PROPINITPRE()
    - scip::ObjConshdlr::scip_exitpre() corresponding to SCIP_DECL_CONSEXITPRE()
    - scip::ObjPresol::scip_exitpre() corresponding to SCIP_DECL_PRESOLEXITPRE()
    -  scip::ObjProp::scip_exitpre() corresponding to  and SCIP_DECL_PROPEXITPRE()
    are virtual functions. That means, if you are not adding the new parameters, your code will still compile, but these methods are not executed.
  - Propagators are now also called in during presolving, this is supported by the new callback methods SCIP_DECL_PROPINITPRE(),
    SCIP_DECL_PROPEXITPRE(), and SCIP_DECL_PROPPRESOL().
  - The new parameters `nnewaddconss` and `naddconss` were added to the constraint handler callback method SCIP_DECL_CONSPRESOL()
    and the presolver callback method SCIP_DECL_PRESOLEXEC(). These parameters were also added to corresponding C++ wrapper
    class methods (scip_presol() in objconshdlr.h and scip_exec() in objpresol.h)

- Problem Data:
  - The callback SCIP_DECL_PROBCOPY() got a new parameter `global` to indicate whether the global problem or a local version is copied.

### Deleted and changed API methods

- implemented SCIPlpiGetPrimalRay() in SoPlex interface that has become available with SoPlex version 1.5.0.2
- allowed calling SCIPgetRowSolActivity() in `SCIP_STAGE_SOLVED`, since LP is still available
- various extensions and modifications for expressions and expression trees (too much to state here)
- The result value `SCIP_NEWROUND` has been added, it allows a separator/constraint handler to start a new separation round
  (without previous calls to other separators/conshdlrs).
- SCIPcalcNodeselPriority() got a new parameter `branchdir`, which defines the type of branching that was performed: upwards, downwards, or fixed.

- Constraint Handlers:
  - Method SCIPincludeQuadconsUpgrade() of quadratic constraint handler got new parameter `active` to indicate whether the upgrading method is active by default.
  - Method SCIPseparateRelaxedKnapsack() in knapsack constraint handler got new parameter `cutoff`, which is a pointer to store whether a cutoff was found.

- Nonlinear expressions, relaxation, and solver interface:
  - SCIPcreateNLPSol() now creates a `SCIP_SOL` that is linked to the solution of the current NLP relaxation
  - Various types and functions dealing with polynomial expressions have been renamed to use the proper terms `monomial` and
    `polynomial` in nonlinear expressions (nlpi/*expr*); results in many renamings of types, structs and methods.
  - The methods SCIPnlpGetObjective(), SCIPnlpGetSolVals(), and SCIPnlpGetVarSolVal() have been removed, use SCIPgetNLPObjval(),
    SCIPvarGetNLPSol() and SCIPcreateNLPSol() to retrieve NLP solution values instead.
    SCIPcreateNLPSol() now returns an error if NLP or NLP solution is not available
  - Removed methods SCIPmarkRequireNLP() and SCIPisNLPRequired(), because the NLP is now always constructed if nonlinearities
    are present.
  - SCIPgetNLP() has been removed and NLP-methods from pub_nlp.h have been moved to scip.h, which resulted in some renamings, too.
  - renamed SCIPexprtreeEvalSol() to SCIPevalExprtreeSol() and now located in scip.h.
  - renamed SCIPexprtreeEvalIntLocalBounds() to SCIPevalExprtreeLocalBounds() and now located in scip.h.
  - renamed SCIPexprtreeEvalIntGlobalBounds() to SCIPevalExprtreeGlobalBounds() and now located in scip.h.
  - The functions SCIPnlpiGetSolution() and SCIPnlpiSetInitialGuess() got additional arguments to get/set dual values.
  - The method SCIPgetNLPI() got a new parameter `nlpiproblem`, which is a pointer to store the NLP solver interface problem.

- Timing:
  - SCIPincludeProp() got additional parameters to set the timing mask of the propagator and the new callbacks and parameters
    related to calling the propagator in presolving.
  - SCIPincludeConshdlr() got additional parameters to set the variable deletion callback function and the timing mask for
    propagation.
  - removed parameters timelimit and memorylimit from SCIPapplyRens()
  - The parameters `timelimit` and `memorylimit` were removed from SCIPapplyRens().

- Problem Data:
  - The method SCIPcopyProb() got a new parameter `global` to indicate whether the global problem or a local version is copied.

- Writing and Parsing Constraints:
  - The methods SCIPwriteVarName(), SCIPwriteVarsList(), and SCIPwriteVarsLinearsum() got a new boolean parameter `type`
    that indicates whether the variable type should be written or not.
  - The methods SCIPparseVarName() and SCIPparseVarsList() got a new output parameter `endptr` that is filled with the position
    where the parsing stopped.
  - The method SCIPwriteVarsList() got additionally a new parameter `delimiter` that defines the character which is used for delimitation.

- Variables:
  - SCIPmarkDoNotMultaggrVar()/SCIPvarMarkDoNotMultaggr() now allow to mark negated and aggregated variables
  - SCIPgetVarCopy() got a new parameter `success` that will be FALSE if method is called after problem creation stage and no hash map is
    given or no image for the given variable is contained in the given hash map.
  - SCIPchgVarType() got an extra boolean parameter to store if infeasibility is recognized while upgrading a variable from continuous
    type to an integer type.
  - SCIPdelVar() got a new parameter `deleted`, which stores whether the variable was successfully marked to be deleted.

### New API functions

- information about the quality of the solution of an LP (currently the condition number of the basis matrix) can now be:
  + requested from the LPI (currently only available for CPLEX): methods SCIPlpiGetRealSolQuality() and
  + SCIPprintLPSolutionQuality() command display lpsolquality in interactive shell display column lpcond to show
  + estimate on condition number, if available
- SCIPround() and SCIPfeasRound() to round to nearest integer
- SCIPsortRealRealIntInt() and corresponding sorting/inserting/deleting methods in pub_misc.h and necessary defines in misc.c
- SCIPsortRealIntLong(), SCIPsortPtrPtrRealInt() and corresponding sorting/inserting/deleting methods in
  pub_misc.h and necessary defines in misc.c
- SCIPcomputeLPRelIntPoint() to compute relative interior point of the current LP
- SCIPstartSolvingTime() and SCIPstopSolvingTime() which can be used to start or stop the solving time clock
- SCIPstrToRealValue() and SCIPstrCopySection() in pub_misc.h; these methods can be used to convert a string
  into a `SCIP_Real` value and to copy a substring.
- SCIPgetBinvarRepresentatives() which gets binary variables that are equal to some given binary variables,
  and which are either active, fixed, or multi-aggregated, or the negated variables of active, fixed, or multi-aggregated variables
- SCIPhasPrimalRay() and SCIPgetPrimalRayVal() that return whether a primal ray is stored and which value a
  given variable has in the primal ray, respectively
- SCIPsetConsModifiable()
- SCIPsetParam() which is a generic parameter setter method, independent of the parameter type
- SCIPpropInitpre(), SCIPpropExitpre(), SCIPpropPresol() which initializes, exists and executes the presolving phase
- SCIProwGetAge() to access the age of a row (pub_lp.h/lp.c)
- SCIPsolGetOrigObj() in pub_sol.h which returns for a solution in the original problem space the objective value
- SCIPretransformSol() in scip.h that allows to retransform a solution to the original space
- SCIPlpiClearState() to LP interfaces for clearing basis information in the LP solver
- SCIPgetSubscipDepth() to access the depth of the current SCIP as a copied subproblem
- SCIPdebugAddSolVal() and SCIPdebugGetSolVal() to add/get values to/from a debug solution
- SCIPsepastoreRemoveInefficaciousCuts() to remove non-efficious cuts from the separation storage

- Nodes:
  - SCIPnodeGetParent() to get parent node of a node
  - SCIPnodesSharePath() in pub_tree.h that determines whether two nodes are on the same leaf-root path
  - SCIPnodesGetCommonAncestor() in pub_tree.h that finds the common ancestor node for two given nodes

- Read and Write:
  - SCIPgetReadingTime() which returns the time for reading in seconds
  - SCIPparseVarsLinearsum(), SCIPparseVarsPolynomial() and SCIPwriteVarsPolynomial() and for writing and
    parsing polynomials in constraint handler writing/parsing methods

- Memory:
  - SCIPcreateMesshdlrPThreads() and SCIPfreeMesshdlrPThreads() for allocating and deleting necessary memory
    for message handlers for parallel pthread version
  - SCIPallocClearMemoryArray() and BMSallocClearMemoryArray() for allocating cleared memory arrays in scip.h and memory.h

- Intervals:
  - SCIPintervalPowerScalarInverse() to solve an equation y = x^p for given bounds on y and scalar exponent p
  - SCIPintervalQuadBivar() to compute tight bounds on a bivariate quadratic form
  - SCIPintervalSolveBivariateQuadExpressionAllScalar() to compute tight bounds on the solutions of a bivariate quadratic equation

- Variables:
  - SCIPcomputeVarCurrent{L,U}b{Local,Global}() to compute local or global lower or upper bounds of a
    multiaggregated variable from the bounds of the aggregation variables
  - SCIPbranchVarValNary() for n-ary variable branching
  - SCIPgetNegatedVars() which returns all negated variables for a given array of variables, if the negated
    variables are not existing yet, they will be created
  - SCIPgetNTotalVars() that returns the total number of created vars, icluding variables that were deleted in the meantime
  - SCIPvarGetHashkey(), SCIPvarIsHashkeyEq(), SCIPvarGetHashkeyVal() in pub_var.h which can be used for `SCIP_HASHTABLE` of variables
  - SCIPvarGetNBdchgInfosLb() and SCIPvarGetNBdchgInfosUb() in pub_var.h returning the number of lower or upper bound changes on the active path
  - SCIPvarGetBdchgInfoLb() and SCIPvarGetBdchgInfoUb() returning the bound change information at the given position
  - SCIPvarMarkDeletable() to mark a variable to be deletable completely from the problem (for
    branch-and-price); can only be called before the variable is added to the problem
  - SCIPvarMarkNotDeletable() that marks a variable to be non-deleteable (used within SCIP for forbidding
    deletion of variables contained in solution, LP bases, (multi)aggregation, ...)
  - SCIPvarIsDeletable() that returns whether a variable is marked to be deletable (each variable is per default non-deletable)

- NLP:
  - SCIPgetNLPVarsNonlinearity() to get for each variable in the NLP the number of NLP rows in which this variable appears in a nonlinear way
  - SCIPnlrowGetDualsol(), SCIPgetNLPVarsLbDualsol(), SCIPgetNLPVarsUbDualsol() to retrieve dual values from an NLP solution
  - SCIPgetNLPFracVars() to get the fractional variables in an NLP solution

- Propagator:
  - SCIPpropSetPresolPriority() which changes the presolving priority of a given propagator
  - SCIPpropGetPresolPriority(), SCIPpropGetPresolTime(), SCIPpropWasPresolDelayed(), SCIPpropGetNFixedVars(),
    SCIPpropGetNAggrVars(), SCIPpropGetNChgVarTypes(), SCIPpropGetNChgBds(), SCIPpropGetNAddHoles(), SCIPpropGetNDelConss(),
    SCIPpropGetNAddConss(), SCIPpropGetNUpgdConss(), SCIPpropGetNChgCoefs(), SCIPpropGetNChgSides(), SCIPpropGetTimingmask(),
    SCIPpropDoesPresolve() which return corresponding presolving information
  - SCIPpropGetNRespropCalls() and SCIPconshdlrGetNRespropCalls() which return the number of times a
    propagator or a constraint handler was called for resolving a propagation
  - SCIPpropGetRespropTime() and SCIPconshdlrGetRespropTime() which return time spent for resolving a
    propagation within a propagator or a constraint handler
  - SCIPcheckCumulativeCondition(), SCIPpropCumulativeCondition() and SCIPrespropCumulativeCondition() in
    cons_cumulative.h; these methods can be used to check, propagate, or resolve the propagation of a cumulative condition
  - SCIPpropagateCutoffboundVar() in prop_pseudoobj.h which can be used to propagate the cutoff bound for the given variables

- Constraints:
  - added to linear constraint handler SCIPsetUpgradeConsLinear(), which (de-)activates the possibility to
    upgrade a linear constraint to a specialized linear constraint (e.g. knapsack)
  - SCIPconvertCutsToConss() and SCIPcopyCuts() to scip.{c,h} for copying cuts to linear constraints
  - SCIPaddCoefLogicor() to add a variable to a logic or constraint
  - SCIPfindOrigCons() which return a original constraint with the given name or `NULL`
  - SCIPconshdlrGetNAddConss() which returns the number of added constraints during presolving by a given constraint handler
  - SCIPpresolGetNAddConss() which returns the number of added constraints during presolving by a given presolver

### Command line interface

- New funtionalities in the interactive shell (modify current CIP instance, write NLP relaxation)
- added dialog `write nlp` to write current NLP relaxation to a file
- new dialog `change freetransproblem` to free transformed problem in the interactive shell before changing the problem
- it is possible to change bounds of a variable in the interactive shell
- it is possible to add a constraint to a problem in the interactive shell

### Interfaces to external software

- Improved SOPLEX interface (LP simplifier)
- Improved CPLEX interface, including measures for numerical stability

### Changed parameters

- change default value of parameter `nodeselection/restartdfs/selectbestfreq` 100
- moved parameters for pseudoboolean constraints from opb-reader to pseudoboolean constraint handler
- changed possible parameter values of `branching/pscost/strategy` from `bri` to `cdsu`: default is now `u`, i.e., to
  estimate the LP gain by a branching for external branching candidates (esp. continuous variables) the same way as
  their pseudo costs are updated
- added possible value `d` for `constraints/soc/nlpform` to choose a convex division form for SOC constraint
  representation in NLP
- renamed parameter `constraints/quadratic/linearizenlpsol` to `constraints/quadratic/linearizeheursol` and do
  linearizations in every solution found by some heuristic
- renamed parameter `constraints/quadratic/mincutefficacyenfo` to `constraints/quadratic/mincutefficacyenfofac` and
  interpret it as a factor of the feasibility tolerance
- removed fastmip setting 2, which means the dualsolution would not be calculated but because SCIP always asks for the
  dual solution, the lp would be reoptimized to calculate them; so it had no real effect
- all parameters in cons_indicator and cons_sos1 have been converted to lower case!
- changed default value of parameter `separating/gomory/maxroundsroot` to 10
- changed default value of parameter `separating/gomory/maxsepacutsroot` to 50
- removed parameter `heuristics/subnlp/nlpsolver`, use `nlp/solver` instead

### New parameters

- `branching/delaypscostupdate` to delay the update of pseudo costs for continuous variables behind the separation round: default is TRUE
- `branching/lpgainnormalize` to set the strategy how the LP gain for a continuous variable is normalized when updating the
  variables pseudocosts: default is to divide LP gain by reduction of variable's domain in sibling node
- `branching/pscost/nchildren` and `branching/pscost/nary*` to enable and customize n-ary branching on
  external branching candidates (e.g., in spatial branching for MINLP)
- `conflict/bounddisjunction/continuousfrac` which defines the maximum percantage of continuous variables
  within a conflict create by the bounddisjunction conflict handler
- `conflict/separate` which enables or disables the separation of conflict constraints
- `constraints/{nonlinear,quadratic,soc,abspower}/sepanlpmincont` to specify minimal required fraction
  of continuous variables in problem to enable linearization of convex constraints in NLP relaxation solution in root
- `constraints/indicator/forcerestart` and `constraints/indicator/restartfrac` to control forced restart in cons_indicator
- `constraints/indicator/generatebilinear` to generate bilinear (quadratic) constraints instead of indicator constraints
- `constraints/indicator/maxconditionaltlp` to enable a quality check for the solution of the alternative LP
- `constraints/indicator/removeindicators` to remove indicator constraints if corresponding vub has been added
- `constraints/linear/nmincomparisons` and `constraints/linear/mingainpernmincomparisons` to influence
  stopping criterium for pairwise comparison of linear constraints
- `constraints/pseudoboolean/decompose`, for pseudoboolean constraints to transform pseudoboolean constraints into linear- and and-constraints
- `constraints/quadratic/binreforminitial` to indicate whether linear (non-varbound) constraints added due to reformulation of products with
  binary variables in a quadratic constraints should be initial (if the quadratic constraint is initial), default is FALSE
- `constraints/quadratic/checkfactorable` to disable check for factorable quadratic functions (xAx = (ax+b)*(cx+d)) in quadratic constraints
  and not to use of this information in separation (generates lifted tangent inequalities according to Belotti/Miller/Namazifar if also
  linear vars are present)
- `constraints/quadratic/disaggregate` to split a block-separable quadratic constraint into several quadratic constraint
- `constraints/quadratic/maxproprounds` and `constraints/quadratic/maxproproundspresolve` to limit the
  number of propagations rounds for quadratic constraints within one propagation round of SCIP solve or during SCIP presolve
- `constraints/varbound/presolpairwise` that allows pairwise presolving of varbound constraints, default is TRUE
- `heuristics/shiftandpropagate/onlywithoutsol` to switch whether the heuristic should be called in case a primal solution is already present
- `limit/maxorigsol` which defines the size of the solution candidate store (default value is 10)
- `lp/resolverestore` controlling how LP solution is restored after diving: if TRUE by resolving them,
  if FALSE by buffering them; if `lp/freesolvalbuffers` is TRUE, we free the buffer memory each time (FALSE by default)
- `lp/clearinitialprobinglp` to clear LP state at end of probing mode, if LP was initially unsolved
- `lp/resolveitermin` and `lp/resolveiterfac` to limit the number of LP iterations in resolving calls:
  resolveiterfac is a factor by which the average number of iterations per call is multiplied to get the limit, but the
  limit is at least resolveitermin; default is -1 (no limit) for resolveiterfac and 1000 for resolveitermin
- `lp/resolverestore` and `lp/freesolvalbuffers` possibility to buffer and restore LP solution after diving without
  having to resolve the LP; currently turned off, because performance impact is unclear;
- `misc/improvingsols` which states whether only solutions which have a better (or equal) primal bound
  as the best known are checked; this is of interest if the check of a solution is expensive; default value is FALSE
- `misc/resetstat` which state if the statistics should be reseted if the transformed problem is freed
  (in case of a benders decomposition this parameter should be set to FALSE) default value is TRUE
- `nodeselection/restartdfs/countonlyleafs` in node selector restart dfs which can be used to select the counting process of processed nodes
- `presolving/donotaggr` to deactivate aggregation of variables globally
- `pricing/delvars` and `pricing/delvarsroot` that define, whether variables created at a node / the
  root node should be deleted when the node is solved in case they are not present in the LP anymore
- `propagating/%s/maxprerounds` for all propagators which allows to change to maximal number of rounds
  of presolving where this propagator participates in
- `propagating/%s/presoldelay` for all propagators which allows to change if the presolving call of the given propagator should be delayed
- `propagating/%s/presolpriority` for all propagators which allows to change the priority of calling the given propagator
- `propagating/pseudoobj/propfullinroot` for allowing to propagate all variables in the root node,
  instead of stopping after `maxcands` which is set by a parameter as well
- `reading/gmsreader/bigmdefault` and `reading/gmsreader/indicatorreform` reader_gms is now able to write indicator
  constraints (reformulated either via big-M or sos1)
- `reading/gmsreader/signpower` to enable writing sign(x)abs(x)^n as the rarely used gams function signpower(x,n)
- `separating/closecuts/maxunsucessful` to turn off separation if we can not find cuts
- `timing/reading` to add reading time to solving time

### Data structures

- split off `PARAMEMPHASIS` from `PARAMSETTING` (in pub_paramset.c/paramset.c)
- new data structure `SCIP_STAIRMAP`
- add expression graph data structures and methods for reformulation, domain propagation, simple convexity check on
  nonlinear expressions and simplification for expression trees and graphs

Testing
-------

- New scripts for running tests with GAMS
- added scripts check_gams.sh, evalcheck_gams.sh and check_gams.awk and target `testgams` in Makefile
- adjusted all test scripts to use the same new optimality gap computation as in SCIP
- added Makefile option `VALGRIND=true` to enable running the SCIP checks (make test) through valgrind; valgrind errors
  and memory leaks are reported as fails
- moved *.test and *.solu files to subdirectory testset in check directory and adjusted test scripts

Build system
------------

### Makefile

- Variables:
  - via `PARASCIP=true` as a `Makefile` option it is possible to compile SCIP threadsafe in DEBUG-mode, (in OPT-mode it's
    only necessary if non-default messagehandler or CppAD is used)
  - the `make` parameter `PARASCIP=true` leads to threadsafe message handlers where you need to call
    SCIPcreateMesshdlrPThreads() and SCIPmessageSetHandler()/SCIPmessageSetDefaultHandler() and SCIPfreeMesshdlrPThreads();
    therefore we need to link with pthread library
  - new variable $(INSTALLDIR) in Makefile which define installation directory for the libraries, $(INSTALLDIR)/lib/,
    binary, $(INSTALLDIR)/bin and include headers, $(INSTALLDIR)/include, the default value is the empty string

- Linking:
  - Linking against Clp and Ipopt has been simplified. Only the directory where the
    package has been installed need to be provided now. For details see the INSTALL file.
  - to link against IPOPT, only the base directory of an Ipopt installation need to be specified now; additionally, if
    building with gnu compilers, the Ipopt libraries directory is stored in the SCIP binary, which should make it easier
    to run with Ipopt shared libraries
  - to link against Clp, only the base directory of an Clp installation needs to be specified now

- Targets:
  - New targets `(un)install` in Makefile, support for valgrind in testing environment
  - new target `make libs` which compiles only the libraries
  - new target in Makefile `install` performs `make` and copies using the install command the include headers, binary, and
    libraries
  - new target in Makefile `uninstall` removes libraries, binary and include headers form `INSTALLDIR`
  - removed target `lintfiles`, this target is now imitated by the `lint` target and a none empty variable `FILES`

Fixed bugs
----------

- fixed bug in copying if the target SCIP already is in solving stage: it might be that the copy of a variable cannot be found/created
- fixed bug trying to print big messages bigger than `SCIP_MAXSTRLEN`
- fixed bug w.r.t. counting feasible solutions and turned of sparse solution test
- LP solution status is now checked when checking root LP solution. Otherwise, due to different time measurements, it
  might happen that the LP solving was stopped due to the time limit, but SCIP did not reach the limit, yet.
- fixed bug trying to tighten multiaggregated variables, which have only one active representation and this variable is already tightened
- fixed possible buffer overrun in tclique_graph.c
- fixed issue with interactive shell in case (user) plugins are included after the default plugins
- fixed bug where mutiaggregating leads to an aggregation and both variables were of implicit or integral type
- fixed bug in conflict.c, where LPi was manipulated, but not marked as not solved

- Tree:
  - fixed assertion in tree.c w.r.t. node estimation
  - fixed bug in debug.c: removed tree nodes had not been checked if they were pruned due to an incumbent solution found by a diving heuristic

- Bounds:
  - fixed bug which occured when changing a bound in the solving stage when this variables got upgraded from continuous to
    a integer type, where the bounds of this variable were still not integral; due to that SCIPchgVarType() has changed (see above)
  - fixed bug in handling of lazy bounds that resulted in putting the bounds explicitly into the LP

- Separation:
  - fixed assert in sepa_clique.c which is currently not valid because implicit binary variables in cliques are ignored
  - fixed bug in sepa_zerohalf.c concerning inconsistent construction of solution array of variables and fixed wrong assert about variable bounds

- Constraints:
  - fixed not correct merging of variable in logicor constraint handler and changed the name of the method to a common
    name used by other constraint handlers too(findPairsAndSets->mergeMultiples)
  - fixed bugs in changing the initial and checked flags for constraints in original problem
  - fixed bug in cons_linear.c, when scaling a constraint maxabscoef was not set correctly, furthermore the correction of
    maxabscoef was not handled correctly
  - fixed bug in cons_indicator.c trying to copy a constraint where the pointer to the linear constraint did not point to
    the already transformed linear constraint (, happend when SCIPcopy() is used after transforming before presolving)
  - fixed numerical bug in linear constraint handler: polishing of coefficients after fixing variables led to wrong
    results for continuous variables fixed to a close-to-zero value.
  - fixed bug in cons_bounddisjunction where branching on multiaggregated variables was tried while all aggregation variables are fixed
  - fixed bug in presolving of cons_logicor.c: adding variable implications can lead to further reductions; added call to applyFixings()
  - fixed bug in cons_countsols.c w.r.t. none active variables
  - fixed bug in cons_linear.c, scaling could have led to wrong values

- Reader:
  - fixed bug in reader_fzn.c w.r.t. cumulative constraints
  - fixed bug in reader_mps.c: if a variables first occurence is in the bounds section, then the corresponding variable bound was lost
  - fixed several issues in flatzinc reader
  - deactived checking of zero solution in Zimpl reader when no starting values are provided
  - reader_lp is now able to read lines longer than 65534 characters

- Memory:
  - fixed bug in copying NLPI interfaces that use block-memory (NLPI copy used block memory from source SCIP)
  - fixed memory leak in reader_pip.c
  - fixed memory leak in coloring part of maximum clique algorithm (tclique_coloring.c)
  - fixed memory leak in coloring part of maximum clique algorithm (tclique_coloring.c) in a better way

- Numerics:
  - fixed bug which occured when the dual farkas multipliers were not available in the lpi because the LP could only be
    solved with the primal simplex due to numerical problems
  - fixed bug in ZI round heuristic that led to infeasible shiftings for numerically slightly infeasible rows with close-to-zero coefficients
  - fixed numerical issue in octane heuristic: close-to-zero values for ray direction could have led to bad computations

- Propagation:
  - fixed bug in propagation of indicator constraints: cannot fix slack variable to 0 if linear constraint is disabled/not active
  - fixed bug in cons_linear.c while sorting the eventdatas during the binary variable sorting for propagation
  - fixed bug and wrong assert in heur_shiftandpropagate.c when relaxing continuous variables from the problem
  - fixed bug in cons_orbitope:resprop() for the packing case
  - fixed wrong changing of wasdelayed flag for propagators
  - fixed bug using wrong sign in infinity check in prop_pseudoobj
  - fixed bug in redcost propagator: can only be called if the current node has an LP
  - fixed bug w.r.t. infinity loop during propagation

Miscellaneous
-------------

- The interface contains several additional callback functions and parameters for plugins. Some effort may be required to compile your old
  projects with SCIP 2.1. For details see section `Changes between version 2.0 and 2.1` in the doxygen documentation.

@page RN20 Release notes for SCIP 2.0

@section RN202 SCIP 2.0.2
*************************

Performance improvements
------------------------

- improved twoopt-heuristic by considering larger search domains
- the SoPlex interface now has the capability to provide a primal ray, provided it is compiled against the next SoPlex release (>= 1.5.0.2)
- calculation of node priority now also works when variable's relaxation value is equal to a bound
- fixed issue w.r.t. calling primal heuristics after presolving detected infeasibility

- Constraints:
  - fasten propagation in cons_knapsack.c due to negated clique partitions
  - recalculating only needed partitions in cons_knapsack.c, not always both

- Memory:
  - reduced memory usage of shift-and-propagate heuristic
  - knapsack constraints are now separated faster; SCIPsolveKnapsackExactly() now works faster and requires less memory
  - fasten knapsack separation by replacing SCIPallocBuffer(Array) through SCIPallocBlockMemory(Array)
  - improved runtime and memory consumption in SCIPsolveKnapsackExactly() in cons_knapsack.c

Fixed bugs:
----------

- fixed `make/make.project`
- fixed wrong assert in plugins that use SCIPcopy()
- fixed bug in DINS w.r.t. column generation
- fixed bug in var.c where a possible multiaggregation was resolved to an aggregation but the variables types were not
  checked to prefer more general types for aggregating; possible memory loss removed
- fixed bug in prop_vbounds.c w.r.t. infinity lower and upper bound of variable bound variables
- fixed bug w.r.t. setting wall clocks
- fixed wrong assert in var.c (replaced `==` through SCIPsetIsEQ()), real values do not have to be exactly the same when
  computed in different function
- fixed bug in SCIPsolveIsStopped() where it could happen that TRUE was reported if a nodelimit was reached but
  checknodelimits had been set to FALSE
- fixed three bugs when writing in fzn format (wrongly splitted writing buffer, wrong variables was used, floats were printed to short)
- fixed bug in conflict.c, infeasibility analysis with big values led to wrong result

- Heuristics:
  - fixed bug in DINS heuristic that occured when the incumbent solution value is outside the variable's current domain
  - fixed behavior of LNS heuristics when the subproblem aborts: continue in optimized mode, stop in debug mode
  - fixed segmentation fault in heur_subnlp.c which occured if resolving the NLP with a tighter feasibility tolerance
    failed with a solver error
  - fixed bug in heur_subnlp.c where constraints forbidding variable fixations where added if a cutoff was used in the subproblem
  - fixed bug in heur_subnlp.c where wrong constraints forbidding variable fixations where added in case of general integers

- NLP:
  - fixed bug in changing quadratic coefficients of a row in the NLP
  - fixed various small bugs in nonlinear expressions code
  - fixed removal of fixed linear variables from a nonlinear row: a fixed variable may have not been removed if there was
    also a multiaggregated variable

- LP:
  - implemented SCIPlpiGetPrimalRay() in SoPlex interface that has become available with SoPlex version 1.5.0.2
  - fixed two bugs at nodes with unbounded LP relaxation: don't check lp rows of infinite solution; don't analyze conflict
    due to primal cutoff bound of -infinity
  - fixed wrong assumption that an optimal LP solution in the root is optimal for the problem if there are no active
    pricers, need to check also whether all variables are in the LP

- Constraints:
  - fixed bug in reader_cip regarding reading of very long constraints
  - fixed bug while after restarting possible the aggregted variables were not removed in setppc constraints
  - fixed bug in cons_knapsack: in seldom circumstances the relaxation of a linear constraint can detect infeasibility,
    which was not handled properly
  - fixed bug w.r.t. to pricing variables in case new initial constraints come in during the price and cut loop
  - fixed bug in cons_soc.c w.r.t. upgrading from quadratic constraints with finite left-hand-side
  - fixed bug caused by not (correctly) counting boundchanges in cons_varbound.c
  - fixed bug in sorting mechanism in cons_xor.c
  - fixed wrong (neg)cliquepartition check in cons_knapsack.c when deleting a coefficient
  - fixed bug in cons_quadratic: in seldom cases, fixed variables may have been substituted out wrongly in presolve
  - fixed bugs in cons_countsols.c w.r.t. collecting feasible solutions and forbidding a found solution
  - fixed bug in cons_linear.c: multiaggregated variables were not removed when adding during solve, leading to a failing
    assert in tightenBounds due to an unsuccessful bound tightening

- Memory:
  - fixed bug concerning overflow in memsize calculation in set.c
  - fixed memory leak in SoPlex LP interface when requesting an unbounded solution
  - fixed memory leak in SoPlex LP interface when solving with LP scaling
  - fixed memory leaks in reader of TSP example

@section RN201 SCIP 2.0.1
*************************

Performance improvements
------------------------

- SCIP with SoPlex as LP solver now uses auto pricing by default (start with devex, switch to steepest
  edge after some iterations); this fixes timeouts on instances where devex converges very slowly
- fixing lifting of new knapsack items which are negated items of already included items, this could lead to very long presolving
- fixed performance issue in presolving w.r.t. to computing the number of new fixings, aggregated,
  and so on before a constraint handler presolver is called
- in case of adding constraints during pricing with initial flag set to
  TRUE, we add now these constraints after the pricing round to the LP
- changed parameter values in clique separator in order to avoid very large branch-and-bound trees

Interface changes
-----------------

### New and changed callbacks

- allow access of transformed constraints in `SCIP_STAGE_TRANSFORMED`

### Changed parameters

- replaced parameter `constraints/quadratic/minefficacy` by `constraints/quadratic/minefficacysepa` and `constraints/quadratic/minefficacyenfo`
- added possible values `a` and `e` for `constraints/soc/nlpform` to enable automatic choice and convex exponential-sqrt
  form for SOC constraint representation in NLP

Fixed bugs
----------

- fixed bug w.r.t. looseobjval; the counting of number of loose variables in the LP data structure was incorrect in case
  a variable got aggregated or multi-aggregated
- fixed bug in copy method of objvardata which should only create a new `SCIP_VARDATA` if the implemented subclass create
  a copy of the given objvardata object
- fixed bug in lp.c where in case of objlimit reached and fastmip not all variables where priced because of an incorrect
  dual solution
- fixed bugs in binpacking example w.r.t. empty struct and not initializing an array
- fixed bugs in sepa_clique.c concerning incorrect way to ignore implicit binary variables in cliques and non-active
  variables in implications
- fixed some bugs w.r.t. to casting pointer arrays
- fixed bug in vars.c which handled arrays with parts of original variables during resolving to active variables (using
  SCIPvarsGetProbvarBinary) wrong
- fixed bug in nlp.c: nlrowSearchQuadElem was using SCIPquadelemSortedFind() incorrectly

- Branching:
  - fixed assertion w.r.t. to probing during the propagation round of a branch-and-bound node
  - fixed computation of node's objective value estimate when branching on continuous variables (see
    SCIPtreeCalcChildEstimate(), SCIPtreeBranchVar())
  - fixed bug in statistic w.r.t. number of calls for external branching candidates
  - fixes to branching on continuous variables

- Reader:
  - fixed bug in reader_gms.c: linear coefficients for quadratic variables were not printed if they had no
    square-coefficient
  - fixed bug in reader_mps: indicator constraints do not output the slack variables anymore

- Constraints:
  - fixed bugs in SCIPcopyConss: copy all active constraints (including disabled ones), *valid was not initialized to TRUE
  - fixed bug in debug.c w.r.t. checking of constraints and continuous variables
  - fixed bug in cons.c which didn't allow the changing of the separation and enforcement flag of a constraint in the
    problem stage
  - corrected behavior of the copy function in cons_indicator.c: create artificial linear constraint if linear constraint
    was deleted
  - fixed bug in cons_indicator.c: presolving cannot delete linear constraints; several other minor bugfixes
  - fixed bugs in cons_bounddisjunction where the branching during the constraint enforcement was done incorrectly
  - fixed bugs in cons_orbitope.c: orbitopal fixing for the packing case had two bugs; also fixed one wrong assert
  - fixed bugs in cons_sos?.c: take average of objestimate
  - fixed bug in cons_logicor, implications on none `SCIP_VARTYPE_BINARY` variable were handled wrong
  - fixed bug in cons_linear while trying to add a conflict without any variables
  - fixed bug in cons_indicator.c: creating constraints in transformed stage is now possible

- LP Interface:
  - fixed bug w.r.t. memory allocation for all values of a column in lpi_cpx.c
  - fixed bugs in SCIPnlpiOracleChgLinearCoefs() and SCIPnlpiOracleChgQuadCoefs() for the case where new coefficients where
    added
  - fixed bugs in lpi_none.c w.r.t. debug and opt mode
  - fixed bug in lpi_cpx.c w.r.t. to wrong handling in case the crossover did not succeed

- Heuristics:
  - fixed bug in heur_subnlp when initialized starting values of a fixed variable in the NLP of the subscip
  - fixed bug in heur_undercover: removed option globalbounds, since we are not allowed to relax bounds at a probing node
  - fixed bug in heur_shiftandpropagate where some variables were initialized too late
  - fixed numerical issue in some heuristics: nearly-integral values that are between the feasibility and the integrality
    tolerance might not have been rounded correctly
  - fixed bug in heur_guideddiving: best solution is now copied to avoid deletion in case of many new solutions
  - fixed bug in DINS heuristic, information storage for binary variables could lead to bad memory access in column
    generation applications
  - fixed bug in heur_shiftandpropagate.c: Now, the heuristic checks rows for global infeasibility at the beginning. This
    check is only relevant if presolving is disabled.
  - fixed bug in heur_subnlp when forbidding a particular combination of integer variables in the main problem

@section RN200 SCIP 2.0.0
*************************

Features
--------

- added relaxation structure to SCIP, it represents global relaxation information independent from a specific relaxator;
  at the moment, it contains information about the relaxation solution stored in the variables: objective value and
  validness
- SCIP may now be manually restarted
- SCIPsolveKnapsackExactly() got a new 12. parameter `SCIP_Bool* success` which stores if an error occured during
  solving(normally a memory problem)
- SCIP can now handle problems with continuous variables w.r.t. to counting (the projection to the integral variables
  are counted)
- an XML-parser is available in the src/xml subdirectory
- We do not distinguish between block memory for the original and the transformed problem anymore. The same
  block memory is now used in both problem stages.
- added new sorting method SCIPsortLongPtr(), SCIPsortDownLongPtr() and all corresponding methods
- added new sorting method SCIPsortRealIntPtr(), SCIPsortDownRealIntPtr() and all corresponding methods

- Heuristics:
  - SCIP can now copy instances (e.g. for heuristics)
  - new undercover heuristic for MINLPs: fixes variables such as to obtain a linear or convex subproblem and solves this
  - primal heuristics may now already be called before presolving, using the new timing point
    `SCIP_HEURTIMING_BEFOREPRESOL`.  Note that solutions that are added before/during presolving, will be retransformed to
    the original space.
  - primal heuristics may now be called during presolving, using the new timing point `SCIP_HEURTIMING_DURINGPRESOLLOOP`
  - added heuristic zirounding (heur_zirounding.{c,h})
  - added heuristic twoopt (heur_twoopt.{c,h})
  - added new NLP heuristic (heur_subnlp.{c,h}) which solves the sub-NLP that is obtained by fixing all discrete variables
    in the CIP and applying SCIP's presolving
  - feasibility pump heuristic now implements all functionality for feasibility pump 2.0

- Reader:
  - can now read XML-solution files as used by CPLEX
  - the MPS reader can now read MIQPs and MIQCPs where a quadratic objective function can be specified by a QMATRIX or
    QUADOBJ section and the quadratic part of a quadratic constraint by a QCMATRIX
  - the MPS reader can now write quadratic and SOC constraints
  - the GAMS reader can now write SOC constraints
  - added support for bool_gt, bool_lt, bool_ge, bool_le, bool_ne, bool_not, int_times, int_minus, int_plus, int_negate,
    float_times, float_minus, float_plus, float_negate constraints to flatzinc reader
  - the LP reader (.lp files) can now read MIQPs and MIQCPs and write quadratic and SOC constraints
  - the LP reader (.lp files) and MPS reader can now read semicontinuous variables, they are handled by creating bound
    disjunction constraints
  - added new reader for polynomial mixed-integer programs (reader_pip.{c,h}) as used in the POLIP

- Indicator constraints:
  - SCIP can now handle indicator constraints (reading (from LP, ZIMPL), writing, solving, ...) see \ref cons_indicator.h.
  - the indicator constraint can now decompose the problem, i.e., not add the linear constraint to the problem if all of
    its variables are continuous
  - can now read and write indicator constraints in the (extended) MPS format
  - cons_indicator tries to adapt solutions to get feasible during check
  - cons_indicator allows to store information on other linear constraints that might help to separate cuts

- Constraint handlers:
  - Solution counting extended to constraint integer programs, this also
    includes constraint integer programs which contain continuous variables
  - The solution behavior of SCIP can be diversified by randomly permuting constraints and variables or randomly
    determining a set of branching variables with a unique high priority
  - `negated cliques` (1<=i<=n : sum (x_i) >= n-1) were added and we are using them now inside the knapsack constraint
    handler, the cliquepartitioning which is returned by SCIPcalcCliquePartition() contains now integer != 0, negatives ones
    indicates a negated clique and positive ones indicates a normal clique
  - SCIP is now able to detect in DEBUG-mode whether a constraint or variables which will be added, was also created in
    the same scip instance, if not an error is thrown
  - cons_knapsack is now able to detect negated cliques due to negated cliques on knapsack constraints
  - SCIP is now able to write non-linear opb-files(linear instances with and-constraints)
  - New constraint handlers for linking constraints (only Beta), cumulative constraints, and for breaking orbitopal symmetries
  - `negated cliques` handling in knapsack constraint handler got changed due to the new method
    SCIPcalcNegatedCliquePartition() resulting in new consdata members `negcliquepartition`, `negcliquepartitioned` and
    `nnegcliques`; changed SCIPcalcCliquePartition() so all cliquepartitions (calculated by SCIPcalcCliquePartition() or
    SCIPcalcNegatedCliquePartition(), which uses the first one) contain again not negative integers
  - `and`, `knapsack`, `linear`, `logic`, `or`, `quadratic`, `setpp`, `varbound`, `xor` and `clique` constraint handlers
    can handle implicit binary variables
  - knapsack constraint handler is now able to pairwise presolving constraints
  - constraint handlers `logicor`, `and`, `or` can parse their output
  - constraint handler `or` can copy its constraints
  - added packing/partitioning orbitope constraint handler for symmetry handling (cons_orbitope.{c,h})
  - added constraint handler for second order cone constraints (cons_soc.(c|h))
  - added constraint handler cons_linking.{c,h} (see cons_linking.c for more details)
  - cons_quadratic can make solutions in CONSCHECK feasible for the quadratic constraints by moving values of linear
    variables and passing the modified solution to the trysol heuristic
  - constraint handler can now register their upgrade functions for quadratic constraints to cons_quadratic (similar to
    LINCONSUPGD)

- Separation:
  - New separators for oddcycle cuts and Chvatal-Gomory cuts using sub-MIPs
  - modified implementation of separation algorithms in cons_knapsack.c according to results of diploma thesis; including
    super-additive lifting (disabled)
  - uncommented decomposeProblem() in sepa_zerohalf.c (in default settings, not used anyway): was not adapted to the case
    that contiuous variables are allowed in a row
  - new separator rapid learning (sepa_rapidlearning.{c,h}) that produces conflicts, global bound changes, primal
    solutions and initializes inference values for branching
  - added Chvatal-Gomory cuts separated with a sub-MIP (sepa_cgmip.{c|h})
  - added reader for 'Weigted Boolean Optimization': problems (reader_wbo.{c,h}), this reader needs the reader_opb files
  - new separator oddcycle (sepa_oddcycle.{c,h}) separates oddcycle inequalities using the implication/conflict graph and
    dijkstra-algorithm based on binary heaps (dijkstra/dijkstra_bh.{c,h})

- Branching:
  - Branching on externally given candidates, the \ref BRANCH 'branching rules' have a second new callback method
    (see type_branch.h for more details): SCIP_DECL_BRANCHEXECEXT(x) can be used to branch on external branching candidates,
    which can be added by a user's `relaxation handler` or `constraint handler` plugin, calling SCIPaddExternBranchCand().
  - added branchcands for relaxator solution, that can be added by the relaxator and used by branching rules
  - added relaxsol to variables, s.t. a relaxator can store a solution on which branching or separation can be done
  - SCIP can now branch on relaxation solutions that are either installed to the relaxsol field of the variables or added
    to the list of relaxation candidates, e.g., by constraint handlers. Branching on relaxation solutions is performed if
    the enforcement resulted in an unresolved infeasibility and there are no LP branching candidates, but before pseudo
    solution branching.  The branching rules leastinf, mostinf, random and pscost implement the callback for branching on
    relaxation candidates.
  - SCIP can branch on continuous variables. The branching value x' must not be one of the bounds. Two children (x <= x',
    x >= x') will be created.
  - the vbc visualization adds the branching type (lower or upper bound change) and the new bound to the node information
  - the vbc visualization adds the new bound of the branched variable to the node information

- Statistic:
  - added statistic information about the first primal solution to SCIP statistic; in the statistic output a new line
    appears with this information
  - now the statistic displays the number of calls of the feasibility checking method of each constraint handler and the
    running time of it

- Propagation:
  - New rounding and propagation heuristics
  - New propagator for variable bounds
  - primal heuristics may now be called directly after the node's propagation loop, using the new timing point
    `SCIP_HEURTIMING_AFTERPROPLOOP`
  - following methods SCIPinferVarUbProp(), SCIPinferVarLbProp(), SCIPinferVarLbCons(), SCIPinferVarUbCons() have a new 6th
    parameter `SCIP_Bool force` which allows bound tightening even if the difference to the newbound is below bound
    strengthening tolerance
  - added propagator for variable lower and upper bounds (prop_vbounds.{c,h}); adjusted cons_varbound.c, var.c, and,
    implics.c to work correctly with the new propagator

- Nonlinear CIPs:
  + Improved constraint handler for quadratic constraints
  + New constraint handler for second order cone constraints
  + New MINLP heuristics (undercover, subnlp)
  + Preliminary support for non-linear relaxations (via expression trees)
  + Automatic branching on solutions from arbitrary relaxations and on continuous variables

Performance improvements
------------------------

- improved `settings/emphasis/cpsolver.set` to decrease time per node
- reworked access to pseudo solution and inference value of variables in order to reduce function calls
- changed default value of parameter `nodeselection/restartdfs/selectbestfreq` to 0; this means if the current node has
  no children the node with the best bound is selected (SCIPgetBestboundNode())
- added a dual reduction step in cons_knapsack.c
- fasten check for common cliques in SCIPcliquelistsHaveCommonClique
- SCIP with CPLEX as LP solver now uses quickstart steepest edge pricing as default instead of steepest edge pricing
- avoid unnecessary domain propagation and LP resolve at nodes with infeasible LP relaxation
- improved zerohalf cut separator: more than one delta is tested for MIR cuts, better handling of dense base
  inequalities, faster scaling of fractional coefficients in rows (now enabled), improved parameter settings (presolving)

- LP solution:
  - in root node, first LP solution is checked for feasibility to avoid expensive setup
  - avoided restarting if LP solution is feasible
  - separators are not called any longer for an integral initial LP solution

Examples and applications
-------------------------

- New branch-and-price example which includes Ryan/Foster branching (binpacking example)
- New example illustrating the use of an event handler (`example/Eventhdlr`)

Interface changes
-----------------

- Enhanced user interface for callable library: manual restarts, predefined settings and many other features
- Support of wbo format for weighted PBO problems, IBM's xml-solution format and pip format for polynomial mixed-integer programs
- Extended reader for Flatzinc models
- new API for 'expressions interpreter': code that evaluates expression trees, including first and second derivatives
- NLP solver interface (NLPI) now independent of SCIP like LPI
- SCIP can now maintain a central NLP relaxation of the problem (similar to LP)
- SCIP can now manage a list of external codes (e.g., LP or NLP solver, ZIMPL)
- lp.h/lp.c and the lpi's were changed according to the changes mentioned below.
- adding and deletion of rows to the separation storage and to the LP can now be catched by events
  (`SCIP_EVENTTYPE_ROWADDEDSEPA`, `SCIP_EVENTTYPE_ROWDELETEDSEPA`, `SCIP_EVENTTYPE_ROWADDEDLP`, `SCIP_EVENTTYPE_ROWDELETEDLP`)

### New and changed callbacks

- new callback SCIP_DECL_BRANCHEXECRELAX(), together with new parameter in SCIPincludeBranchrule() for branching on a
  relaxation solution

- Copying a SCIP instance:
  - Constraint handlers have two new callback methods. One for copying the constraint handler plugins
    SCIP_DECL_CONSHDLRCOPY() and the other for copying a constraint itself, SCIP_DECL_CONSCOPY().
  - All plugins, like \ref BRANCH `branching rules` and \ref HEUR `primal heuristics`, have a new callback method (see, e.g.,
    type_branch.h and type_heur.h for more details):
    - SCIP_DECL_BRANCHCOPY(x), SCIP_DECL_HEURCOPY(x) etc.
    - When copying a SCIP instance, these methods are called to copy the plugins.
  - The main problem has a new callback method (see type_prob.h for more details) SCIP_DECL_PROBCOPY(x) when copying a
    SCIP instance, this method is called to copy the problem's data.
  - Variables have a new callback method (see type_var.h for more details) SCIP_DECL_VARCOPY(x) when copying a SCIP
    instance, this method is called to copy the variables' data.

- Restarts:
  - The callback SCIP_DECL_PROBEXITSOL(x) in the main problem has one new parameter (see type_prob.h for more details):
    - The parameter `restart` is `TRUE` if the callback method was triggered by a restart.

### Deleted and changed API methods

- All C++ objects and constructors have a SCIP pointer, now.
- added parameter scip to ObjCloneable::clone()
- changes in a row can now be catched via row events (SCIPcatchRowEvent(), SCIPdropRowEvent(),
  `SCIP_EVENTTYPE_ROWCOEFCHANGED`, `SCIP_EVENTTYPE_ROWCONSTCHANGED`, `SCIP_EVENTTYPE_ROWSIDECHANGED`)
- added new parameter `varcopy` to SCIPcreateVar() to add the function for copying variable data
- in case of using SCIPwriteTransProblem() the currently (locally) valid problem is written this now also includes the
  local constraints

- Settings:
  - The predefined setting files like `settings/cuts/off.set,aggressive.set,fast.set` have been replaced by
    interface methods like SCIPsetHeuristics(), SCIPsetPresolving(), SCIPsetSeparating(), and SCIPsetEmphasis() in
    \ref scip.h and by user dialogs in the interactive shell like
    `SCIP> set {heuristics|presolving|separating} emphasis {aggressive|fast|off}` or
    `SCIP> set emphasis {counter|cpsolver|easycip|feasibility|hardlp|optimality}`
  - All functions for setting user parameters of different types like SCIPparamSetBool(), SCIPparamSetChar(),
    SCIPparamSetInt(), SCIPparamSetLongint(), and SCIPparamSetString() in pub_paramset.h have a new parameter
    `quiet` it prevents any output during the assign to a new value.

- NLP:
  - NLPIs can now be used without generating a SCIP instance (i.e., do not require a SCIP pointer), code moved into src/nlpi
  - NLPIs can now be managed like other SCIP plugins, i.e., they can be included into the SCIP core and accessed by
    methods SCIPincludeNlpi(), SCIPfindNlpi(), SCIPgetNNlpis(), SCIPgetNlpis(), SCIPsetNlpiPriority()

- Intervalarithmetic:
  - method SCIPgetVarPseudocostCurrentRun() now returns the pseudocost value of one branching direction, scaled to a unit
    interval, old method now called SCIPgetVarPseudocostValCurrentRun()
  - renamed SCIPintervalScalarProductRealsIntervals()/SCIPintervalScalarProduct() by
    SCIPintervalScalprodScalars()/SCIPintervalScalprod() and redesigned them in intervalarith.c including new methods
    SCIPintervalScalprodScalarsInf/Sup()

- Branching:
  - The usage of strong branching changed. Now, SCIPstartStrongbranch() and SCIPendStrongbranch() must be
    called before and after strong branching, respectively.
  - The methods SCIPgetVarPseudocost() and SCIPgetVarPseudocostCurrentRun() in \ref scip.h now return the pseudocost value of
    one branching direction, scaled to a unit interval. The former versions of SCIPgetVarPseudocost() and
    SCIPgetVarPseudocostCurrentRun() are now called SCIPgetVarPseudocostVal() and SCIPgetVarPseudocostValCurrentRun(), respectively.
  - The methods SCIPgetVarConflictScore() and SCIPgetVarConflictScoreCurrentRun() in \ref scip.h are now called
    SCIPgetVarVSIDS() and SCIPgetVarVSIDSCurrentRun(), respectively.
  - The methods SCIPvarGetNInferences(), SCIPvarGetNInferencesCurrentRun(), SCIPvarGetNCutoffs(), and
    SCIPvarGetNCutoffsCurrentRun() are now called SCIPvarGetInferenceSum(), SCIPvarGetInferenceSumCurrentRun(),
    SCIPvarGetCutoffSum(), and SCIPvarGetCutoffSumCurrentRun(), respectively. Furthermore, they now return
    `SCIP_Real` instead of `SCIP_Longint` values.
  - The method SCIPgetVarStrongbranch() has been replaced by two methods SCIPgetVarStrongbranchFrac() and
    SCIPgetVarStrongbranchInt().

- Copying a SCIP instance:
  - Every new callback method resulted in a new parameter of the include function for the corresponding plugin,
    e.g., SCIPincludeBranchrule() has two new parameters `SCIP_DECL_BRANCHCOPY((*branchcopy))` and
    `SCIP_DECL_BRANCHEXECREL((*branchexecrel))`.  In the same fashion, the new callbacks
    `SCIP_DECL_VARCOPY` and `SCIP_DECL_PROBCOPY` led to new parameters in SCIPcreateVar() and SCIPcreateProb() in
    scip.c, respectively.
  - W.r.t. to copy and the C++ wrapper classes there are two new classes. These are `ObjCloneable` and `ObjProbCloneable`.
    The constraint handlers and variables pricers are derived from `ObjProbCloneable` and all other plugin are derived from `ObjCloneable`.
    Both classes implement the function `iscloneable()` which return whether a plugin is clone able or not. Besides that each class has a
    function named `clone()` which differ in their signature. See objcloneable.h, objprobcloneable.h, and the TSP example for more details.
  - SCIPincludeHeur() and SCIPincludeSepa() in \ref scip.h, as well as scip::ObjSepa() and scip::ObjHeur(), have a new parameter:
    `usessubscip`: It can be used to inform SCIP that the heuristic/separator to be included uses a secondary SCIP instance.
  - The argument success in `SCIP_DECL_CONSCOPY` has been renamed to valid.

- Heuristics:
  - SCIPcutGenerationHeuristicCmir() in sepa_cmir.h has three new parameters:
    - `maxmksetcoefs`: If the mixed knapsack constraint obtained after aggregating LP rows contains more
      than `maxmksetcoefs` nonzero coefficients the generation of the c-MIR cut is aborted.
    - `delta`: It can be used to obtain the scaling factor which leads to the best c-MIR cut found within
      the cut generation heuristic. If a `NULL` pointer is passed, the corresponding c-MIR cut will already be
      added to SCIP by SCIPcutGenerationHeuristicCmir(). Otherwise, the user can generate the cut and add it to SCIP
      on demand afterwards.
    - `deltavalid`: In case, the user wants to know the best scaling factor, i.e., `delta` passed is not `NULL`,
      `deltavalid` will be `TRUE` if the stored scaling factor `delta` will lead to a violated c-MIR cut.

### New API functions

- added SCIPcalcNegatedCliquePartition() to scip.c to calculate a clique partition on negations of all given binary
  variables
- SCIPpermuteArray() that randomly shuffles an array using the Fisher-Yates algorithm
- SCIPgetRandomSubset() that draws a random subset of disjoint elements from a given set of disjoint elements
- SCIPswapPointers()
- SCIPlpiGetSolverDesc() to get a descriptive string of an LP solver (developer, webpage, ...)
- SCIPholelistGetNext() to get the next hole of the hole list
- SCIPlpRecalculateObjSqrNorm() which is used when the old calculated square norm was unreliable
- SCIPpricerIsDelayed() which returns if the pricer is delayed (see pub_pricer.h)

- Variables:
  - SCIPvarIsBinary() which checks if a variable is (implicit) binary (see var.c for more details)
  - SCIPvarGetHolelistOriginal(), SCIPvarGetHolelistGlobal(), SCIPvarGetHolelistLocal() to get the original, global and local holes, respectively
  - SCIPvarGetProbvarHole() to tranform a given domain hole to the corresponding active, fixed, or multi-aggregated variable

- Restart:
  - allow user to trigger a restart during presolving SCIPrestartSolve()
  - SCIPrestartSolve() that allows the user to manually restart the solving process
  - SCIPisInRestart() to detect whether we are currently restarting

- Heuristics:
  - for heuristics SCIPheurSetFreq() to change the frequency of the heuristic (pub_heur.h, heur.c)
  - SCIPsepaUsesSubscip(), SCIPheurUsesSubscip()

- Intervalarithmetic:
  - SCIPeventGetHoleLeft() and SCIPeventGetHoleRight() for accessing the left right interval bound of a domain hole added or removed event
  - SCIPholelistGetLeft() and SCIPholelistGetRight()to get the left and right interval bounds of the open hole interval
  - SCIPintervalAddInf/Sup/Vectors(), SCIPintervalMulInf/Sup() in intervalarith.c

- Sorting:
  - added SCIPsortPtrPtrLongIntInt(), SCIPsortLongPtrPtrIntInt() and corresponding sorting/inserting/deleting methods in
    pub_misc.h and necessary defines in misc.c
  - added SCIPsortLongPtrInt() and corresponding sorting/inserting/deleting methods in pub_misc.h and necessary defines in misc.c
  - added SCIPsortPtrPtrInt() (and various other) and corresponding sorting/inserting/deleting methods in pub_misc.h and
    necessary defines in misc.c
  - SCIPsortPtrBool() and corresponding sorting/inserting/deleting methods in pub_misc.h and necessary defines in misc.c

- Constraint Handlers:
  - SCIPconshdlrGetEnfoConss(), SCIPconshdlrGetNEnfoConss()
  - can now forbid upgrading of individual linear constraints (SCIPmarkDoNotUpgradeConsLinear())
  - SCIPpermuteProb() that randomly permutes constraints and variables
  - SCIPgetResultantOr() which returns the resultant of an `or` constraint
  - SCIPmarkDoNotUpgradeConsLinear() in cons_linear.?, which allows to forbid upgrading of linear constraints
  - SCIPgetNUpgrConss() which returns the number of upgraded constraints
  - SCIPconshdlrGetCheckTime() and SCIPconshdlrGetNCheckCalls() which returns the running time in the feasibility checking of the
    corresponding constraint handler respectively the number of calls of the checking method (implemented in cons.c)

- Copy:
  - SCIPcopy() to clone a SCIP instance
  - SCIPcopyPlugins(), SCIPcopyParamSettings(), SCIPcopyVars(), SCIPcopyConss(), SCIPgetVarCopy() to copy
    individual parts of a SCIP instance separately.
  - SCIPcopyProbData() and SCIPprobCopyProbData() which copies the probdata from a sourcescip to a targetscip

- Branching:
  - two new functions SCIPgetVarsStrongbranchesFrac()/SCIPgetVarsStrongbranchesInt() for computing strong branching
    information for several variables
  - SCIPbranchruleGetNRelaxCalls() to get the total number of times, a particular branching rule was called on a relaxation solutions
  - SCIPbranchRelax() to branch on a relaxation solution
  - SCIPbranchVarVal() to branch on an arbitrary value within the variable's bounds
  - SCIPbranchGetBranchingPoint() and SCIPgetBranchingPoint() to select branching point for a variable, e.g.,
    ensure branching point is inside the interval for a continuous variable
  - SCIPexecRelpscostBranching() in branch_relpscost.{c,h}; this method allows of calling the reliability
    pseudo cost branching algorithm for given set of branching candidates from the outside
  - SCIPinitVarBranchStats() to initialize the branching statistics (such as pseudo costs, VSIDS, inference values) of a variable
  - SCIPselectBranchVarPscost() in branch_pscost.{c,h}; this method selects from a given candidate array a
    branching variable w.r.t. pseudo cost branching for relax candidates

- Reading, Writing and Parsing:
  - SCIPparseVarName() which parses a string in cip-format as a variable name
  - SCIPparseVarList() which parses a string as a variable list in cip-format
  - the Flatzinc reader can now handle the output annotations of the Flatzinc format; the method SCIPprintSolReaderFzn()
    outputs the given solution in Flatzinc format w.r.t. the output annotations
  - SCIPprintSolReaderFzn() which prints the best solution in Flatzinc format w.r.t. to the output annotations
    in the input file of the flatzinc model
  - SCIPwriteVarName() which writes a variable in cip-format to given stream
  - SCIPwriteVarsList() which writes an array of variables in cip-Format to given stream
  - SCIPwriteVarsLinearsum() which writes an array of variables and coefficients as linear sum in cip-Format to given stream

- Copying a SCIP instance:
  - SCIPapplyRens() in \ref heur_rens.h has a new parameter `uselprows`. It can be used to switch from LP rows
    to SCIP constraints as basis of the sub-SCIP constructed in the RENS heuristic.

- Parameters:
  - SCIPsetParamsCountsols() which sets the parameter for a valid counting process
  - SCIPsetEmphasis() which sets parameter to detect feasibility fast, handle hard LP, solves easy CIPs fast, behaves like a
    CP solver, set parameter for a valid counting process; the desired behavior is triggered via a parameter of the function
  - SCIPresetParam() to reset the value of a single parameter to its default value

- Settings:
  - added SCIPsortRealRealRealPtr() and corresponding sorting/inserting/deleting methods in pub_misc.h and necessary defines in misc.c
    as basis for the subSCIP, setting ist to TRUE (uses LP rows) will lead to same version as before
  - SCIPsetHeuristics(), SCIPsetSeparating(), SCIPsetPresolving() which set the heuristics to aggressive, fast, off, or
    default settings, depending on the `SCIP_PARAMSET` parameter
  - SCIPsetSubscipsOff() which disables all plugins that uses subscips
  - SCIPsepaSetFreq() to set the calling frequency of a separator

### Command line interface

- added new dialog for setting the SCIP parameters for hardlp, optimality, easy CIP, CP like search
- added new dialog for setting the SCIP parameters for feasibility problems `SCIP> set emphasis feasibility`
- added new dialog for setting the SCIP parameters for counting `SCIP> set emphasis counting`
- added new dialog for setting presolving to aggressive, fast, or off in interactive shell
- added new dialog for setting separation to aggressive, fast, or off in interactive shell
- added new dialog for writing all solutions which are collected during the counting process (see cons_countsols.{c,h})
- added new dialog for setting heuristics to aggressive, fast, or off in interactive shell
- added new dialog `display pricers` which displays all included pricers

### Interfaces to external software

- added interface to CppAD (nlpi/exprinterpret_cppad.cpp)
- Improved Xpress, CPLEX, SoPlex interfaces
- the SoPlex interface now includes equilibrium scaling on lp's solved from scratch without starting basis
- the SoPlex interface can now double check each SoPlex result against CPLEX (lpi_spx.cpp)
- the SoPlex interface has the option to restore basis only after entire strong branching phase instead of after each
  strong branch (off, because it mostly appears to increase strong branching time and iterations) (lpi_spx.cpp)

### Changed parameters

- removed parameter `constraints/knapsack/maxnumcardlift` and adapted setting files
- changed parameter `lp/fastmip` from boolean to integer, possible values are 0 (off), 1 (medium, default), 2 (full,
  must not be used with branch-and-price).

### New parameters

- `branching/clamp` to set the minimal fractional distance of a branching point to a continuous variable' bounds
- `branching/random/seed` to change the initial seed value of the branching rule random
- `constraints/indicator/addCouplingCons` that allows to add variable upper bounds if addCoupling is true
- `constraints/indicator/enforceCuts` that allows to check for violated cust in enforcement
- `constraints/indicator/maxCouplingValue` for the maximal value of the coefficient in a coupling inequality/constraint
- `constraints/indicator/noLinconsCon` which controls whether the linear constraint is not explicitly
  added to the problem. default is FALSE
- `constraints/knapsack/dualpresolving` to switch dualpresolving on/off inside the knapsack constraint handler, default is TRUE
- `constraints/knapsack/presolpairwise` that allows pairwise presolving of knapsack constraints, default is TRUE
- `constraints/knapsack/presolusehashing` that allows fast pairwise presolving of knapsack constraints, default is TRUE
- `heuristics/crossover/dontwaitatroot` that allows to call crossover at root node independently from nwaitingnodes
- `heuristics/rens/uselprows` that allows to switch between LP row and SCIP constraints as basis for the
  subSCIP, default is TRUE (uses LP rows)
- `lp/rowrepswitch` telling simplex solver to switch to row representation of the basis (if possible),
  if number of rows divided by number of columns exceeds this value (default value infinity, i.e. never switch)
- `lp/threads` to change the number of threads used to solve the LP relaxation (default is 0: automatic)
- `misc/lexdualstalling` that turns on the lex dual algorithm if the separation process is stalling
- `misc/usevartable` and `misc/useconstable` which turns on/off the usage of hashtables mapping from
  variable/constraint names to the variables/constraints; when turned off, SCIPfindVar() and SCIPfindCons() may not be
  used; the hashtables can be turned off for subMIPs to improve the performance, default value TRUE
- `misc/usesmalltables` which results in using smaller tables for names, cliques and cuts and improves
  the performace for smaller instances, default value FALSE
- `misc/permutationseed` to change the permutation seed value for permuting the problem after the
  problem is transformed (-1 means no permutation)
- `reading/zplreader/usestartsol` which allows to switch ZIMPL start solutions off, default value TRUE
- `vbc/dispsols` to propose if the nodes where solutions are found should be visualized in the branch and bound tree

### Data structures

- implemented the data structure and events for global and local domain holes added and removed
- new data structures and methods to handle nonlinear expressions in NLPI ({type_, struct_, pub_}expression.{h,c}):
  nlpioracle can store and evaluate general NLPs now, nlpi_ipopt can solve general NLPs now

Testing
-------

- minor changes on several evaluation scripts (new statuses: better, solved, sollimit, gaplimit) and short-mode for cmpres.awk
- support for FreeBSD (32- and 64-bit) including minor changes in several scripts in the check-directory

Build system
------------

### Makefile

- added scripts check_*.sh, evalcheck_*.sh and check_*.awk for blis, glkp, gurobi and symphony (including targets in
  Makefile) and slightly modified scripts for cplex, cbc and mosek and cmpres-script
- added target `lintfiles` which allows to call flexelint with a list of file, for example, make lintfiles
  `FILES=src/scip/prop_vbounds.c`
- the NLP solver interfaces and expression interpreter are located in a separate library (libnlpi.*; similar to the lpi
  library) and is required to link against the SCIP library also projects that use SCIP via `make/make.project` need to
  change their Makefile (!!!): in the $(MAINFILE) target, add $(NLPILIBFILE) behind $(LPILIBFILE) in the dependencies
  and add $(LINKCXX_l)$(NLPILIB)$(LINKLIBSUFFIX) to the linker flags
- The additional NLPI library requires a change in the Makefile of SCIP's project:
  The $(MAINFILE) target now has $(NLPILIBFILE) as additional dependency and the linking
  command requires $(LINKCXX_l)$(NLPILIB)$(LINKLIBSUFFIX) as additional argument.
- A bug in the Makefiles of older versions of the SCIP examples may cause
  data loss. If you have a custom Makefile, please ensure that the target
  `clean` is changed as described here:
  http://scipopt.org/download/bugfixes/scip-1.2.0/make.txt.

Fixed bugs
----------

- fixed bug in conflict.c in the method conflictsetAddBound()
- fixed `bug` in projects Makefiles w.r.t. `make clean`
- fixed bug in rapid learning with wrong ordering of dual and primal bound update, primal bound is now updated inside
  rapid learning
- fixed potential bug in rapid learning with dual reductions
- fixed potential bug where SCIPselectSimpleValue() returns a value slightly outside of the given bounds due to rounding
  errors (probably cancelation in subtraction in SCIPfindSimpleRational), now use rounding control and check result
- fixed bug that SCIP could not be continued after it has been stopped due to a limit
- fixed bug in var.c: SCIPvarChgLbOriginal() and SCIPvarChgUbOriginal() cannot access original bounds if the variable is
  negated
- fixed potential bug with pseudo solution branching on free variables
- fixed bug with multiaggregations whose infimum and supremum are both infinite: in such a case multiaggregation is now
  forbidden
- fixed numerical issue with multiaggregations which are infinite in one direction: value of multiaggregated variable
  could have been larger then inifinity
- fixed bug w.r.t. of adding a variable bound variable to its self
- fixed bug concering the incorrect assumption that every solution computed in SCIPlpGetUnboundedSol() is integral (we
  will not branch but return `infeasible or unbounded` like in presolving)
- fixed bug while breaking an clique down to their impications (in SCIPcliquetableCleanup() in implics.c) where the
  variable was not of vartype `SCIP_VARTYPE_BINARY`, instead of adding an implication we add a variable bound
- fixed bug with debugging a solution: during restarts erroneously it was claimed that the primal solution is cut off

- Interface:
  - fixed bug w.r.t. ObjDialog and displaying the description of the dialog
  - fixed bug when aborting pricing with Ctrl-C

- LP:
  - fixed bug in scip.c w.r.t. to call of conflict analysis for LPs which reached the objective limit in case of diving
  - fixed bug with resolving LPs at infeasible root node
  - fixed bug in lp.c: in sumMIRRow() rowtoolong was not set correctly
  - fixed bug in lp.c w.r.t. objective limit reached and the chosen comparison (fixed buglist entry 40)
  - fixed bug in lp.c: if in SCIPlpSolveAndEval() the LP has to be solved from scratch due to numerical troubles, reset
    `SCIP_LPPARAM_FROMSCRATCH` to `FALSE` afterwards
  - fixed bug in lp.c SCIProwGetObjParallelism() due to a wrong parallelism value which arised from cancellations during
    calculation of squared euclidean norm of objective function vector of column variables
  - fixed bug in lp.c: SCIPlpGetUnboundedSol() did not ensure that unbounded solution lies withing the bounds of the
    variables
  - fixed bug in lp.c w.r.t. to the number of `active` pricer

- Solve:
  - fixed bug in solve.c where relaxation branching candidates were cleared, but the relaxation was still marked solved
    and not called again, furthermore, adjusted criterions for solving a relaxation again
  - fixed bugs in solve.c: even with LP solving disabled, the root LP was solved in case continous variables are
    contained; setting pricing/maxvars(root) to 1 resulted in not calling the pricers
  - fixed bug in solve.c: make sure SCIP terminates correctly also when a user interrupt or gap limit is reached, i.e.,
    avoid error `pricing was aborted, but no branching could be created!`

- Tree:
  - fixed bug in tree.c: if an explicit branching point is given, we may not recompute a better centering point
  - fixed bug in tree.c: propagate implications on multi-aggregated should not be performed

- Constraints:
  - corrected several asserts in linear and quadratic constraint handler concerning parsing of CIP format
  - fixed bug while deleting redundant variables, which have no influence on changing the feasibility of the linear
    constraints, we need to update the sides of the constraint at each step, bug number 51 in bugzilla
  - fixed bug in copy procedure of AND constraint handler, negated variables have been copied to their originals
  - fixed bug when deleting a constraint where the update was delayed and not processed yet (in cons.c)
  - fixed bug in cons_linear.c: binary variables should not be multi-aggregated
  - fixed bug in cons_quadratic.c: curvature of bivariate quadratic constraints was not detected correctly
  - fixed bug in cons_sos2.c: the branching position was sometimes mistakenly increased
  - fixed bug in propagation of cons_sos2.c: the node can be cut off at more places: the previous version was not
    sucessfull in this respect
  - fixed bug in cons_linear.c:applyFixings() which could lead to lhs/rhs smaller/larger than -/+infinity
  - fixed bug in cons_linear.c in detectRedundantConstraints() and corrected old bug fix in SCIProwCreate(): we want lhs
    <= rhs to be satisfied without numerical tolerances in order to avoid numerical problems in the LP solver

- Knapsack Constraint Handler:
  - fixed bug in cons_knapsack.c: mergeMultiples() now detects whether a node can be cut off
  - fixed bug in cons_knapsack.c w.r.t. to items with zero weight
  - fixed bug in cons_knapsack.c: In SCIPseparateRelaxedKnapsack() not all variables need to be active in deeper regions
    of the tree
  - fixed bug in cons_knapsack.c and sepa_clique.c: the assumption that implications are always nonredundant and contain
    only active variables is not correct anymore as the corresponing vbound might be missing because of numerics

- Separation and Cuts:
  - fixed bug in cutpool.c: the hashkey computation was not constant over time
  - fixed bug in cutpool.c: hashkey of a row changed during the solving process (if a row is made integral after creation,
    maxabsval can be invalid when adding it to the pool, but might be recomputed later on)
  - fixed bug in sepa_rapidlearning.c, stop processing if there are no binary variables left
  - fixed bug in sepa_rapidlearning.c, corrected computation of right dualbound
  - fixed bugs in sepa_zerohalf.c, e.g., handling of intscaling and substitution of variable bounds
  - fixed bug in sepastore.c in sepastoreApplyLb/Ub being to hard on feasibility decisions
  - fixed bug in sepa_flowcover.c: numerical issues while computing candidate set for lambda

- LP Interfaces:
  - fixed bug in SoPlex autopricing due to which autopricing had behaved like steepest edge pricing so far
  - fixed bug in lpi_clp.cpp: SCIPlpiChgBounds() checks if the column status exists in Clp before using it
  - fixed wrong assert in Cplex LPI: Due to numerical inaccuracies, a few pivots might be performed after refactorization
  - fixed bug concerning assert(!SCIPlpDivingObjChanged(lp)) which was caused by wrong infinity double parameters for
    cplex
  - fixed makefile system for `OSTYPE=darwin` w.r.t. to CPLEX as LP solver

- Presolving:
  - fixed bug in cons_setppc: aggregated variables were not correctly removed in presolving
  - fixed bug in presolving of linear constraint handler: in redundancy detection, two different numerical epsilons were used
  - fixed bug in presolving while not applying a bound change on a variable in a single-variable constraint (e.g. x1 =
    0.03) in cons_linear which is too small, that lead to another bound change in presol_trivial which is not allowed, so
    now this bound change will be forced
  - fixed SCIPvarIsTransformedOrigvar() in var.c (variables generated by presol_inttobinary returned false)
  - fixed bug w.r.t. an assert in presol_inttobinary.c; it was assumed that the aggregation which is performed there will
    never lead to an infeasibility, this is not true, see comment in presol_inttobinary.c
  - fixed bug in presol_trivial.c trying to fix continuous variables, now uses a less stricter comparison to fix variables
  - fixed bug in cons_bounddisjunction.c: presolve may have tried to tighten bounds on a multiaggregated variable (now
    upgrades to linear constraint)

- Reading, Writing and Messages:
  - fixed bug while trying to write a MIP where SCIP needs to flush the lp changes first
  - fixed potential resource leak when running out of memory while writing files
  - fixed bug in reader_zpl.c which appeared using the parameter `reading/zplreader/parameters`
  - fixed bugs in flatzinc readers with constraints that exclusively consist of constants
  - fixed bug in reader_gms: correct handling of nonstandard bounds on general integer variables
  - fixed buglist entry 35, which was caused by a wrong read in correction when the reading buffer was full in
    reader_opb.c
  - fixed bugs in reader_fzn.c w.r.t. parsing and solution output in Flatzinc format
  - fixed bug in reader_fzn.c w.r.t. comment lines
  - fixed bug in reader_opb.c w.r.t. comment lines
  - fixed bug in message handler w.r.t. to messages which are longer then `SCIP_MAXSTRLEN`

- Heuristics:
  - fixed bugs do to `HEUR_TIMING SCIP_HEURTIMING_AFTERPROPLOOP` which appeared during repropagation
  - fixed bug in trivial heuristic: the locking solution might have falsely initialized some values to zero
  - fixed bug in heur_oneopt.c w.r.t. to SCIPtrySol(); it is necessary that the bound of the solution is check otherwise,
    infeasible solution could be accepted as feasible
  - fixed bug in heur_trivial.c w.r.t. to debug messages after a solution was freed
  - fixed bug for `HEUR_TIMING SCIP_HEURTIMING_BEFOREPRESOL` and modifiable constraints
  - corrected wrong assert in DINS heuristic when called for an empty problem
  - fixed potential bug in OCTANE heuristic with nonbasic solutions
  - fixed bug in sub-MIP heuristics with parameter change if some default plugins are not included
  - fixed bug in trivial heuristic with bounds that are greater than the heuristic's infinity value

Miscellaneous
-------------

- As the interface contains several additional callback functions and
  parameters for plugins, some effort may be required to compile your
  own projects with SCIP 2.0. See also `Changes between version 1.2 and 2.0` in the doxygen
  documentation for additional information.

@page RN12 Release notes for SCIP 1.2

@section RN120 SCIP 1.2.0
*************************

Features
--------

- adjusted hard memory limit to (soft memory limit)*1.1 + 100mb in check.sh, checkcount.sh, check_cplex.sh,
  check_cluster.sh and check_cbc.sh
- new presolving step in cons_knapsack.c, same like `simplifyinequalities` in cons_linear.c
- now it's possible to write strings with more than `SCIP_MAXSTRLEN` amount of characters in all message.c functions
- the current/root lp can be marked to be no relaxation of the current/root problem
- added new preprocessing step (mergeMultiples) in cons_setppc.c where equal variables are merged
- Black-box lexicographic dual simplex algorithm; can now run lexicographical dual algorithm (parameter `lp/lexdualalgo`)

- Bounds:
  - SCIP now has `lazy bounds`, which are useful for column generation: see @ref PRICER_REMARKS `pricer remarks` for an explanation.
    Each variable has now two additional `SCIP_Real` parameter which define a lazy lower and upper bound; lazy means that
    there exists constraints which implies these (lazy) bounds. If the lazy lower or upper bound is greater or less than
    the local lower or upper bound, respectively, then the corresponding bound is not put into the LP. The bounds are set
    to minus and plus infinity per default which yields the same behavior as before. With the methods SCIPchgVarLbLazy()
    and SCIPchgVarUbLazy() these bounds can be set.  This is of interest if SCIP gets used as a branch-and-price
    framework. Attention! The lazy bounds need to be valid for each feasible LP solution. If the objective function
    implies bounds on the variables for each optimal LP solution, but these bounds may be violated for arbitrary LP
    solutions, these bounds must not be declared lazy!
  - interval arithmetic functions can work with unbounded intervals added new functions to allow more operations on
    intervals, including solving quadratic interval equations

- Branching:
  - extended hybrid relpscost branching rule by usage of the average length of conflicts a variable appears in
  - `early branching`-functionality added: in a branch-and-price code, the user can stop pricing at a node although there
    may exist variables with negative reduced costs. In this case, the lp-lowerbound will not be used. The pricer has,
    however, the option to return a lower bound. This can be useful for column generation.

- Constraints:
  - Copy constructors and i/o functionality for constraints: all linear type constraint handlers are able to copy
    constraints using the function SCIPgetConsCopy() in scip.h
  - the linear constraint handler is able to parse a string in CIP format and create a corresponding linear constraint
  - Constraint handler for indicator constraints and parsing them from *.lp and *.zpl files
  - the indicator constraint can now try to produce a feasible solution (via heur_trysol)
  - one can now write indicator constraints in LP-format
  - added constraint handler for quadratic constraints

- Cuts:
  - added new version of zerohalf cuts from Manuel Kutschka
  - added multi-commodity-flow cut separator

- Heuristics:
  - Heuristics which are applied before root LP
  - added heuristic that performs a local search in an NLP (takes only linear and quadratic constraints into account so far)
  - added heuristic that gets a solution from other components and tries it (heur_trysol.?)
  - new trivial heuristic: tries zero solution, lower and upper bound solution and some variable lock based fixing
  - added new timing point, `SCIP_HEURTIMING_DURINGPRICINGLOOP`, for calling heuristics; If this timing point is used the
    corresponding heuristics is called during the pricing loop of variables; we also added this timing point to
    heur_simplerounding.{h,c} which has the effect that a LP solution which satisfies all integrality conditions during
    the pricing loop is detected

- Interfaces:
  - added first version of an interface to NLP solvers (type_nlpi.h, struct_nlpi.h, nlpi.h, nlpi.c, nlpi_oracle.h, nlpi_oracle.c)
  - Preliminary support of non-convex MIQCPs: Constraint handler for quadratic constraints, NLP heuristic and
    Ipopt interface, see \ref cons_quadratic.h.
  - There are LP-interfaces to QSopt and Gurobi (rudimentary).

- Reader and Writer:
  - added reader and writer for FlatZinc models (reader_fzn.{c,h})
  - added writer for GAMS models (reader_gms.{c,h})

Performance improvements
------------------------

- Enhanced MCF cuts: stable version, used by default
- replaced some function calls in loop conditions
- in sepa_cmir.c, if mksetcoefs is invalid for delta=1 no other values of delta are tested anymore
- changed the timing of the feasibility pump in case of pricing
- removed changing of update rule to `ETA` from standard soplex update `Forrest-Tomlin` in lpi_spx.cpp
- improved memory usage in heur_octane.c
- improved reading time of opb-files, due to using a hashtable for all `and`-constraints
- improved performance of merging variables in mergeMultiples() in cons_knapsack.c
- improved performance in tightenWeightsLift() and SCIPseparateRelaxedKnapsack() in cons_knapsack.c, due to now
  sparse-cleaning `global` arrays instead of using BMSclearMemory... functions for cleaning local arrays each time
- improved performance in SCIPcliquelistRemoveFromCliques()
- improved performance in SCIPcalcCliquePartition()
- improved performance in SCIPvarGetActiveRepresentatives() in var.c

- Presolving:
  - improved pairwise presolving in cons_and.c due to using a hashtable
  - improved pairwise presolving in cons_xor.c due to using a hashtable

Interface changes
-----------------

- A significant change for C++ users is that all include files of SCIP
  automatically detect C++ mode, i.e., no `extern `C`` is needed anymore.
- Reader for Flatzinc and GAMS models

### New and changed callbacks

- The callback SCIP_DECL_PRICERREDCOST(x) in the \ref PRICER `pricers` has two new parameters:
  + A `result` pointer determines whether the pricer guarantees that there exist no more variables. This allows for early branching.
  + A pointer for providing a lower bound.

- The \ref CONS `constraint handlers` have two new callback methods (see type_cons.h for more details):
  + SCIP_DECL_CONSCOPY(x): this method can be used to copy a constraint.
  + SCIP_DECL_CONSPARSE(x): this method can be used to parse a constraint in CIP format.

### Deleted and changed API methods

- SCIPcalcMIR() in scip.h has two new parameter `mksetcoefsvalid` and `sol`. The parameter `mksetcoefsvalid` stores
  whether the coefficients of the mixed knapsack set (`mksetcoefs`) computed in SCIPlpCalcMIR() are valid. If the mixed
  knapsack constraint obtained after aggregating LP rows is empty or contains too many nonzero elements the generation of the
  c-MIR cut is aborted in SCIPlpCalcMIR() and `mksetcoefs` is not valid. The input parameter `sol` can be used to separate a
  solution different from the LP solution.
- new parameter `set` in SCIPconsSetInitial().
- some interval arithmetic method take an additional argument to denote which value stands for infinity in an interval

- Variables:
  - SCIPgetVarClosestVlb() and SCIPgetVarClosestVub() in scip.h have a new parameter `sol`. It can be used to obtain the closest
    variable bound w.r.t. a solution different from the LP solution.
  - new parameters `lowerbound` and `result` in type_pricer.h: lowerbound can save a lower bound computed by the pricer,
    result indicates whether the pricer guarantees that there exist no more variables if no variable was found

### New API functions

- new methods to deactivate a pricer SCIPdeactivatePricer() in scip.c
- new methods in pub_misc.h/misc.c to access hash map lists and elements of a hash map list and to clear all entries in a hash map
- SCIPsetProbName() to set problem name in scip.h/c (SCIPprobSetName() in prob.h/c)

- Objective:
  - SCIPgetTransObjscale() and SCIPgetTransObjoffset() in scip.c
  - SCIPaddObjoffset() in scip.h; sets offset of objective function
  - SCIPgetOrigObjoffset() in scip.h; returns the objective offset of the original problem
  - SCIPgetOrigObjscale() in scip.h; returns the objective scale of the original problem

- Constraints:
  - detectRedundantConstraints() in cons_xor.c and necessary hash-functions for fast pairwise presolving
  - SCIPparseCons() in scip.h; parses constraint information (in cip format) out of a string
  - SCIPgetConsCopy() in scip.h; which copies a constraint of the source SCIP

- Relaxation:
  - SCIPisLPRelax() and SCIPisRootLPRelax() in scip.c and scip.h returning whether the current/root LP is a
    relaxation of the current/root problem and thus defines a valid lower bound
  - SCIPlpSetIsRelax() and SCIPlpSetRootLPIsRelax() in lp.c and lp.h to set the information, whether the lp is a valid relaxation;
    this information is per default set to true and constraint be used. The aggregated version has only 2 linear constraints the
    default linearization has nvars + 1

- Sort:
  - extended the sort template functions in sorttpl.c with a `five` array; now it possible to used this template to sort
    up to five arrays
  - new interface methods SCIPcolSort(), SCIProwSort(), SCIPcolGetIndex()
  - added SCIPsortPtrPtrLongInt() and corresponding sorting/inserting/deleting methods in pub_misc.h and necessary defines
    in misc.c

- Variables:
  - SCIPprintNodeRootPath() in scip.h This method prints all branching decisions on variables from the root to the given node
  - SCIPnodeGetParentBranchings(), SCIPnodeGetAncestorBranchings(), SCIPnodeGetAncestorBranchingPath(); These methods return
    the set of variable branchings that were performed in the parent node / all ancestor nodes to create a given node
  - SCIPchgVarLbLazy() and SCIPchgVarUbLazy() in scip.h; These methods can be used to change the lazy lower or
    upper bound of a variable; This might has the consequences that the bounds of the corresponding variable is not in
    LP. This is the case if the lazy lower or upper bound is greater or less than the local lower or upper bound, respectively
  - SCIPvarGetLbLazy() and SCIPvarGetUbLazy() in pub_var.h; These methods return the lazy lower or upper bound, respectively
  - SCIPvarCompareActiveAndNegated() and SCIPvarCompActiveAndNegated() in pub_var.h for comparing variables
    negated, active or fixed the same way
  - SCIPparseVars() in scip.h; parses variable information (in cip format) out of a string
  - SCIPgetNFixedonesSetppc() and SCIPgetNFixedzerosSetppc() in cons_setppc.{h,c}; these methods returns
    current (local) number of variables fixed to one/zero in the given setppc constraint
  - SCIPgetVarConflictlengthScore(), SCIPgetVarAvgConflictlength(), SCIPgetAvgConflictlengthScore() and their pendants for the current run
  - added function SCIPvarsGetProbvarBinary() in pub_var.h; gets active, fixed, or multi-aggregated problem variables of
    binary variables and corresponding negated status

### Interfaces to external software

- LP Interfaces:
  - heavily revised Mosek interface
  - new interface to QSopt due to Daniel Espinoza
  - First version of LP interfaces to Gurobi and QSopt
  - Major performance improvements in LP interfaces to Clp, Mosek and SoPlex

- External Software:
  - adjusted interface to ZIMPL (reader_zpl.{c,h} for ZIMPL version 2.10; this interface should also work with older ZIMPL versions
  - Adjusted interface to Zimpl version 3.0.0
  - added first version of an interface to Ipopt (only QCP, no deletion of vars/cons allowed; nlpi_ipopt.(h|c))

- SCIP Interfaces:
  - On http://code.google.com/p/python-zibopt/source/checkout you find a beta
    version of a python interface to SCIP implemented by Ryan J. O'Neil.

### Changed parameters

- removed parameter `constraints/and/initiallp` since it is not needed anymore;
- set parameter `constraints/and/sepafreq` default value to 1
- display character of oneopt heuristic changed to `b`

### New parameters

- `branching/relpscost/advanced/conflenscore`, default value 0.001
- `constraints/and/aggrlinearization` in cons_and.c, aggregated version of the linearization
- `constraints/and/enforcecuts` in cons_and.c, should cuts be separated during LP enforcing?
- `constraints/and/presolusehashing` in cons_and.c, should pairwise presolving use hashing?, default TRUE
- `constraints/countsols/sollimit` in cons_countsols.c, counting stops, if the given number of solutions were found (-1: no limit)
- `constraints/xor/presolusehashing` in cons_xor.c, should pairwise presolving use hashing?, default TRUE
- `heuristics/oneopt/duringroot`, default value TRUE

Build system
------------

### Makefile

- extend Makefile to link against Ipopt if `IPOPT=true` is set

Fixed bugs
----------

- fixed wrong use of pointer in lp.c
- fixed bug with array dimension not reset to zero when array is freed in pseudoobj propagator
- fixed bug with enforcement of pseudo solutions: if pseudo solution is choosen because LP hit a limit, it has to be
  enforced in any case
- fixed potential bug in coloring example: SCIPcreateChild() is now given an estimate in terms of the transformed
  problem by SCIPgetLocalTransEstimate(), no longer the estimated original problem value. Also clarified this in the
  comments for SCIPcreateChild()
- fixed compiler warning `warning: dereferencing type-punned pointer will break strict-aliasing rules` which resuts in
  scip-crashes with gcc version 4.4.0
- adjusted assert in var.c
- fixed bug in SCIPvarGetActiveRepresentatives() in var.c
- fixed bug with objective limit in lp.c: previously the infinity value of SCIP was used as default - now the value of
  LPI is used. In the earlier version in many cases the problems where never infeasible.
- added and adjusted some asserts, initialized some values
- increased the numerical stability of coefficient tightening for Big M formulations
- fixed bug with incorrect pseudo activities when objective of a variable switches sign in linear constraint handler
- fixed bug with empty constraints in several writing routines
- fixed `GGT-Kaibel-Bug` in var.c, prop_pseudoobj.c and cons_varbound.c that occured while computing new values using
  infinity values

- Bounds:
  - fixed bug in coefficient tightening with infinite bounds
  - fixed bug in solve.c: in case lowerbound >= upperbound, SCIPsolveIsStopped() returned `SCIP_STATUS_GAPLIMIT`

- Nodes:
  - fixed bug in SCIPsolveNode() concerning the case that the time limit was hit while solving the LP relaxation of a
    subproblem which is already an LP (branching on pseudo solution is not possible)
  - fixed bug in vbc tools concerning of marking probing nodes
  - fixed bug in solve.c with nodes which are marked to be repropagated while enforcement

- Variables:
  - fixed possible infinite loop while multiaggregating a variable in var.c
  - fixed bug in SCIPgetSolVals() similar to SCIPgetSolVal(): try to get original variables of transformed ones if the
    solution lives in original space

- Pricing:
  - fixed potential bug: restarts are now only done if no active pricers exist
  - fixed bug in SCIPlpSolveAndEval(): if fastmip and pricers enabled and objlimit was reached but CPLEX did not perform
    the final pivot step in order to exceed the objlimit, do one additional simplex step with pricing strategy steepest
    edge, if this doesn't suffice, turn off fastmip temporarily and solve again. Also consider solstat of the new
    solution.
  - fixed bug with invalid pseudo solution (lower bound was always >= 0) when using pricing.
  - fixed bug in SCIPfreeProb() in scip.c: all pricers are deactivated now

- Memory:
  - now frees debug memory
  - fixed bug with exponential complexity for reallocating memory in SCIPvarGetActiveRepresentatives() in var.c
  - fixed casting of void* pointers in memory.h for C++, adjusted the same for C in memory.h and due to that adjusted all
    header files(set whole files in extern `C`) and cpp-files(removed unnecessary extern `C` lines)
  - removed memory leak in connection with freeing branch and bound nodes: focusnode was not freed if both children could
    be cut off due to bounding

- Reading and Writing:
  - corrected bug in reader_lp.c: earlier read bounds were thrown away (implementation was not conforming to standard)
  - fixed bug in reader_lp.c with respect to constraint and variable names which start with two or more dots `..`
  - fixed bug in all readers w.r.t. SCIPgetProbvarLinearSum()
  - fixed bug in reader_mps.c with respect to corrupted files
  - fixed bug in reader_mps.c with respect to writing transformed problems
  - changed wrong writing of mps files due to constraints without any name
  - fixed a bug during reading debug solution file
  - fixed bug in case of reading an objective function in opb format with multiple occurrences of the same variable
  - fixed bug in case of reading an objective function in lp format with multiple occurrences of the same variable
  - fixed a wrong fix of a reading bug, which was in reality a writing bug in MPS format; integer variables in mps format
    without bounds are binary variables, if the bound of an integer variable is infinity you have to write this bound

- Separation:
  - fixed bug in sepa_cmir.c, sepa_mcf.c and sepa_flowcover.c: sol different to LP solution is now separated
  - corrected two asserts in sepa_redcost.c (reduced costs can be negative for fixed variables: qsopt uses this)
  - fixed bug in sepa_zerohalf.c; replacement of own sorting functions by template functions was incorrect
  - fixed bug in var.c, cons_knapsack.c and sepa_flowcover.c: variable bounds corresponding to implication are not
    generated if coefficient is large, variable bounds with large coefficients are ignored for construction of knapsack
    and snf relaxations
  - fixed bug in sepa_impliedbound.c concerning redundant implications

- Cuts:
  - fixed bug in sepa_cmir.c concerning uninitialized mksetcoefs (if MIR-cut generation is aborted because the aggregated
    constraint is empty or contains too many nonzero elements mksetcoefs is invalid)
  - interrupts optimization process if a node will be cutoff, which allows the solution
  - fixed bug in sepa_impliedbounds.c and sepa_intobj.c: if separating a sol, this sol is now also given to SCIPaddCut()
    so that the efficacy of the cut is now computed correctly
  - fixed bug in solve.c caused by integer overflow due to setting the number of cuts to INT_MAX

- Presolving:
  - fixed wrong result in check.awk, if infeasible problems are stopped in presolving
  - fixed exponential calculation of solution values during check of original solution, therefore changed
    SCIPvarGetActiveRepresentatives() in var.c and flattened all multiaggregated vars at the end of presolving in
    exitPresolve()
  - fixed bug with wrong abort criterion in presolving
  - fixed bug in presol.c caused by not reseting presolver-wasdelayed status
  - fixed bug in SCIPconsSetInitial() that occurred in pairwise presolving: add or delete constraint in initconss when
    changing the initial flag

- Constraints:
  - fixed bug in cons.c caused by not resetting conshdlr data after restart
  - fixed memory error in cons_countsols.c
  - fixed assert in cons_and.c method SCIP_DECL_CONSINITSOL(consInitsolAnd)
  - fixed bug in cons_countsols.c we respect to warning message that `The current parameter setting might cause ...`

- Knapsack Constraint Handler:
  - fixed wrong assert in cons_knapsack.c and handled a special this case in simplifyInequalities()
  - fixed some bugs in simplifyInequalities() in cons_knapsack.c
  - fixed bug in mergeMultiples() in cons_knapsack.c
  - adjusted ConsData and ConsHdlrData in cons_knapsack.c
  - fixed compiler warning caused by no initialization of two integer in cons_knapsack.c
  - fixed bug in cons_knapsack.c caused by having a multi-aggregated variable in a knapsack constraint, now applyFixing is
    able to resolve a binary multi-aggregation with integral values

- Linear Constraint Handler:
  - fixed infinity loop in simplify inequalities in cons_linear.c
  - fixed bug in cons_linear.c: do not select variable as slack variable for multiaggregation in convertLongEquality if it
    has been marked as not-multiaggregable
  - fixed bug in cons_linear.c: also do not multiaggregate variables in dual preproccessing if it has been marked as
    not-multiaggregable
  - fixed bug in cons_linear.c: slight decrease of epsilon in order to make sure that scaled coefficients are really
    integral
  - fixed bug in chgRhs() and chgLhs() of cons_linear.c: after changing lhs or rhs of a constraints lhs <= rhs has to be
    satisfied without numerical tolerances

- Heuristics:
  - added and changed some SCIPisStopped() calls in several heuristics
  - fixed bug in oneopt heuritic with start solution which has become infeasible due to global bound changes

- Interfaces:
  - corrected several bugs in the Clp-interface concerning return values
  - fixed potential interface bug: time limits of 0.0 are not anymore passed to the LP solver, which may have caused
    errors

@page RN11 Release notes for SCIP 1.1

@section RN110 SCIP 1.1.0
*************************

Features
--------

- SCIP can now count integer feasible solutions for IPs/CIPs (without continuous variables) (see SCIPcount())
- check.awk now uses TeX package supertabular which supports automatic pagebreak
- struct `SCIP_Stat` has now two additional variables: `nprobboundchgs`, `nprobholechgs`; these are used to fix the domain
  reduction counts in sepa.c, cons.c, branch.c and prop.c; this means, that now the domain reduction counts are reduced
  by those domain reduceds which are preformed during probing
- added capabilities to flatten the (multi)-aggregation graph of variables
- pseudoobj propagator now also propagates the global lower (dual) bound
- new heuristic DINS (distance induced neighborhood search by Ghosh)

- Output:
  - SCIP can now output a picture of the constraint matrix in PPM format.
  - output of real values is now done with 15 digits after the decimal point
  - Extended the capabilities of SCIP to output problems in different formats (LP, MPS, CIP, ...). You can output the original and
    transformed problem. Furthermore, generic names can be given to the variables and constraints.
  - The feasibility test for solutions at the end of the execution now outputs more useful information.
    This made some changes in the interface of constraint handlers necessary.

- Presolving:
  - added predefined settings file presolving/aggressive.set
  - new presolver boundshift (presol_boundshift.{c,h}); this presolver is currently turned off with default parameter setting

- Constraints:
  - linear constraint handler now detects continuous variables that are implicit integer in dual presolve
  - replaced some old sorting methods in cons_knapsack.c, heur_octane.c, sepa_flowcover.c and presol_probing.c through
    SCIPsort...() interfaces, adjusted misc.{c,h} and pub_misc.h for these changes
  - cons_countsols.c is now able to store the collected solution if required
  - added first version of SOS type 1 constraint handler (cons_sos1.{c,h})
  - added first version of SOS type 2 constraint handler (cons_sos2.{c,h})
  - less aggressive scaling in linear constraint handler presolve to improve numerics
  - added first version of constraint handler cons_countsols.{c,h}

- Reader:
  - added ccg-reader (weighted column connectivity graph)
  - added reader for pseudo-Boolean problems (reader_opb.{c,h})
  - the ZPL reader is now able to pass a starting solution to SCIP
  - the MPS reader is now able to write a problem in MPS format
  - the ZIMPL reader now understands SOS type 1 and 2 constraints
  - the LP reader reads SOS constraints of type 1 and 2
  - the MPS reader reads the SOS section (but cannot yet handle `MARKERS`)

- LPI:
  - The SoPlex LPI can now write basis files.
  - revised lpi_clp.cpp (many small changes, in particular writing and reading of bases)
  - added FASTMIP settings in lpi_clp.cpp that try to improve the performance of Clp as much as possible

- Cuts and Separation:
  - the c-MIR separator now also tries to get rid of implicit integer variables by aggregation
  - allow cut selection based on support of inequality in orthogonality computation
  - disabled zerohalf cuts by default
  - adjusted all predefined settings files, e.g., `settings/cuts/fast.set`, such that they are consistent wrt removed,
    added and changed parameter values of scip.
  - New cutting plane separator MCF (beta version).
  - new separator sepa_zerohalf.{c,h}; separates {0,1/2}-Cuts according to Caprara and Fischetti

Performance improvements
------------------------

- heavily decreased the usage of SCIPisStopped(), which costs system time
- small performance improvement of c-MIR aggregation heuristic
- reworked strong branching in lpi_clp.cpp (scaling works now, bounds can be trusted)

- Constraints:
  - The preprocessing has been revised. It now applies bound computations in a numerically more stable way. The pairwise
    comparison of linear, logicor, and setppc constraints has been improved.
  - better branching in SOS1/SOS2 constraints
  - fixed performance bug with large number of unnamed constraints that will kill the name hash table (now, unnamed
    constraints are not put into the hash table)

- Cuts and Separation:
  - improved the performance of SCIPcalcMIR() and SCIPcalcStrongCG() by exploiting sparsity
  - improved performance of SCIPvarGetLPSol(), which affects many parts of the code, in particular Gomory and strong CG cuts
  - do not calculate MIR and StrongCG cut aggregations if number of nonzeros in aggregated row is too large

- Presolving:
  - improved pairwise presolving in cons_linear.c: reduced cache misses, reduced number of SCIPisStopped() calls and
    included detecting of redundant constraints with hash table in advance
  - tighter memory limits in knapsack presolve lifting procedure to avoid overly expensive presolving
  - included detecting of redundant constraints with hash table in advance in cons_logicor.c and limit other pairwise
    presolving
  - included detecting of redundant constraints with hash table in advance in cons_setppc.c and limit other pairwise
    presolving
  - limit pairwise presolving in cons_linear.c

Examples and applications
-------------------------

- Added an example for the graph coloring problem in `examples/Coloring`, showing the usage of column generation.
- added SOS2 example
- extended TSP example

Interface changes
-----------------

### New and changed callbacks

- New callback method SCIP_DECL_READERWRITE(x) in type_reader.h; this method is called to write a problem to file
  stream in the format the reader stands for; useful for writing the transformed problem in LP or MPS format. Hence,
  also SCIPincludeReader() has changed.
- The callback \ref CONSCHECK (SCIP_DECL_CONSCHECK()) in the constraint handlers now has a new parameter `printreason` that tells
  a constraint handler to output the reason for a possible infeasibility of the solution to be checked using
  SCIPinfoMessage(). Have a look at one of the constraint handlers implemented in SCIP to see how it works. This
  methodology makes it possible to output the reason of a violation in human readable form, for instance, for the check
  at the end of a SCIP run, where the obtained best solution is checked against the original formulation.\n This change
  often has little effect on C-implementations, since this parameter can be safely ignored with respect to the
  correctness of the code. The corresponding C++ method scip::ObjConshdlr::scip_check(), however, has to be extended
  and will not compile otherwise.
- added new LPI pricing option `SCIP_PRICING_LPIDEFAULT`, such that every LP interface can set the default pricing
  strategy on its own (`auto` is not useful for this, because for CPLEX, for example, SCIP seems to be worse with `auto`
  then with `steepest edge`)
- Added user pointer to callback methods of hash table, see pub_misc.h.

### Deleted and changed API methods

- SCIPgetVarRedcost() now returns 0 for variables that have been aggregated out or removed in presolving.
  reduced cost in case of infeasible LPs)
- new parameter `maxfrac` for SCIPcalcStrongCG()
- new parameter `maxmksetcoefs` for SCIPcalcMIR() and SCIPcalcStrongCG() methods
- new parameter `conshdlrname` in SCIPincludeLinconsUpgrade()

- Problem:
  - new parameters `extension` in SCIPreadProb() defining a desired file format or `NULL` if file extension should be use
  - New parameters `extension` and `genericnames` in SCIPprintTransProblem(), SCIPprintOrigProblem(),
    SCIPwriteOrigProblem(), and SCIPwriteTransProblem() defining the requested format or `NULL` for default CIP format
    and using generic names for the variables and constraints. Examples are
    - SCIPprintTransProblem(scip, NULL, NULL, TRUE) displays the transformed problem in CIP format with
      generic variables and constraint names
    - SCIPprintOrigProblem(scip, NULL, `lp`, FALSE) displays the original problem in LP format with
      original variables and constraint names.

- Sorting:
  - expand sorttpl.c by some parameters
  - changed some names for sorting methods
  - replaced sorting methods SCIPbsort...() by faster (quicksort/shellsort) algorithms SCIPsort...() Note that the order
    of the parameters has been changed to simplify the template code in sorttpl.c!

- Checking:
  - SCIPcheckSolOrig() is restructured. The last two parameters have changed. They are now bools indicating
    whether the reason for the violation should be printed to the standard output and whether all violations should be
    printed. This reflects the changes in the constraint handlers above, which allow the automation of the feasibility
    test. The pointers to store the constraint handler or constraint are not needed anymore.
  - the parameter list of the method SCIPcheckCons() (scip.h) has changed; the new advatage is, that SCIP can print the
    reason for the violation of a constraint as for as the constraint handler supports that
  - the parameter list of the method scip_check() (objconshdlr.h) has an additional parameter `printreason` see for
    explanation the previous point

### New API functions

- LPI now has a function SCIPlpiGetSolverPointer() that returns a solver dependent pointer. This can be used to directly
  access the LP solver.  This should, of course, only be used by people that know exactly what they are doing.
- added capabilities to avoid multi-aggregation of a single variable by setting a corresponding flag (SCIPmarkDoNotMultaggrVar())
- SCIPgetProbvarLinearSum()
- SCIPgetResultantAnd() which returns the resultant variable of an `and` constraint
- SCIPchgChildPrio() to change the node selection priority of the given child
- SCIPconsGetPos()
- SCIPrepropagateNode() to mark a node for repropagation
- SCIPcount() (in cons_countsols.h) for counting all feasible solution of a given CIP
- SCIPcreateRootDialog() (in dialog_default.h) which creates a root dialog
- SCIPgetVectorEfficacyNorm()
- SCIPseparateRelaxedKnapsack() in cons_knapsack.h
- SCIPgetCutoffdepth() which returns the depth of first node in active path that is marked being cutoff
- SCIPflattenVarAggregationGraph()
- SCIPclockGetLastTime()
- SCIPcalcHashtableSize() to get a reasonable hash table size
- SCIPgetVarFarkasCoef() and SCIPgetColFarkasCoef() to get the farkas coefficient of a variable (analogon of
- SCIPgetRepropdepth() to get the depth of first node in active path that has to be propagated again
- SCIPmajorVersion(), SCIPminorVersion() and SCIPtechVersion() returning the corresponding version

- Read, Write and Print:
  - SCIPprintSysError() which encapsulates the strerror_r calls, the NO_STRERROR_R flag switches between the use
    of strerror_r and strerror inside
  - SCIPsnprintf() safe version of snprintf (and sprintf)
  - SCIPreaderCanRead() and SCIPreaderCanWrite() in pub_reader.h, these return TRUE if the corresponding
    reader is capable to read or write, respectively
  - SCIPwriteOrigProblem(), e.g., SCIPwriteOrigProblem(scip, `orig.lp`, NULL, FALSE) prints the original
    problem in LP format in the file `orig.lp`
  - SCIPwriteTransProblem(), e.g., SCIPwriteTransProblem(scip, NULL, NULL, FALSE) displays the transformed problem in CIP format

- Heuristics:
  - SCIPcutGenerationHeuristicCmir() in sepa_cmir.h
  - SCIPheurGetTimingmask() and SCIPheurSetTimingmask()

- Sorting:
  - added some downwards-sorting methods
  - SCIPbsortInd()
  - SCIPsortedvecInsert...(), SCIPsortedvecInsertDown...(), SCIPsortedvecDelPos...(),
    SCIPsortedvecDelPosDown...(), SCIPsortedvecFind...() and SCIPsortedvecFindDown...() to manage sorted vectors or
    groups of vectors of various data types that are sorted w.r.t. the first vector

### Command line interface

- advanced reading and writing dialog in interactive shell

### Interfaces to external software

- Many changes in the SoPlex interface: The current one is tailored towards SoPlex 1.4 (aka 1.3.3). All SoPlex functions
  (where applicable) should now have an exception handling. The Bugfix for adding columns has been moved to SoPlex.  One
  can use ROW representation. Reading/writing of a basis has been implemented.

### Changed parameters

- changed default frequency parameters for RINS, Local Branching, Crossover and Mutation heuristic This should not
  change the performance but happened just for consistency reasons
- changed parameter default values for the priority of presolver `dualfix` and `inttobinary`
- removed parameter `separating/cmir/maxtestdeltaroot`
- new value `l` for parameter `lp/pricing`, which is the new default

### New parameters

- `constraints/and/linearize` to enable linearization of all <and> constraints (in presolving),
- `constraints/and/initiallp` to turn on, off, or `auto` that the LP relaxation of the AND constraints are in the initial LP;
- `constraints/countsols/collect` to enable the storing of the solutions; default value FALSE;
- `constraints/indicator/addCoupling` to enable generation of relaxation
- `constraints/indicator/branchIndicators` to decide whether it is branched on indicator constraints in enforcing
- `constraints/indicator/genLogicor` to decide whether logicor constraints instead of cuts are generated
- `constraints/indicator/sepaAlternativeLP` to decide whether separation takes place using the alternative LP
- `constraints/linear/aggregatevariables` to search for aggregations in equations in the presolving step
- `constraints/linear/dualpresolving` to disable dual presolving step in the linear constraint handler; default value is TRUE
- `constraints/linear/simplifyinequalities` to enable a simplification step for inequalities; default value is set to FALSE = disabled
- `constraints/linear/upgrade/binpack` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/eqknapsack` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/invarknapsack` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/knapsack` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/logicor` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/setppc` to enable or disable the linear upgrading process
- `constraints/linear/upgrade/varbound` to enable or disable the linear upgrading process
- `constraints/linear/presolusehashing` to use hashing comparison in cons_linear.c; default value is TRUE
- `constraints/logicor/presolusehashing` to use hashing comparison in cons_logicor.c; default value is TRUE
- `constraints/setppc/presolusehashing` to use hashing comparison in cons_setppc.c; default value is TRUE
- `constraints/SOS1/branchNonzeros` to decide whether SOS1 constraint with largest number of nonzero variables is picked for branching
- `constraints/SOS1/branchSOS` to enable or disable branching on SOS1 constraints
- `heuristics/feaspump/beforecuts` to allow the feaspump to be called before cut separation
- `heuristics/mutation/minimprove`
- `presol/donotmultaggr` which disables multiaggregation for all variables of the problem
- `separating/cmir/densityoffset` to allow for more c-MIR cuts on small models
- `separating/orthofunc` to choose function for scalar product computation in orthogonality test

Testing
-------

- updated mmm.{test,solu}, mittelmann.{test,solu}, miplib3.solu, miplib.solu, shortmiplib.test and added
  mittelmann_current.test, mittelmann_old.test
- added test scripts for testing counting (make testcount)
- removed tag make testpre (useless without corresponding scripts)
- added tag testcount (make testcount); this allows for testing counting problem
- replaced tcsh by bash and gawk by awk in all check scripts to achieve higher compatibility

Build system
------------

### Makefile

- added `make/make.project` as default make include for external projects using SCIP
- added possibility to compile shared libraries in makefiles (and added `make/make.linux.x86.gnu.opt-shared`)
- replaced <string> by <cstring> in all C++-interfaces to get `strlen()` included (gcc-4.3 gave an error)
- Moved -rpath option for ld to linux-specific Makefiles.
- Re-activated readline library on darwin/ppc.

- Flags:
  - added in all `make/make.*` `GMP_FLAGS` and `GMP_LDFLAGS`
  - new flag GMP with values (`auto`, `true and `false`); in case of `auto` the library gmp is linked if ZIMPL is
    included
  - adapted all makefiles of the examples accordingly

- LP:
  - modified makefiles to accept ZIMPLOPT and LPSOPT flags (with values `opt` or `dbg` and default being `opt`), and
    removed `LPS=spxdbg` and `LPS=clpdbg`
  - added target spx132 for SoPlex version 1.3.2

Fixed bugs
----------

- fixed CTRL-C if NO_SIGACTION is set (e.g., for MinGW)
- added checks whether a plugin (handler) has already been included to avoid later complications e.g. with parameters.
- fixed bug with wrong `tightened` return value of some of the change bounds methods
- forced full propagation in presolving -> this fixes a bug that implied that variable locks became inconsistent
- replaced calls to perror() by SCIP error message using strerror(errno); this avoids problems with the error output
  stream
- fixed bug in method SCIPgetProbvarLinearSum()
- fixed bug with errors occurring in sub-MIPs. Search is only aborted in dbg mode, in opt mode a warning will be printed
- fixed bug in tclique-graph datastructure concerning insertion of edges into nonempty graph
- corrected bug in SCIPtreeBranchVar() (tree.c): several comparison functions needed a `feas`.
- fixed bug in SCIPtightenVarLb/Ub() in scip.c concering forcing a bound change (bound improvement is checked now)
- improved stage checking for bound computation
- fixed usage of command test for string comparison in check-scripts (now compatible with ubuntu)
- replaced sprintf and snprintf by SCIPsnprintf() fixed potential bug with overlong strings
- corrected bug in the case when soplex threw an exception in autopricing
- fixed bug in SCIPvarGetOrigvarSum() concerning the corner case the a negated variable has no parent variable in
  original problem

- Aggregation:
  - avoid aggregation of implicit integers with fractional aggregation scalars
  - fixed bug in aggregateActiveIntVars(): If a < 0, multiply a*x + b*y == c by -1 (algo for finding initial solution does
    only work for a > 0).
  - avoiding aggregation that removes information about implicitly integer variables (removes bug)
  - fixed bug with exponential running times due to complicated recursive multi-aggregation
  - corrected bug in var.c occuring during applying boundchanges in varUpdateAggregationBounds method

- Constraints:
  - fixed bug that a missing CONSTRANS in constraint handler leads to `NULL` pointer as constraint data for the copied
    constraints instead of pointer copies of the consdata (as explained in the constraint handler `HowTo`)
  - fixed bugs in second part of consdataTightenCoefs(): Removed min/maxleftactisinfinity (definition was not correct),
    fixed calculation of min/maxleftactivity and removed asserts concerning whether all redundant vars were deleted (led
    to different behavior in debug and opt mod).
  - fixed typo in documentation: default value for `dynamic` parameter is FALSE for all constraint handlers!
  - fixed bug in preprocessing of SOS2 constraints (cons_sos2.c)
  - fixed bug in cons_countsols.c concerning variable locking
  - fixed bug in cons_varbounds.c, concerning SCIPaddVarVlb() and SCIPaddVarVub()
  - fixed bug in applyFixings() in cons_varbound.c concerning tightening the bound of a variable left in a redundant
    constraint (bound change is forced now)

- Heuristics:
  - fixed bug with useless objective cutoff in LNS heuristics
  - removed bug for values greater than (-)infinity, heur_shifting.c, heur_intshifting.c, heur_rounding.c, heur_oneopt.c
  - fixed bug with errors occurring in heuristic LPs. In opt mode a warning will be printed, abort in dbg mode

- Linear Constraints:
  - fixed bug with wrong update of activities in linear constraints after global upper bound changes
  - fixed bug in preprocessConstraintPairs() in cons_linear.c concerning updating the flags of the constraint that stayes
    in the problem (nonredundant information were lost before)
  - fixed bug in cons_linear.c caused by comparing two infinity values during checking of using variable as slackvariable
  - removed bug for rhs/lhs greater than (-)infinity, cons_linear.c
  - removed bug caused by hashcomparison for non-sorted constraints, cons_linear.c
  - fixed bugs with wrong presolving due to cancellation in (res-)activities in cons_linear.c
  - removed BOUNDSCALETOL adjustment in cons_linear.c. This fixes bug with slightly infeasible variable fixings in
    presolving; reliable resactivities should make the BOUNDSCALETOL relaxation redundant.
  - removed `epsilontic` bug in cons_linear.c due to adjusting left/right hand side in applyfixing
  - fixed bug with multi-aggregated variables in cons_logicor: instead of fixing them, a linear constraint will be created
  - corrected bug in cons_linear.c:applyFixings() [if variable was fixed to infinity the rhs/lhs were wrong]
  - fixed bugs in pairwise presolving of cons_linear.c concerning deletion of upgraded constraints and inconsistent update
    of nchgsides in case of coefsequal and coefsnegated
  - fixed false assert and corrected a bug caused by deleting a constraint on `firstchanged` position in pairwise
    presolving with hashing in cons_linear.c

- LP:
  - fixed handling of unbounded variables with 0 objective in SCIPlpGetModifiedPseudo[Proved]Objval() (lp.c)
  - fixed bug with uncatched LPSOLSTAT after hitting a time or iteration limit
  - corrected bug in SCIPlpGetState() if the LP is empty
  - fixed bug in SCIPlpSolveAndEval(): added extra simplex step if objlimit reached, fastmip and pricers enabled in order
    to get dual solution for pricing.
  - weakened two too strong asserts in lp.c concerning the LP result OBJLIMIT
  - fixed bug in SCIPlpSolveAndEval(): allow more than one extra simplex step for getting an objlimit exceeding solution
    with fastmip

- Memory:
  - corrected invalid memory access in tcliqueIsEdge: added check whether node1 has no neighbors (tclique_graph.c)
  - removed memory leak detected with the help of coverity in dialog.c
  - fixed bug with memory reallocation in SCIPgetProbvarLinearSum()
  - tried to fix memory leak in dialog.c occuring from different versions of the readline/history libraries
  - removed possible memory leak in objdialog.cpp

- Numerical:
  - fixed numerical issue in linear constraint propagation: need slightly more aggressive tightening such that probing
    does not choose a wrong value for fixing inside an epsilon interval
  - fixed numerical bug in dual presolving of linear constraint handler
  - avoid fixing variables to infinity in order to get rid of numerical inconsistencies in the original model

- Objective:
  - added handling of the case of roundable variables with 0 objective in presol_dualfix.c
  - fixed bug with writing the MIP relaxation to a file concerning the objective function; in case the original objective
    function is requested, the transformed objective function gets re-transformed (scaling, offset)
  - fixed bug with wrong objective sense output for transformed problem. The transformed problem is always a minimization
    problem!
  - fixed bug with objective scaling after restart

- Reading:
  - fixed bug with reading empty lines in TSP example
  - fixed bug with non-conformal parameter name in reader_ppm
  - fixed infinite loop in LP file reader if a line exceeds the character limit
  - fixed bug in reader_ppm while appending strings for output file
  - fixed some `SCIP_RETCODE` bugs in reader_fix.c, reader_sol.c, reader_sos.c and reader_zpl.c
  - fixed docu in type_reader.h
  - fixed bug with multi-aggregated variables which are de facto aggregated or fixed after flattening the aggregation tree
  - fixed bug with bound changes of variables in modifiable constraints during full dual presolving of linear conshdlr
  - increased compiler compatibility for C++ wrapper classed by adding extern `C` in obj*.cpp files and changing strlen
    calls to std::strlen

- Separation:
  - corrected bug in priceAndCutLoop(): separation was aborted if domain reduction was applied
  - fixed bug in sepa_mir.c: size of testeddeltas-array was too small
  - corrected imlementation of SCIPlpiGetBasisInd() in lpi_clp.cpp (this fixes the bug that almost no Gomory cuts are
    found with Clp).

- Sorting:
  - fixed bugs in sorttpl.c: fixed wrong arraysize in shellsort; in case an has at most one element, then no sorting is
    applied
  - fixed wrong if condition for function call in sorttpl.c
  - fixed obvious bug in linear constraint data sorting. Most part of the code assumed pure index sorting, but in fact, it
    was sorted by variable type as first criterion and index as second criterion.

@page RN10 Release notes for SCIP 1.0

@section RN100 SCIP 1.0.0
*************************

Features
--------

- SCIP now has a couple of specialized settings, all called scip_*.set
- SCIP is now compatible to the Exception branch of SoPlex
- if possible, objective function is scaled to make objective value integral with gcd 1
- slightly modified automatic constraint aging strategy
- new C templates disp_xxx.h and dialog_xxx.h and C++ wrapper classes objdisp.h and objdialog.h, respectively
- modified reader `sol`, st. files which where created via typing the order of commands `set log *.sol`,
  `disp sol var -`, `set log cplex.log` in Cplex can now be read
- new dummy LP interface `lpi_none.c`; useful for running SCIP without a LP solver

- Presolver:
  - modified probing presolver to do multiple cycles if called in subsequent runs
  - changed sort algorithm in probing presolver

- Node selection:
  - new node selection rule `estimate` (best estimate search)
  - new node selection rule `hybridestim`

- Documentation:
  - the doxygen documentation now has HowTo's for all plugin types
  - the doxygen documentation now contains a FAQ
  - the documentation has now a TAB Modules; there you can find list of available constraint handles, presolvers,
    propagators, lpi interfaces, file readers and so on

- Time:
  - time limit is now forwarded to lp solving algorithm
  - presolving, cut separation, primal heuristics and strong branching now better respect time limit

- Heuristics:
  - best estimate search is now used in all large neighborhood search heuristics
  - new improvement heuristic `oneopt`
  - new heuristic `actconsdiving` following an idea of John Chinneck

- Separation and Cuts:
  - modified cut selection code
  - cut conversion into linear constraints after a restart now works better
  - added flow cover separator
  - gomory cuts are now also separated for integral slack variables
  - less aggressive in Gomory cut separation
  - strong CG cuts are now also separated for integral slack variables

Performance improvements
------------------------

- greatly improved performance of LP file reader by replacing string copies with pointer copies
- removed performance bottleneck with non-bfs based node selectors and large leaf queues at the cost of a small memory
  overhead (2 ints per node in the leaf queue); this improves performance quite a bit on instances that take a large
  number of branching nodes
- improved performance of linear constraint propagation by delaying some floor/ceil calculations
- improved performance of clique cut separator

Interface changes
-----------------

### New and changed callbacks

- new callback method SCIPdialogFree()

### Deleted and changed API methods

- slightly modified bound substitution heuristic in SCIPcalcMIR() and SCIPcalcStrongCG()
- slightly less conservative in numerics for SCIPmakeRowIntegral()
- linear and knapsack constraint handler may now deal with coefficients of value zero
- new parameter `maxbounddist` for SCIPincludeSepa() and constructor ObjSepa()
- new parameter `restart` for method SCIPfreeSolve()
- calling SCIPwriteLP() is now possible in Solved Stage
- SCIPwrite{LP,MIP} may no longer be called after solving, since the LP data structures may not be valid
- All functions SCIP<datatype>Param() got a new parameter `isadvanced`.
  This does not influence the performance of SCIP, but the position of the parameter in the settings menu.
  Hence, if you do not care about this, you can assign any value to it.
  You should add the corresponding flag to the SCIP<datatype>Param() calls in your own source code.

- Version:
  - modified `SCIP_SUBVERSION` to be a number instead of a string (to be able to use `SCIP_SUBVERSION >= ...`)
  - SCIPsubversion() now returns an int instead of a const char*

- Tree and Nodes:
  - new parameter `estimate` for SCIPcreateChild() giving an estimate for value of best feasible solution in the subtree to
    be created. One possibility is to use SCIPgetLocalOrigEstimate() for this value.
  - removed method SCIPnodeGetPriority()
  - removed parameter `lowestboundfirst` from SCIPincludeNodesel()

- Branching:
  - removed parameter `branchdir` from SCIPbranchVar()
  - new parameters `leftchild`, `eqchild` and `downchild` for SCIPbranchVar()
  - SCIPgetVarStrongbranch() now also returns lperror == TRUE if the solving process should be stopped, e.g., because of a
    time limit

- Variable tightening:
  - replaced methods SCIPvarGetClosestVlb() and SCIPvarGetClosestVub() from pub_var.h by new methods
    SCIPgetVarClosestVlb() and SCIPgetVarClosestVlb() in scip.h
  - new parameter `force` for SCIPtightenVarLb() and SCIPtightenVarUb()

### New API functions

- SCIPreadSol()
- SCIPwriteMIP()
- SCIPgetLocalOrigEstimate() and SCIPgetLocalTransEstimate()
- SCIPisStopped()
- SCIProwIsInGlobalCutpool()
- SCIPresetParams()
- SCIPgetVarRedcost()
- SCIPtightenVarLbGlobal() and SCIPtightenVarUbGlobal()
- SCIPsepaGetMaxbounddist()
- SCIPboundchgGetNewbound(), SCIPboundchgGetVar(), SCIPboundchgGetBoundchgtype(),
  SCIPboundchgGetBoundtype(), SCIPboundchgIsRedundant(), SCIPdomchgGetNBoundchgs(), SCIPdomchgGetBoundchg()
- SCIPnodeUpdateLowerboundLP()
- SCIPcalcNodeselPriority()
- SCIPnodeGetEstimate()
- SCIPnodeGetDomchg()
- SCIPgetRootNode() (in combination with SCIPcutoffNode(), this allows the immediate finishing of the optimization)

### Command line interface

- default dialog menu now includes the commands `set default` and `display parameters`
- added option to write node LP and MIP relaxations to LP file from interactive shell

### Changed parameters

- parameters are now separated into basic and advanced, the latter ones have been moved to extra submenus
- priority parameters are now restricted to be in [INT_MIN/4,INT_MAX/4] to avoid overflow errors in comparison methods
- increased priority of `estimate` node selector, such that this is the new default node selector
- changed meaning of parameter setting `nodeselection/childsel = l`; old meaning is now called `r`
- changed default value of `conflict/maxvarsfac` to 0.1
- changed default value of `conflict/useprop` to TRUE
- changed default value of `conflict/useinflp` to TRUE
- changed default value of `conflict/usepseudo` to TRUE
- changed default value of `conflict/maxlploops` to 2
- changed default value of `conflict/lpiterations` to 10
- changed default value of `conflict/interconss` to -1
- changed default value of `conflict/reconvlevels` to -1
- changed default value of `conflict/settlelocal` to FALSE
- changed default value of `constraints/linear/propfreq` to 1
- changed default values of `heuristics/*diving/backtrack` to TRUE
- changed default value of `nodeselection/restartdfs/stdpriority` to 10000
- changed default value of `numerics/boundstreps` to 0.05 in order to avoid very long propagation loops on continuous variables
- changed default value of `presolving/restartfac` to 0.05
- changed default value of `presolving/restartminred` to 0.10
- changed default value of `separating/objparalfac` to 0.01 for performance reasons
- changed default value of global `separating/maxbounddist` to 1.0
- changed default value of `separating/objparalfac` to 0.0001

### New parameters

- `conflict/enable` to globally enable or disable conflict analysis
- `constraints/linear/maxcardbounddist` and `constraints/knapsack/maxcardbounddist`
- `heuristics/*diving/backtrack` to activate 1-level backtracking for most of the diving heuristics
- `heuristics/feaspump/maxstallloops`
- `nodeselection/childsel` to control the child selection
- `presolving/immrestartfac`
- `separating/*/maxbounddist` to have individual maxbounddist parameters per separator
- `separating/clique/backtrackfreq` to speed up clique cut separation in heuristic fashion
- `separating/redcost/continuous`

Build system
------------

### Makefile

- added version numbers to library files (There will be a softlink generated in the lib/ and bin/ directories without
  version number that point to the latest compiled version.)
- added .exe extension to binaries of MinGW
- removed the `.static` extension associated to the LINK variable from the Makefile system (If you want to build
  makefiles for shared library generation, use the OPT variable. For example, you could create a makefile
  `make/make.linux.x86.gnu.opt-shared` and compile it with `make OPT=opt-shared`.)

- Defaults and Options:
  - modified the default LP solver to be SoPlex instead of CPLEX
  - added `LPS=none` for compiling SCIP without a LP solver
  - made `ZIMPL=true` the default; if you do not want to include ZIMPL support, call `make ZIMPL=false`

Fixed bugs
----------

- fixed bug in rowScale() concerning deletion of almost zero coefficients
- weakened assert in primal.c in order to avoid numerical troubles
- fixed bug with too long variable names
- fixed bug with strange user descriptions of plugins
- changed position of some asserts to prevent segmentation faults
- SCIPgetAvgPseudocostCount() and SCIPgetAvgPseudocostCountCurrentRun() now return the average over all integer
  variables instead of all variables, since pseudo costs are not recorded for continuous variables
- fixed wrong sorting of plugins with priorities close to INT_MIN or INT_MAX
- replaced `line` by `read` in Makefile, since `line` is non-standard
- fixed bug with branching rules that produce only one child with no changes to the problem
- fixed bug that external relaxator is not reset appropriately for a new problem instance
- removed wrong assert in function paramWrite()
- fixed bug with uninitialized in check.awk
- fixed bug in ZIMPL file reader for multiple occurrences of a single variable in the objective function
- fixed bug with deleting variables from the transformed problem that are contained in the implication graph
- fixed bug in root reduced cost fixing propagator that leads to an empty domain for a variable as a proof of optimality
  of the current incumbent
- fixed bug with fractional coefficients of binary variables in cont --> impl int upgrading

- Solution:
  - fixed bug with aggregated variables in debug solution test
  - now it is possible to add original solutions
  - fixed bugs with SCIPgetBestsol() returning `NULL` after a restart with user objective limit
  - fixed wrong status code in presence of user objective limit and a feasible solution that is not better than the limit

- Bounds:
  - fixed bug with wrong bound changes of loose variables
  - changed wrong assert in SCIPnodeAddBoundinfer()
  - fixed bug in variable bounds search and insertion method
  - fixed bug regarding modifying bounds in original problem if negated original variables exist
  - fixed bug with multiple pending bound changes on some variable

- Separator:
  - fixed bug in integer objective separator with restarts
  - fixed bug in integer objective separator with dynamic columns

- Cuts:
  - fixed bug that cut age was not reset to zero for violated cuts
  - fixed bug in SCIPcutpoolAddNewRow() concerning update of minidx and maxidx of added row
  - fixed numerical bug in rowScaling of lp.c, which possibly cut off feasible solutions
  - significantly improved performance of c-MIR and Gomory cuts by caching closest VLB and VUB info

- LP:
  - fixed numerical buf with slightly different LP optimum after resolving due to probing/diving
  - fixed bug in cmir and flowcover separator with variables which are currently not in the LP
  - fixed bug with LP size management in probing if column generation is used
  - fixed bug in LP file reader with row names identical to section keywords
  - fixed potential bugs due to errors in resolving the LP after diving or probing
  - fixed potential bugs in SCIPpriceLoop() and priceAndCutLoop(), st. now all LP solution stati are handled appropriately
  - fixed potential bug with non-existent LP in SCIPwrite{LP,MIP}

- Constraint handler:
  - removed wrong assert in bounddisjunction constraint enforcement
  - fixed numerical bug in propagator of varbound constraint handler
  - fixed bug in variable bound constraint handler with changing bounds on multi-aggregated variables
  - fixed bug in linear constraint handler: only tight cuts are transformed into linear constraints after restart
  - fixed bug in bounddisjunction constraint handler with propagation of multi-aggregated variables
  - fixed bug with numerics in linear constraint handler due to non-representable `BOUNDSCALETOL`
  - fixed bug with almost integral multi-aggregation in dual presolve of linear constraint handler
  - fixed bug with numerics in update of min/maxactivity in linear constraint handler

- Heuristics:
  - fixed bug in intshifting and oneopt heuristic with variables which are currently not in the LP
  - fixed bug with primal heuristics reducing the cutoff bound such that the current node is cut off
  - fixed bug in oneopt heuristic: must not be called on pseudo nodes if continuous variables are present

@page RN09 Release notes for SCIP 0.9

@section RN090 SCIP 0.9.0
*************************

Features
--------

- the EXITSOL callback of the plugins is now called before the LP and the global cut pool are freed

- Primal Heuristics:
  - new primal heuristics `rens`, `mutation` and `veclendiving`
  - primal heuristics that run before the node is solved now know already whether the LP will be solved at the current
    node or not

- Heuristics:
  - new heuristic `intshifting` (ID character `i`)
  - in the root node of the very first run, heuristics with timing `AFTERNODELPNODE`, `AFTERLPPLUNGE`, `AFTERPSEUDONODE`, and
    `AFTERPSEUDOPLUNGE` are now called before the enforcement of the constraint handlers, in particular before the branching
    rules; in this way, the branching rule can already benefit from a tighter primal bound
  - if a heuristic found a better solution after the LP loop (and in particular the `AFTERNODE` heuristics in the root node
    of the very first run, see above), domain propagation and LP solving is triggered again; this allows for additional
    reduced cost tightening and other dual propagations
  - slightly modified `crossover` and `rins` heuristics
  - improved performance of intdiving heuristic
  - improved heuristic `octane` and `shifting`
  - slightly modified rens and localbranching heuristics
  - modified guided diving heuristic such that it equals the original version of the heuristic (i.e., round in direction of the
    current incumbent solution instead of the average of all primal feasible solutions)
  - ID character for intdiving heuristic is now `I`

- Separation and Cuts:
  - c-MIR cuts try now to scale the cut to integral values; however, cuts are still generated if this fails
  - hard-coded relative objective gain to consider a separation loop to be stalling is now changed from 1e-3 to 1e-4,
    which means that separation is not aborted as early as before
  - modified c-MIR cut separator to more closely resemble the original version of Marchand and Wolsey

- Constraint:
  - possibility of SAT-like restarts after a number of conflict constraints have been found
  - improved presolving of and, or and xor constraints
  - implemented additional dual presolving in linear constraint handler
  - slightly modified presolving of varbound constraint handler

Interface changes
-----------------

### New and changed callbacks

- new parameter `solinfeasible` for constraint handler callback methods `ENFOLP`  and `ENFOPS`
- replaced callback parameter `inlploop` and `inplunging` by `heurtiming` in `SCIP_DECL_HEUREXEC`
- slightly changed the meaning of the result codes returned by external relaxators: if they modify the LP or tighten
  bounds of variables, they are not automatically be called again (it is assumed that they already made use of these
  changes). They are only called again, if they returned `SCIP_SUSPENDED` or if some other plugin modified the LP.

### Deleted and changed API methods

- new parameter `escapecommand` for SCIPdialoghdlrAddHistory()
- removed method SCIPgetVarData(); use SCIPvarGetData() from pub_var.h instead
- new calls SCIPgetLPBInvCol() and SCIPgetLPBInvACol() to access the basis inverse and simplex tableau columnwise
- new parameter `ndomredsfound` of SCIPpropagateProbing()
- new parameters `fixintegralrhs`, `maxfrac`, `mksetcoefs` and `fracnotinrange` in SCIPcalcMIR()
- modified SCIPfixVar() such that in problem creation stage it will change the bounds as requested even if the fixing
  value is outside of the current bounds
- replaced parameters `pseudonodes`, `duringplunging`, `duringlploop` and `afternode` by `timingmask` in
  SCIPincludeHeur() and constructor of ObjHeur() class use the following table to translate old settings into the new
  timingmask:

| PSEUDONODES | DURINGPLUNGING | DURINGLPLOOP | AFTERNODE | timingmask                                                    |
|-------------|----------------|--------------|-----------|---------------------------------------------------------------|
| FALSE       | FALSE          | FALSE        | FALSE     | SCIP_HEURTIMING_BEFORENODE                                    |
| TRUE        | FALSE          | FALSE        | FALSE     | SCIP_HEURTIMING_BEFORENODE                                    |
| FALSE       | TRUE           | FALSE        | FALSE     | SCIP_HEURTIMING_BEFORENODE                                    |
| TRUE        | TRUE           | FALSE        | FALSE     | SCIP_HEURTIMING_BEFORENODE                                    |
| FALSE       | FALSE          | TRUE         | FALSE     | SCIP_HEURTIMING_BEFORENODE \| SCIP_HEURTIMING_DURINGLPLOOP    |
| TRUE        | FALSE          | TRUE         | FALSE     | SCIP_HEURTIMING_BEFORENODE \| SCIP_HEURTIMING_DURINGLPLOOP    |
| FALSE       | TRUE           | TRUE         | FALSE     | SCIP_HEURTIMING_BEFORENODE \| SCIP_HEURTIMING_DURINGLPLOOP    |
| TRUE        | TRUE           | TRUE         | FALSE     | SCIP_HEURTIMING_BEFORENODE \| SCIP_HEURTIMING_DURINGLPLOOP    |
| FALSE       | FALSE          | FALSE        | TRUE      | SCIP_HEURTIMING_AFTERLPPLUNGE                                 |
| TRUE        | FALSE          | FALSE        | TRUE      | SCIP_HEURTIMING_AFTERPLUNGE                                   |
| FALSE       | TRUE           | FALSE        | TRUE      | SCIP_HEURTIMING_AFTERLPNODE                                   |
| TRUE        | TRUE           | FALSE        | TRUE      | SCIP_HEURTIMING_AFTERNODE                                     |
| FALSE       | FALSE          | TRUE         | TRUE      | SCIP_HEURTIMING_AFTERLPPLUNGE \| SCIP_HEURTIMING_DURINGLPLOOP |
| TRUE        | FALSE          | TRUE         | TRUE      | SCIP_HEURTIMING_AFTERPLUNGE \| SCIP_HEURTIMING_DURINGLPLOOP   |
| FALSE       | TRUE           | TRUE         | TRUE      | SCIP_HEURTIMING_AFTERLPNODE \| SCIP_HEURTIMING_DURINGLPLOOP   |
| TRUE        | TRUE           | TRUE         | TRUE      | SCIP_HEURTIMING_AFTERNODE \| SCIP_HEURTIMING_DURINGLPLOOP     |

- Constraints:
  - renamed all occurences of `removeable` by the correct English word `removable`: SCIPconsIsRemovable(),
    SCIPsetConsRemovable(), SCIPvarIsRemovable(), SCIPcolIsRemovable(), SCIProwIsRemovable()
  - new parameter `sticktonode` in SCIPcreateCons(), SCIPcreateConsAnd(), SCIPcreateConsBounddisjunction(),
    SCIPcreateConsKnapsack(), SCIPcreateConsLinear(), SCIPcreateConsLogicor(), SCIPcreateConsOr(),
    SCIPcreateConsVarbound(), SCIPcreateConsXor(), SCIPcreateConsSetpart(), SCIPcreateConsSetpack(),
    SCIPcreateConsSetcover(): usually, you should set this to FALSE; if you want to add constraints as node markers with
    node data and, e.g., use the `activate` and `deactivate` callbacks to get informed about the activation and
    deactivation of the node, you should set this flag to TRUE in order to make sure, that the constraint will always be
    associated to the node and not moved to a more global node if this would be possible
  - slightly changed semantics of SCIPaddConsNode() and SCIPaddConsLocal(), such that a constraint which is added to the
    root node now enters the global problem (and is still existing after a restart)

### New API functions

- SCIPgetVerbLevel()
- SCIPescapeString()
- SCIPgetGlobalCutpool(), SCIPgetPoolCuts(), SCIPcutpoolGetCuts(), SCIPcutGetRow() and SCIPcutGetAge()
- SCIPconsGetNLocksPos() and SCIPconsGetNLocksNeg()

### Command line interface

- command shell now understands escape characters `\``,`'` and `\` which makes it possible to read in files with spaces in the
  name

### Interfaces to external software

- updated XPress interface to XPress-MP 17 (contributed by Michael Perregaard)

### Changed parameters

- changed default value of `heuristics/octane/usediffray` to FALSE
- removed parameter `heuristics/octane/usediffbwray`
- renamed parameter `heuristics/octane/useavgray` to `heuristics/octane/useavgnbray`
- changed default value of `heuristics/rens/binarybounds` to TRUE
- changed default value of `heuristics/octane/freq` to -1 in order to deactivate Octane
- parameter `heuristics/feaspump/maxsols` is now strict, i.e., if n solutions were already found, the feasibility pump
  starts to work only if `maxsols <= n`, instead of `maxsols < n`

### New parameters

- `conflict/restartnum` and `conflict/restartfac`
- `heuristics/octane/useavgray`
- `heuristics/octane/useavgwgtray`
- `limits/absgap` to define an absolute gap limit
- `separating/cmir/aggrtol`
- `separating/cmir/densityscore`
- `separating/cmir/fixintegralrhs`
- `separating/maxruns`
- `presolving/restartminred` which forbids another restart if the last one was not successful enough
- `propagating/abortoncutoff`
- `reading/zplreader/changedir` to control behavior of path switching of ZIMPL file reader
- `reading/zplreader/parameters` to pass additional parameters to ZIMPL

Build system
------------

### Makefile

- added ncurses to the readline entries in the `make/make.*` files
- added quotes to sed expressions in Makefile (needed under Windows)
- modified makefiles for Windows/Intel
- added automatic query script in the Makefile for soft-link names

Fixed bugs
----------

- fixed bug with string pointer copy instead of string content duplication in constructors of C++ wrapper classes
- fixed bug in CPLEX interface with basis access methods that dualopt has to be called for more error status codes
- fixed bug with inserting two variable bounds of the same type on the same variable with the same bounding variable but
  with different sign of coefficient (e.g., `x <= 10*z + 5` and `x <= -5*z + 10`); in previous version, one of the two was
  removed, although both have a useful meaning; now, we keep both and detect a stronger global bound in the implication graph presolving
- objective function is now also checked for integrality after problem transformation (fixed a bug that a solution which
  was generated between transformation and presolving for an integral objective function did not reduce the cutoff bound by one)
- fixed a bug with cmir cut efficacy calculation (however, on my first tests, the performance reduced slightly!)
- fixed bug that SCIPvarGetAvgSol() always returned the upper bound (affected guided diving heuristic)
- fixed bug in RENS, RINS, Local Branching, Crossover and Mutation heuristics with wrong variable-subvariable assignments
- fixed bug in infeasible/bound-exceeding LP conflict analysis if the bounds were relaxed in diving (happens in intshifting heuristic)

- Separation:
  - fixed bug with adding constraints with `INITIAL=true` and separating them afterwards, which lead to a second addition of
    the constraint's relaxation in the child node
  - separation LPs are now immediately resolved after a bound change was generated by a cut separator; before, the
    separation round was prematurely aborted, which means that a separation round limit was sometimes reached very quickly
    and some of the separators were not even called a single time

- Cmir Cut Separator:
  - too large deltas are now also rejected in c-MIR cut separation
  - fixed bug in cmir cut separator, that 8*delta was not tried
  - fixed bug in cmir cut separator with wrong sign of slack in row score function
  - fixed bug in cmir cut separator with weights fixed to zero, thus making the current aggregation invalid
  - fixed bug in cmir cut separator with wrong calculation of cut efficacies

@page RN08 Release notes for SCIP 0.8

@section RN082 SCIP 0.8.2
*************************

Features
--------

- additional flag `delay` for pricers
- new propagator `rootredcost` which applies reduced cost fixing at the root node whenever a best new primal solution was found
- new separator `redcost` which replaces the internal reduced cost strengthening

- LP:
  - extensions to the LP are kept even if the LP is not solved at the current node; however, if the LP turned out to be
    numerically instable, the extensions of the current node are still discarded
  - added removal of bound-redundant rows from the LP during root node LP solving loop
  - new display column `lpobj`

- Constraints:
  - slightly changed priorities of constraint handlers
  - now, conflict constraints are also created if they were generated in strong branching or diving with insertion depth
    equal to the current depth
  - new constraint handler `bounddisjunction`

- Readers:
  - renamed `sol` file reader to `fix` file reader (reads partial solution files and fixes variables to the given values)
  - added `sol` file reader which reads complete solution files and adds the solutions to the solution pool
  - LP and MPS file readers are now able to parse lazy constraints and user cuts sections

- Presolver:
  - knapsack presolver now generates cliques in the clique table (this essentially solves `neos1.mps`)
  - new presolver `inttobinary`

- Heuristics:
  - new primal heuristic `shifting`
  - diving heuristics abort earlier (did not come back in reasonable time on `fast0507`)

Interface changes
-----------------

- new solution status code `SCIP_STATUS_STALLNODELIMIT`

### New and changed callbacks

- slightly modified semantics of the `CONSINITLP` callback in the constraint handlers

### Deleted and changed API methods

- methods SCIPisLbBetter() and SCIPisUbBetter() have an additional parameter and slightly different meaning (they now
  compare the bound improvement *relatively* to the width of the domain and the bound itself)
- SCIPgetNSols() now returns an int instead of `SCIP_Longint`
- method SCIPreadProb() does not call SCIPfreeTransform() anymore; file readers that want to extend the existing problem
  must now call SCIPfreeTransform() themselves before modifying the original problem
- method SCIPgetBinvarRepresentative() can now also be called in problem creation stage
- additional parameter `maxpricerounds` in method SCIPsolveProbingLPWithPricing()
- changed name of method SCIPpresolGetNVarTypes() to SCIPpresolGetNChgVarTypes()
- method SCIPsplitFilenames() now treats both versions of slashes, `/` and `\`, as directory delimiters (under MinGW and
  CygWin, both are valid; so, we cannot treat file names anymore where the other slash is used as a regular character)

- Constraints:
  - marking a constraint to be `initial` now means in addition, that if the constraint is added to a local node it will
    enter the LP at the time the node is first processed, even if parameters forbid separation at this node
  - changed name of method SCIPconshdlrGetNVarTypes() to SCIPconshdlrGetNChgVarTypes()

- Conflicts:
  - method SCIPgetNConflictClausesFound() renamed to SCIPgetNConflictConssFound()
  - method SCIPgetNConflictClausesFoundNode() renamed to SCIPgetNConflictConssFoundNode()
  - method SCIPgetNConflictClausesApplied() renamed to SCIPgetNConflictConssApplied()

### New API functions

- SCIPsolveProbingLPWithPricing()
- SCIPchgVarLbRoot() and SCIPchgVarUbRoot()
- SCIPinRepropagation()
- SCIPaddDialogInputLine() and SCIPaddDialogHistoryLine()
- SCIPtransformProb() to create the transformed problem; enables the user, e.g., to add primal solutions before the presolving begins
- SCIPcreateSolCopy()
- SCIPareSolsEqual()

- Getters:
  - SCIPgetRowKnapsack(), SCIPgetRowLinear(), SCIPgetRowLogicor(), SCIPgetRowSetppc(), and
    SCIPgetRowVarbound() for obtaining the linear relaxation of a corresponding constraint
  - SCIPgetLhsVarbound(), SCIPgetRhsVarbound(), SCIPgetVarVarbound(), SCIPgetVbdvarVarbound(), and
    SCIPgetVbdcoefVarbound()
  - SCIPgetLPRootObjval(), SCIPgetLPRootColumnObjval() and SCIPgetLPRootLooseObjval()
  - SCIPcolGetMinPrimsol() and SCIPcolGetMaxPrimsol()
  - SCIPgetFocusDepth()

- Score:
  - SCIPgetAvgPseudocostScore()
  - SCIPgetAvgPseudocostScoreCurrentRun()
  - SCIPgetAvgConflictScore()
  - SCIPgetAvgConflictScoreCurrentRun()
  - SCIPgetAvgInferenceScore()
  - SCIPgetAvgInferenceScoreCurrentRun()
  - SCIPgetAvgCutoffScore()
  - SCIPgetAvgCutoffScoreCurrentRun()

- Reduced Cost:
  - SCIPgetColRedcost()
  - SCIPvarGetRootRedcost()

- Variables:
  - SCIPgetNVarsAnd() and SCIPgetVarsAnd()
  - SCIPgetWeightsKnapsack(), SCIPgetNVarsKnapsack(), SCIPgetVarsKnapsack() and SCIPgetWeightsKnapsack()
  - SCIPgetNVarsLinear(), SCIPgetVarsLinear() and SCIPgetValsLinear()
  - SCIPgetNVarsOr() and SCIPgetVarsOr()
  - SCIPgetNVarsXor() and SCIPgetVarsXor()

### Command line interface

- command line syntax changed to support batch modus without piping stdin with `<` or `|` operators
- advanced command line syntax:
  - `-l <logfile>  `: copy output into log file
  - `-q            `: suppress screen messages
  - `-s <settings> `: load parameter settings (.set) file
  - `-f <problem>  `: load and solve problem file
  - `-b <batchfile>`: load and execute dialog command batch file (can be used multiple times)
  - `-c <command>  `: execute single line of dialog commands (can be used multiple times)

### Interfaces to external software

### Changed parameters

- removed parameter `propagating/redcostfreq`, because reduced cost strengthening is now an external separator plugin
- removed parameter `conflict/maxunfixed`
- parameter `conflict/maxclauses` renamed to `conflict/maxconss`
- parameter `conflict/interclauses` renamed to `conflict/interconss`
- parameter `conflict/reconvclauses` replaced by `conflict/reconvlevels`
- parameter `conflict/uselp` replaced by `conflict/useinflp` and `conflict/useboundlp`
- changed default value of `constraints/obsoleteage` to -1
- changed default value of `branching/relpscost/conflictweight` to 0.01
- changed default value of `branching/relpscost/inferenceweight` to 0.0001
- changed default value of `branching/relpscost/cutoffweight` to 0.0001
- in bfs node selector, parameter `minplungedepth` is now stronger than `maxplungedepth` if they conflict

### New parameters

- `constraints/linear/separateall`
- `conflict/lpiterations`
- `conflict/keepreprop`
- `branching/relpscost/conflictweight`, `branching/relpscost/inferenceweight`,
  `branching/relpscost/cutoffweight` and `branching/relpscost/pscostweight`
- `conflict/settlelocal`
- `conflict/depthscorefac`
- `limits/stallnodes`

Build system
------------

### Makefile

- removed ncurses and pthread libraries from the Makefile; pthread is now only linked if CPLEX is used

Fixed bugs
----------

- fixed numerical bug in SCIPrealToRational() [thanks to Anders Schack-Nielsen]
- fixed bug in crossover heuristic with negative timelimit
- removed bug in conflict analysis with wrong redundancy check
- fixed bug that unexpected end of stdin (Ctrl-D or piped-in file without `quit` command) gives a segmentation fault
- fixed bug with inconsistent data structures after a global bound was changed at a local subproblem and the local
  bounds are not contained anymore in the new global bounds
- fixed dependency generation in example Makefiles

- Knapsack:
  - fixed bug in knapsack presolving with redundancy check after applyFixings() [thanks to Anders Schack-Nielsen]
  - fixed bug in knapsack separator with empty initial covers
  - fixed bug in knapsack constraint disaggregation that may lead to acceptance of infeasible solutions
  - fixed bug in knapsack constraint handler where a modifiable constraint may be declared redundant

- LP:
  - fixed bug with missing LP size updates after pricing or cut separation in probing [thanks to Marc Nuenkesser]
  - fixed bug in CPLEX interface with getting basis information after the LP was modified and restored
  - fixed bug with updating LP size in probing
  - fixed bug that SCIPgetLPSolstat() returns a valid status code even if the LP was not yet constructed for the current node

- Variables:
  - fixed bug with invalid lazy updates after a restart where the LP is not solved again (e.g., due to all variables being fixed)
  - fixed bugs resulting from inactive general integer variables being member of the variable bounds array of a variable
  - fixed bug in updatePseudocost() with wrong lpgain distribution on multiple branching variables [thanks to Anders Schack-Nielsen]
  - fixed bug in objconshdlr.h where member variable scip_maxprerounds_ was declared as an `SCIP_Bool` instead of an int
  - branching on nearly-integral variables is now avoided in relpscost branching, which lead to a numerical assertion

- Implication:
  - fixed bug with adding implications that fix the implication variable to the opposite value (due to the bug, it was
    returned that the whole problem is infeasible)
  - removed wrong assert in varRemoveImplicsVbs()

- Cliques:
  - fixed bug in SCIPcliqueSearchVar() [thanks to Anders Schack-Nielsen]
  - fixed bug in SCIPcliqueAddVar() [thanks to Anders Schack-Nielsen]

- Readers:
  - fixed bug in MPS file reader with `OBJSENSE`
  - fixed bug in LP reader with potentially uninitialized pointers [thanks to Martin Mueller]

- Constraints:
  - it is now possible to branch on constraints without the risk of going into an infinite loop, because constraints marked as `initial`
    will be put to the LP relaxation (of the child nodes) even if separation is prohibited by the parameter settings
  - fixed bug that locally valid varbound constraints produce VLB/VUB entries [thanks to Anders Schack-Nielsen]

@section RN081 SCIP 0.8.1
*************************

Features
--------

- improved performance of the priority queue in conflict analysis
- slightly modified restartdfs node selector

- Presolving:
  - new presolver `implics` to find bound changes and aggregations out of the implication graph
  - modified probing order in probing presolver

- Constraints:
  - changed handling of added constraints in separation calls
  - modified bookkeeping of locally added and disabled constraints such that the order of enabling and disabling constraints stays the same
  - logic or constraint handler now adds implications on clauses with 2 literals to the implication graph
  - and/or constraint handlers now add implications to the implication graph
  - xor constraint handler now uses stronger LP relaxation without auxiliary variable for xor constraint with 2 operands

- Heuristics:
  - added preliminary version of `intdiving` heuristic (disabled in default settings)
  - added crossover heuristic

- Readers:
  - LP file reader now accepts the keyword `Integer` for defining the start of the integer variables section
  - new file reader for (partial) solutions

Examples and applications
-------------------------

- added two small pricer examples (for C and C++)
- updated example code (s.t. it compiles again)

Interface changes
-----------------

### New and changed callbacks

- callback method `CONSSEPA` of constraint handler was split into two methods `CONSSEPALP` and `CONSSEPASOL`
- callback method `SEPAEXEC` of separator was split into two methods `SEPAEXECLP` and `SEPAEXECSOL`

### Deleted and changed API methods

- replaced method SCIPsepaWasDelayed() by SCIPsepaWasLPDelayed() and SCIPsepaWasSolDelayed()
- additional parameter `sol` for methods SCIPaddCut(), SCIPgetCutEfficacy() and SCIPisCutEfficacious()
- additional parameter `sol` for method SCIPseparateKnapsackCover()
- primal solutions may now contain values marked to be unknown (value is `SCIP_UNKNOWN`); unknown values don't contribute
  to the objective value of the solution; an unknown solution value should be treated as an arbitrary value in the
  variable's bounds, e.g., in the calculation of the feasibility of a constraint, a value inside the variable's bounds
  should be selected that makes the constraint as feasible as possible
- new parameter `printzeros` for methods SCIPprintSol(), SCIPprintTransSol(), SCIPprintBestSol() and SCIPprintBestTransSol()

- Constraints:
  - replaced method SCIPconshdlrWasSeparationDelayed() by two methods SCIPconshdlrWasLPSeparationDelayed() and
    SCIPconshdlrWasSolSeparationDelayed()
  - renamed method SCIPgetNGlobalConss() to SCIPgetNConss()

### New API functions

- SCIPgetCuts()
- SCIPgetVarConflictScore() and SCIPgetVarConflictScoreCurrentRun()
- SCIPvarSetData()
- SCIPcreateUnknownSol()
- SCIPgetNConflictClausesFoundNode()
- SCIPvarSetDelorigData(), SCIPvarSetTransData() and SCIPvarSetDeltransData()
- SCIPvarHasBinaryImplic()
- SCIPgetFixedVars() and SCIPgetNFixedVars()
- SCIPgetConss(), SCIPgetNOrigConss() and SCIPgetOrigConss()
- SCIPsepaGetNConssFound() and SCIPsepaGetNDomredsFound()
- SCIPconstructLP() to force constructing the LP of the current node
- SCIPisLPConstructed()

### Command line interface

- added `write statistics` command to default user dialogs

### Changed parameters

- modified meaning of parameter `presolving/probing/maxtotaluseless`
- heuristics with `freq = 0` and `freqofs > 0` are now called in depth level freqofs instead of being called in the root
  node
- added some parameters in local branching and RINS heuristic
- new parameter values `p`rimal simplex and `d`ual simplex in `lp/initalgorithm` and `lp/resolvealgorithm`

### New parameters

- `branching/inference/conflictweight`

Build system
------------

### Makefile

- included version number in binary file name
- tried to make the code Windows compatible

Fixed bugs
----------

- also removed history_length, if `NO_REMOVE_HISTORY` is defined to support older versions of the readline library
- hopefully fixed bug with wrong path slash `/` under Windows
- fixed bug with aggregating fixed variables

- Implications:
  - fixed bug in transitive implication addition
  - fixed wrong assert with implications that imply a fixed variable
  - removed bug in implication addition

- Readers:
  - fixed bug in ZIMPL model reader with wrong chdir, if .zpl file is in current directory
  - fixed bug in LP file reader with signed values without space between sign and value (e.g. `+2x` instead of `+ 2x`)
  - fixed various bugs in LP file reader
  - fixed bug in LP file reader with explicit zero coefficients

- Numerics:
  - fixed numerics in probing and linear constraint handler (rentacar was detected to be infeasible in presolving)
  - fixed numerics in check method of linear constraint handler
  - fixed bug with numerical error in LP resolve after probing or diving

- Heuristics:
  - fixed bug with calling heuristics in depths smaller than their frequency offset
  - fixed bugs in local branching and RINS heuristic

Known bugs
----------

- if one uses column generation and restarts, a solution that contains variables that are only present in the
  transformed problem (i.e., variables that were generated by a pricer) is not pulled back into the original space
  correctly, since the priced variables have no original counterpart

@section RN080 SCIP 0.8.0
*************************

Features
--------

- adding variable bounds automatically adds the corresponding implication
- changed restart dfs nodeselector to sort leaves by node number instead of node depth to aviod jumping around in the
  search tree after a restart was applied and the current dive ended due to infeasibility
- new Message Handler plugin
- added file reader for LP format
- introduced subversion string
- replaced all abort() calls by SCIPABORT(); this is defined in def.h to be `assert(FALSE)`
- added possibility to disable certain features by using `make USRFLAGS=-DNO_REMOVE_HISTORY`, `make
  USRFLAGS=-DNO_SIGACTION`, `make USRFLAGS=-DNO_RAND_R`, or `make USRFLAGS=-DNO_STRTOK_R`
- improved preprocessing abort criteria
- added zlib support

- Conflict Analysis:
  - conflict clauses are now collected in a conflict store, redundant clauses are eliminated and only the best `conflict/maxclauses`
    clauses are added permanently to the problem; the remaining clauses are only added temporarily, if they can be used for repropagation
  - modified the influence of the depth level in conflict analysis
  - slightly changed LP resolving loop in conflict analysis
  - if CPLEX returns that the LP exceeds the bound and if no additional LP solves are allowed in conflict analysis, we
    have to perform one additional simplex iteration to get the dual solution that actually violates the objective limit

- Constraints:
  - reactivated multiaggregation in cons_linear.c on binary variables again (possible due to bug fix below)
  - improved preprocessing of variable bounds constraints
  - linear constraint handler now catches events of variables after the problem was completely transformed in order to
    avoid the whole bunch of `LOCKSCHANGED` events that are generated at problem transformation stage
  - added redundancy detection for pairs of constraints in setppc constraint handler

- Presolving and Cliques:
  - changed linear constraint presolving s.t. redundant sides are not removed if constraint is an equality
  - new event type `SCIP_EVENTTYPE_PRESOLVEROUND`
  - modified probing presolver to not add implications that are already included in the implication graph and clique table
  - incorporated clique and implication information in knapsack constraint presolving
  - removed transitive clique generation, because this produces way too many cliques

- Heuristics:
  - diving heuristics now apply propagation at each step
  - removed `objfeaspump` heuristic, because the functionality can be achieved by using the `feaspump` heuristic
  - diving heuristics are now applying propagation after each bound change
  - new primal heuristic `octane`
  - slightly changed feaspump heuristic, s.t. after finding a new best solution the target integral solution is modified randomly

- Separation and Cuts:
  - improved debugging for infeasible cuts and propagations, given a primal feasible solution
  - improved knapsack cover separation
  - improved performance of c-MIR separator
  - cut pool is now also separated in root node (to find cuts again that were removed from the LP due to aging)

Interface changes
-----------------

- new event type `SCIP_EVENTTYPE_VARDELETED`
- new event `SCIP_EVENTTYPE_IMPLADDED`
- new event types `SCIP_EVENTTYPE_GLBCHANGED` and `SCIP_EVENTTYPE_GUBCHANGED`

### New and changed callbacks

- new callback parameter `validnode` for the `CONFLICTEXEC` method of conflict handlers, which should be passed to
  SCIPaddConsNode()

### Deleted and changed API methods

- additional parameter `validnode` for SCIPaddConsLocal() and SCIPaddConsNode()
- SCIPhashtableRemove() can now also be called, if the element does not exist in the table
- SCIPhashmapRemove() can now also be called, if the element does not exist in the map
- additional parameter `branchdir` for SCIPbranchVar()
- replaced method SCIPmessage() by SCIPverbMessage() with additional parameter `file`
- put block memory shell and tclique algorithm into separate subdirectories
- new parameter `duringlploop` of SCIPincludeHeur(): heuristics can now run during the price-and-cut loop at a node

### New API functions

- SCIPgetNConflictClausesApplied()
- SCIPgetNConflictClausesApplied()
- SCIPhashtableExists()
- SCIPhashmapExists()
- SCIPnodeGetNumber()
- SCIPsolveProbingLP() to solve the LP in a probing node (enables mixing of propagation and LP solving for diving heuristics)
- SCIProwGetDualfarkas()
- SCIPgetCurrentNode()
- SCIPinterruptSolve()
- SCIPpropagateProbingImplications()
- SCIPgetLPI() which makes all methods in scip/lpi.h available to the user
- SCIPgetRandomInt() and SCIPgetRandomReal()
- SCIPstrtok()
- SCIPheurGetNBestSolsFound()

- Variables:
  - SCIPdelVar()
  - SCIPgetVarStrongbranchLPAge()
  - SCIPvarIsTransformedOrigvar()
  - SCIPvarIsDeleted()

- Messages and IO:
  - SCIPerrorMessage()
  - SCIPwarningMessage()
  - SCIPdialogMessage()
  - SCIPinfoMessage()
  - SCIPsetMessagehdlr()
  - SCIPsetDefaultMessagehdlr()
  - SCIPgetMessagehdlr()
  - new file i/o methods SCIPfopen(), SCIPfclose(), SCIPfprintf(), ... that operate on the data type `SCIPFILE`; these
    methods automatically use zlib methods if the zlib is enabled

- Cliques:
  - SCIPvarGetNCliques()
  - SCIPvarGetCliques()
  - SCIPvarsHaveCommonClique()
  - SCIPvarHasImplic()
  - SCIPcliqueGetNVars()
  - SCIPcliqueGetVars()
  - SCIPcliqueGetValues()
  - SCIPcliqueGetId()
  - SCIPaddClique()
  - SCIPcalcCliquePartition()

- Constraint handler:
  - SCIPgetDualfarkasLinear() of linear constraint handler
  - SCIPgetDualfarkasLogicor() of logicor constraint handler
  - SCIPgetDualfarkasSetppc() of setppc constraint handler
  - SCIPgetDualsolKnapsack() of knapsack constraint handler
  - SCIPgetDualfarkasKnapsack() of knapsack constraint handler
  - SCIPgetDualsolVarbound() of varbound constraint handler
  - SCIPgetDualfarkasVarbound() of varbound constraint handler
  - SCIPconsGetValidDepth()
  - SCIPsetConsInitial()
  - SCIPsetConsSeparated()
  - SCIPsetConsEnforced()
  - SCIPsetConsChecked()
  - SCIPsetConsPropagated()
  - SCIPsetConsLocal()
  - SCIPsetConsDynamic()
  - SCIPsetConsRemoveable()

### Command line interface

- added command `write solution` to default dialog
- added commands `write problem` and `write transproblem` to default dialog

### Changed parameters

- additional setting `SCIP_VERBLEVEL_DIALOG` in `display/verblevel` parameter
- additional LP pricing setting `partial`
- replaced parameter `presolving/restartbdchgs` with parameters `presolving/maxrestarts` and `presolving/restartfac`
- replaced parameter `constraints/linear/maxpresolaggrrounds` with `constraints/linear/maxpresolpairrounds`
- parameters `constraints/agelimit` and `constraints/obsoleteage` now iterprete the value 0 as a dynamic setting
- number of fractional variables included in parameter `separating/maxstallrounds`

- Changed default values:
  - changed default values of `heuristics/*/maxdiveavgquot` and `heuristics/*/maxdiveavgquotnosol` to 0
  - changed default values of `constraints/agelimit` and `constraints/obsoleteage` to 0
  - changed default values of `heuristics/objpscostdiving/maxsols` and `heuristics/rootsoldiving/maxsols` to -1
  - changed default value of `separating/strongcg/maxroundsroot` to 20
  - changed default value of `separating/cmir/maxroundsroot` to 10
  - changed default value of `constraints/linear/maxaggrnormscale` to 0.0, which means to not apply aggregation
  - changed default value of `separating/maxstallrounds` to 5
  - changed default value of `presolving/probing/maxfixings` to 50
  - changed default parameter values to MIP settings:
    + `conflict/useprop` = FALSE
    + `conflict/usepseudo` = FALSE
    + `display/verblevel` = 4
    + `separating/poolfreq` = 0
    + `constraints/linear/sepafreq` = 0
    + `constraints/and/sepafreq` = 0
    + `constraints/conjunction/sepafreq` = 0
    + `constraints/knapsack/sepafreq` = 0
    + `constraints/knapsack/sepacardfreq` = 0
    + `constraints/logicor/sepafreq` = 0
    + `constraints/or/sepafreq` = 0
    + `constraints/setppc/sepafreq` = 0
    + `constraints/varbound/sepafreq` = 0
    + `constraints/xor/sepafreq` = 0
    + `separating/clique/freq` = 0
    + `separating/cmir/freq` = 0
    + `separating/gomory/freq` = 0
    + `separating/impliedbounds/freq` = 0
    + `separating/strongcg/freq` = 0

### New parameters

- `branching/fullstrong/reevalage`
- `conflict/maxclauses`
- `conflict/allowlocal`
- `constraints/knapsack/disaggregation`
- `presolving/probing/maxtotaluseless`
- `separating/cmir/maxfails`, `separating/cmir/maxfailsroot` and `separating/cmir/trynegscaling`

### Data structures

- MAJOR CHANGE: preceeded all data types with `SCIP_`: you may use shell script reptypes_scip.sh to rename the SCIP
  data types in your own source code (But use with care! Create a backup copy of your source first!)

Build system
------------

### Makefile

- modified the Makefile to accept an additional parameter `VERBOSE={true,false}`
- added flags `READLINE=true/false`, `ZLIB=true/false`, `ZIMPL=true/false` to Makefile

Fixed bugs
----------

- fixed minor bugs in debug code of primal.c and sol.c
- variables that are being multiaggregated are now automatically removed from all other variables' variable bound and
  implication arrays; this fixes bugs with methods, that rely on the fact, that the entries in the variable bound and
  implication arrays are active variables only
- aggregations are now always performed in a way, such that the variable of more general type is aggregated (with type
  generality being cont > implint > int > bin); in this way, a binary variable's representant is always binary (which
  was not the case before and resulted in a bug in SCIPgetBinvarRepresentative())
- removed bug in presol_probing.c: the vars of the sorted variables array have to be captured
- fixed bug in the output of solutions with priced variables
- fixed bug in propagation with parameters prop_maxrounds and prop_maxroundsroot
- conflict analysis can now handle errors in LP solving calls
- removed bug in SCIPvarAddVlb() and SCIPvarAddVub() with fractional vlb/vubcoefs
- fixed bug that primal or dual rays might not be available because the wrong solver was used
- included message.o in LPI library, s.t. one can link this library indepentent of SCIP
- fixed bug that if diving heuristic that changes the objective values finds a solution, the cutoff is reinstalled in
  the LP solver (although the objective value has no meaning due to the objective function modification)

- Feasibiltiy:
  - LP primal feasibility for bounds is now defined as absolute measure (was relative to the bound before); this fixes a bug (see alu8_9.mps),
    that an LP with an integral variable fixed to a large value yields an accepted solution with that variable slightly different than the fixed
    value; the integrality feasibility condition is measured with absolute differences, which leads to the fixed integer variable being fractional;
    this leads to an error if branching is performed on this variable
  - fixed bug with redundant self implications that wrongly lead to the detection of infeasibility
  - fixed bug with potential infinite loop if a separator is delayed and the LP is infeasible

- Asserts:
  - removed wrong asserts from lpi_cpx.c
  - removed wrong assertion in varAddImplic()

- Numerics:
  - locally fixed variables are no longer used as branching candidates even if their LP solution value is fractional (due
    to numerical reasons, see above)
  - fixed numerical bug in pseudo objective propagator with only slightly tightened bounds
  - removed bug that an LP might be declared to be solved even if it was marked erroneous due to numerical problems

- Constraint Handlers:
  - fixed bug in linear constraint handler with variables fixed to infinity
  - fixed bug with constraint handlers that can only enforce their constraints by adding cuts, but the maximal number of
    cuts to separate is set to 0; now, cuts that are generated in the constraint enforcement are used in any case
  - fixed bug in knapsack constraint presolving with tightening coefficients and capacity
  - fixed bug with modifiable constraints in linear constraint handler preprocessing
  - fixed bug in linear constraint handler that global activities are not updated after global bound changes

- Separation and Cuts:
  - global bound changes now lead to the removal of redundant implications (such that the asserts in sepa_implbounds.c are now correct)
  - due to usage of variable bounds, SCIPcalcMIR() may return LOOSE variables in the cut -> modified sepa_cmir.c, sepa_gomory.c and
    sepa_strongcg.c to use SCIPcreateEmptyRow() and SCIPaddVarsToRow() instead of SCIPcreateRow() which only works for COLs
  - fixed bug in clique separator that reduced performance
  - increased performance of clique separator by allowing only a certain number of zero-weighted fill ins

@page RN07 Release notes for SCIP 0.7

@section RN079 SCIP 0.7.9
*************************

Features
--------

- aging and cleanup now only remove non-basic columns and basic rows, s.t. resolving can be applied with 0 simplex iterations
- it is now possible to create subnodes in probing and use backtracking to undo probing changes
- bounds of variables are included in the feasibility checks for solutions
- support for barrier algorithm
- changed implementation of automatic minplungedepth and maxplungedepth calculation in bfs node selector

- Presolving:
  - new plugin: probing presolver
  - probing is now also possible in presolving stage
  - it is now possible to interrupt and continue presolving

- Separation and Cuts:
  - new plugin: clique separator for clique cuts with at least 3 elements
  - new plugin: implied bound cuts separator
  - included debugging module to check whether cutting planes cut off the optimal solution

- Branching:
  - changed implementation of reliability value calculation in reliability branching; slightly modified influence of
    maximal total number of strong branching LP iterations in reliability branching
  - changed implementation of maximal strong branching iterations calculation in reliability branching

- Constraints:
  - if verblevel is at least `NORMAL`, an automatical check of the best solution is performed in the original problem, and
    an error message is displayed, if it violates an original constraint
  - due to the new constraint handler `cons_cumulative.{c,h}` SCIP can resource-constraint scheduling problem
  - during probing, propagation of bounds is now always performed in linear constraint handler, ignoring the parameter `tightenboundsfreq`
  - new implementation of the clique graph construction method in clique separator
  - new constraint handler `cons_cumulative.{c,h}`

- Heuristics:
  - new implementation of the feasibility pump heuristic by Timo Berthold (replaces old implementation); old
    implementation is now called `objfeaspump`; parameter names have been changed accordingly
  - diving heuristics now compare their number of LP iterations with the number of node LP iterations instead of the total
    number (including their own) LP iterations
  - modified the automatic objfactor setting of feaspump heuristic to let the objective function have stronger influence

Examples and applications
-------------------------

- added TSP example in `examples/TSP`

Interface changes
-----------------

### New and changed callbacks

- new callback methods `INITSOL` and `EXITSOL` for variable pricers, primal heuristics, conflict handlers, relaxators,
  separators, propagators, event handlers, node selectors and display columns
- callback method `CONFLICTEXEC` of conflict handlers receive additional parameters `dynamic` and `removeable`
- constraint handler callback methods `CONSLOCK` and `CONSUNLOCK` are replaced by a single method `CONSLOCK` with the number
  of locks being positive or negative

### Deleted and changed API methods

- calling SCIPaddCut() with `forcecut=TRUE` will add the cut to the LP even if it is redundant
- SCIPreadProb() does not free the current problem, this is done in SCIPcreateProb() now, which is usually
  called by a problem reader; in this way, a reader can generate `extra information` for the current problem, s.t.  the
  full problem information can be distributed to different files read by different readers
- SCIPgetVarStrongbranch() and SCIPgetVarStrongbranchLast() now have two additional parameters that can be used
  to check, whether the returned values are correct dual bounds
- SCIPgetBinvarRepresentative() now returns the fixed or multi-aggregated variable instead of returning `NULL` or
  aborting with an error message
- SCIPdispDecimal() is replaced by SCIPdispInt() and SCIPdispLongint()
- additional parameter `maxproprounds` in SCIPpropagateProbing()
- changed memory interface (see memory.h), `MEMHDR` is now called `BLKMEM`
- source code was moved into subdirectories: replace includes `scip.h` by `scip/scip.h` and
  `objscip.h` by `objscip/objscip.h`; This should allow a user to have include files of the same name as the ones
  of SCIP, e.g. `tree.h` or `var.h`.
- event handlers are now available as C++ wrapper class
- new flag `afterrelaxation` for primal heuristics

- Solution:
  - removed method SCIPsolGetObj(), use SCIPgetSolOrigObj() or SCIPgetSolTransObj() instead
  - additional parameter `checkbounds` for SCIPtrySol(), SCIPtrySolFree(), SCIPcheckSol()

- Variables:
  - SCIPvarLock(), SCIPvarLockDown(), SCIPvarLockUp(), SCIPvarLockBoth(), SCIPvarUnlock(), SCIPvarUnlockDown(),
    SCIPvarUnlockUp() and SCIPvarUnlockBoth() are replaced by SCIPaddVarLocks() which returns a `RETCODE`
  - SCIPvarGetLbGlobal(), SCIPvarGetUbGlobal(), SCIPvarGetLbLocal() and SCIPvarGetUbLocal() now return the
    corresponding values of the transformed problem or current subproblem even for original problem variables
  - SCIPvarGetProbvar(), SCIPvarGetProbvarBinary() now return the fixed or multi-aggregated variable instead of
    returning `NULL` or aborting with an error message; in SCIPvarGetProbvarBinary(), the fixing of a fixed variable does
    not influence the negation status anymore
  - SCIPvarGetProbvarBound() returns the multi-aggregated variable instead of aborting with an error message
  - SCIPvarGetProbvarSum() does not set *var to `NULL` for fixed variables anymore; it may also return a
    multi-aggregated variable instead of aborting with an error message
  - SCIPaddVarImplication() now also adds variable lower and upper bounds, if the implied variable is non-binary
  - additional parameter `aggregated` in SCIPmultiaggregateVars()

- Constraints:
  - SCIPvarLockDownCons(), SCIPvarLockUpCons(), SCIPvarUnlockDownCons() and SCIPvarUnlockUpCons() are replaced by
    SCIPlockVarCons() and SCIPunlockVarCons() which return a `RETCODE`
  - SCIPlockConsVars() and SCIPunlockConsVars() replaced with method SCIPaddConsLocks()
  - SCIPconshdlrGetNConss() is replaced by SCIPconshdlrGetNActiveConss() (returning the number of active
    constraints); method SCIPconshdlrGetNConss() does now return the total number of existing constraints, active and inactive
  - SCIPconshdlrGetStartNConss() is now called SCIPconshdlrGetStartNActiveConss()
  - SCIPconshdlrGetMaxNConss() is now called SCIPconshdlrGetMaxNActiveConss()
  - SCIPdisableConsNode() is replaced by SCIPdelConsNode()
  - SCIPdisableConsLocal() is replaced by SCIPdelConsLocal()
  - added new parameter `dynamic` to SCIPcreateCons() and all plugin methods SCIPcreateCons...()

### New API functions

- SCIPgetObjNorm()
- SCIPcreateOrigSol()
- SCIPwriteImplicationConflictGraph()
- SCIPinProbing()
- SCIPgetProbName()
- SCIPgetVarNStrongbranchs()
- SCIPcolGetNStrongbranchs()
- SCIPfindSimpleRational()
- SCIPselectSimpleValue()

- Variables:
  - SCIPvarGetLbOriginal()
  - SCIPvarGetUbOriginal()
  - SCIPvarGetImplIds()
  - SCIPvarGetOrigvarSum()

- Constraints:
  - SCIPenableCons()
  - SCIPdisableCons()
  - SCIPenableConsSeparation()
  - SCIPdisableConsSeparation()
  - SCIPconsIsSeparationEnabled()

- Averages:
  - SCIPgetAvgPseudocost()
  - SCIPgetAvgPseudocostCurrentRun()
  - SCIPgetAvgPseudocostCount()
  - SCIPgetAvgPseudocostCountCurrentRun()
  - SCIPgetAvgInferences()
  - SCIPgetAvgInferencesCurrentRun()
  - SCIPgetAvgCutoffs()
  - SCIPgetAvgCutoffsCurrentRun()

- LPs:
  - SCIPisLPSolBasic() to check, whether the current LP solution is basic (i.e. due to a simplex algorithm or barrier with crossover)
  - SCIPgetNPrimalLPs()
  - SCIPgetNPrimalLPIterations()
  - SCIPgetNDualLPs()
  - SCIPgetNDualLPIterations()
  - SCIPgetNBarrierLPs()
  - SCIPgetNBarrierLPIterations()
  - SCIPgetNPrimalResolveLPs()
  - SCIPgetNPrimalResolveLPIterations()
  - SCIPgetNDualResolveLPs()
  - SCIPgetNDualResolveLPIterations()

- Delayed:
  - SCIPsepaIsDelayed()
  - SCIPsepaWasDelayed()
  - SCIPpropIsDelayed()
  - SCIPpropWasDelayed()
  - SCIPpresolIsDelayed()
  - SCIPpresolWasDelayed()
  - SCIPconshdlrIsSeparationDelayed()
  - SCIPconshdlrIsPropagationDelayed()
  - SCIPconshdlrIsPresolvingDelayed()
  - SCIPconshdlrWasSeparationDelayed()
  - SCIPconshdlrWasPropagationDelayed()
  - SCIPconshdlrWasPresolvingDelayed()

### Command line interface

- command line history in interactive shell now only stores useful commands

### Interfaces to external software

- removed storing of dual norms in LPI state of CPLEX interface (too memory consuming)

### Changed parameters

- default frequency offset of fracdiving heuristic changed to 3
- default frequency offset of (new) feaspump heuristic changed to 0
- default frequency offset of objfeaspump heuristic changed to 8
- changed default priority of primal heuristics
- renamed parameter `limits/sol` to `limits/solutions`
- changed default check priority of knapsack constraint handler to -600000
- changed default priority of Gomory cut separator to -1000 (will now be called after constraint handlers!)
- changed default priority of strong CG cut separator to -2000
- changed default priority of cmir cut separator to -3000
- changed default of parameter `lp/pricing` to `s`teepest edge pricing
- default parameter `branching/relpscost/minreliable` changed to 1.0
- default parameter `branching/relpscost/maxlookahead` changed to 8
- default parameter `branching/relpscost/sbiterofs` changed to 100000
- default parameter `heuristics/coefdiving/maxlpiterquot` changed to 0.05
- default parameter `heuristics/fracdiving/maxlpiterquot` changed to 0.05
- default parameter `heuristics/guideddiving/maxlpiterquot` changed to 0.05
- default parameter `heuristics/linesearchdiving/maxlpiterquot` changed to 0.05
- default parameter `heuristics/pscostdiving/maxlpiterquot` changed to 0.05
- default parameter `heuristics/feaspump/freq` changed to 20
- default parameter `heuristics/objfeaspump/freq` changed to 20
- default parameter `heuristics/objpscostdiving/freq` changed to 20
- default parameter `heuristics/rootsoldiving/freq` changed to 20
- default parameter `separating/clique/maxtreenodes` changed to -1

### New parameters

- new parameter delay for presolvers
- new parameter delaypresol for constraint handlers
- `branching/scorefunc`
- `constraints/.../delaypresol`
- `constraints/.../delayprop`
- `constraints/.../delaysepa`
- `conflict/dynamic`
- `conflict/removeable`
- `heuristics/coefdiving/maxlpiterofs`
- `heuristics/feaspump/maxlpiterofs`
- `heuristics/feaspump/maxsols`
- `heuristics/fracdiving/maxlpiterofs`
- `heuristics/guideddiving/maxlpiterofs`
- `heuristics/linesearchdiving/maxlpiterofs`
- `heuristics/objfeaspump/maxlpiterofs`
- `heuristics/objfeaspump/maxsols`
- `heuristics/objpscostdiving/maxlpiterofs`
- `heuristics/objpscostdiving/maxsols`
- `heuristics/pscostdiving/maxlpiterofs`
- `heuristics/rootsoldiving/maxlpiterofs`
- `heuristics/rootsoldiving/maxsols`
- `heuristics/fixandinfer/proprounds` and `heuristics/fixandinfer/minfixings`
- `lp/cleanupcolsroot` and `lp/cleanuprowsroot` to distinguish cleanup settings between root node and other nodes
- `lp/checkstability` to disable stability check of LP solver's result code
- `lp/initalgorithm` and `lp/resolvealgorithm` for switching between simplex and barrier algorithm
- `lp/pricing` to set the pricing strategy used in the LP solver
- `numerics/barrierconvtol` to set the convergence tolerance in the barrier algorithm
- `presolving/.../delay`
- `propagating/.../delay`
- `reading/cnfreader/dynamicconss`
- `reading/mpsreader/dynamicconss`
- `separating/.../delay`

### Data structures

- new possible result `SCIP_DELAYED` for `EXEC` method of separators, presolvers and propagators and `SEPA`, `PROP` and
  `PRESOL` methods of constraint handlers

Fixed bugs
----------

- fixed bug in MPS file reader
- removed bug with applying reduced cost strengthening before pricing in all necessary variables
- negated variables must also be reset in SCIPvarInitSolve()
- fixed documentation of `CONSLOCK`-method (missing parameter `scip` in SCIPaddVarLocks())
- included missing `objrelax.h` in includes of objscip.h
- fixed bug that after a resolve and further preprocessing, existing primal solutions may get corrupted due to
  aggregations or fixings that are possible due to the primal bound (given by the best solution)
- fixed bug with primal bound becoming wrong, if in a prior run the optimal solution was found and the cutoff bound was
  thereby reduced due to further domain propagation w.r.t. the objective function
- fixed bug in SCIPisObjIntegral()
- fixed bug in SCIPprintError() with `file == NULL`
- heuristic's display character is now only shown the first time, the new solution was found
- fixed bug that SCIPreadProb() doesn't discard the transformed problem
- fixed bug with wrong euclidean norm calculation of row, if multiple coefficients for the same variable are added and
  the sorting of the row was delayed with SCIProwDelaySort()
- fixed bug with adding implications: wrong insertion position, if only the lower bound change was present but not the
  upper bound change
- fixed bug in SCIPvarAddImplics() with wrong variable used in varAdjustBd()
- fixed bug in method reduced() of tclique_branch.c with sorting nodes in V

- LP:
  - removed bug with objective norm calculation and column variables not in the LP (pricing)
  - LP error on forced LP resolve (due to 0 unfixed integers) now leads to an error (instead of accepting the pseudo
    solution as feasible)
  - fixed bug in CPLEX LP interface with dual norms

- Presolving:
  - fixed bug that presolving time is not counted to solving time, if presolving is called explicitly with SCIPpresolve()
  - fixed bug where presolving fixings are counted even if the variable was already fixed
  - removed bug with dual presolver, that declared a problem to be unbounded or infeasible, if it could fix a variable to
    infinity even if its objective value is zero
  - fixed bug in knapsack constraint handler that fixed variables are sometimes not removed in presolving

- Numerics:
  - fixed bug with unresolved numerical troubles in LP that don't render the LP useless at the current node
  - fixed numerical bugs in rounding heuristic and rootsoldiving heuristic

- Separator:
  - fixed bugs in separation store with single coefficient cuts that are converted into bound changes
  - at least one cut per separation round is added to the LP to avoid cycling, even if the cut is redundant
  - fixed bug in SCIProwCalcIntegralScalar() with rows consisting of only continuous variables (appeared in gomory cut
    separator on miplib/dcmulti.mps)
  - fixed bug in linear constraint handler's knapsack relaxation separator
  - fixed bugs in intobj separator
  - fixed bug in cmir separator with empty rows
  - fixed bug in implied bound cut separator: only implications between binary variables were generated before

- Constraint Handlers:
  - removed bug in knapsack constraint handler with merging multiple items if more than two items of the same variable
    appear in the constraint
  - removed bug in knapsack constraint handler with merging negated variables of equal weight at the end of the variables' array
  - fixed bug in linear constraint handler with eventdatas, if the original constraint has no variables
  - fixed bug that `CONSLOCK` method of constraint handlers that don't need constraints is not called
  - fixeg bug in setppc constraint handler with pairs of aggregated variables in the same constraint
  - fixed bug with globally deleting constraints, that have attached rows which are therefore not released in exitsol methods

- Conflict analysis:
  - removed conflict analysis of infeasible diving LP if pricing is activated
  - made conflict analysis available in presolving stage (for probing conflicts)

@section RN078 SCIP 0.7.8
*************************

Features
--------

- changed SCIProwCalcIntegralScalar() to a slightly different algorithm
- improved knapsack relaxation in linear constraint handler separator to scale the constraint in order to get integral
  coefficients instead of just rounding down all coefficients
- improved presolving of linear constraint handler: aggregation of two constraints with equal coefficient vector into
  single constraint
- improved presolving of knapsack constraint handler: aggregation of equal or negated variables in same constraint

- Plugins:
  + priority of separators, propagators and presolvers decide whether the plugin is called before the corresponding
    constraint handler methods or after: plugins with nonnegative priorities are called before, plugins with negative
    priorities are called after the constraint handlers
  + new plugin class for relaxators (external relaxations, that can be used in parallel with LP relaxations)
  + if more than one result code applies to a plugin's execution, it should return the one that is higher in the call's
    documentation list

Interface changes
-----------------

- even in optimized mode, the simple functions that are implemented as defines in the include files exist in the
  library, s.t. one can include the include files without `NDEBUG` and use the optimized library

### New and changed callbacks

- new branching rule plugin methods `INITSOL` and `EXITSOL`

### Deleted and changed API methods

- removed SCIPisFeasible(); use !SCIPisFeasNegative() instead
- SCIPisIntegral(), SCIPisFracIntegral(), SCIPfloor(), SCIPceil() and SCIPfrac() don't use the feasibility
  tolerance anymore (default: 1e-06); instead, they are using epsilon (default: 1e-09); instead, for handling
  integrality of a variable `in feasibility tolerances`, new methods SCIPisFeasIntegral(), SCIPisFeasFracIntegral(),
  SCIPfeasFloor(), SCIPfeasCeil() and SCIPfeasFrac() should be used
- in LPI, the semantics of SCIPlpiHasPrimalRay() and SCIPlpiHasDualRay() changed: methods return TRUE, if a ray exists
  and the solver can return it; new methods SCIPlpiExistsPrimalRay() and SCIPlpiExistsDualRay() check whether a ray
  exists without checking, if the solver knows and can return the ray

### New API functions

- SCIPvarIsInLP()
- SCIPgetLPColumnObjval() and SCIPgetLPLooseObjval()
- SCIPcalcIntegralScalar() with arbitrary array of Real values
- SCIPaddCoefKnapsack() in knapsack constraint handler
- SCIPisScalingIntegral() to check, whether the scaling of a value would lead to an integral value, measured
  against epsilon which is also scaled by the same scalar
- SCIPgetRealarrayMinIdx(), SCIPgetRealarrayMaxIdx(), SCIPgetIntarrayMinIdx(), SCIPgetIntarrayMaxIdx(),
  SCIPgetBoolarrayMinIdx(), SCIPgetBoolarrayMaxIdx(), SCIPgetPtrarrayMinIdx() and SCIPgetPtrarrayMaxIdx()
- SCIPbsortPtrInt() and SCIPbsortPtrIntInt()
- SCIPvarWasFixedAtIndex()
- SCIPaddConflictBd()
- SCIPprintMemoryDiagnostic()
- SCIPfindObj...() and SCIPgetObj...() in C++ wrapper interface to get the corresponding plugin object

### Changed parameters

- slightly changed the meaning of parameter `presolving/abortfac` a value of 0 now means to abort presolving only after
  no more change has been found

Fixed bugs
----------

- assigning a value to a fixed variable in a solution with SCIPsetSolVal() does not return an error anymore, if the
  value is equal to the fixed value of the variable
- removed bug in SCIPisScalingIntegral()
- removed bugs with calling SCIPtightenVarLb(), SCIPtightenVarUb(), SCIPinferVarLbCons(), SCIPinferVarUbCons(),
  SCIPinferVarLbProp() and SCIPinferVarUbProp() in `PROBLEM` stage

- (Re)solving:
  - solving loop is now immediately aborted, if a node on the active path is marked to be cut off
  - removed bug in resolving an interrupted problem, after the last solved node was cut off
  - removed bug with infinite solving loop if LP solving is turned off
  - removed bug with aborted solving in root node (e.g. due to time limit) that is tagged to be restarted

- Branching:
  - fixed bug in all-fullstrong branching with getting strong branching information for columns not in current LP
  - implemented missing case in solve.c with branching rules that add constraints

- Numerics:
  - changed numerics for integrality check of coefficients (fixed bug with accumulated errors in rows s.t. the row's
    activity is no longer integral although the row is marked being integer)
  - slightly changed numerics in linear constraint handler presolving to fix a bug with coefficients detected to be scaled
    to an integral value, that are not integral after scaling due to a large scalar that increased the integrality gap to
    a value larger than epsilon

- Constraint handlers:
  - fixed bugs in consdataSwitchWatchedVars() of `or` and `and` constraint handlers
  - fixed wrong assertion in xor constraint handler with switching both watched variables to unwatched
  - fixed bugs in constraint handlers (and, logicor, or, setppc, xor) with calling conflict analysis during presolving
  - removed bug in knapsack constraint handler that appears if a variable is fixed to zero in knapsack presolving, which
    triggers a variable of the same knapsack to be fixed to one due to aggregation

- Presolving:
  - removed bug in knapsack presolver
  - fixed bug in presolving with wrong number of newly fixed/aggregated/... variables/bounds/... after a restart

@section RN077 SCIP 0.7.7
*************************

Features
--------

- infeasible LPs in diving now produce conflict clauses (if LP conflict analysis is enabled)
- conflict analysis was slightly modified
- slightly changed aging strategy of logic or constraint handler

Interface changes
-----------------

### Deleted and changed API methods

- method SCIPgetGap() and SCIPgetTransGap() now return infinity, if primal and dual bound have opposite sign (this
  removes the oddness with the gap increasing while the dual bound approaches zero)

### New API functions

- added methods SCIPgetVarsLogicor() and SCIPgetNVarsLogicor() in logic or constraint handler

### Changed parameters

- `lp/colagelimit` and `lp/rowagelimit` may now be set to -1 to disable deletion of columns/rows due to aging

Build system
------------

### Makefile

- the file names in the archive file are now preceeded with a directory `scip-<version>/`
- the compiler is now also represented in the LP solver library names (e.g. you have to rename the softlink
  `libcplex.linux.x86.a` to `libcplex.linux.x86.gnu.a`)

Fixed bugs
----------

- removed bug in conflict analysis that appears if the conflict is only active at the current depth level
- missing SCIPlpiIsPrimalFeasible() and SCIPlpiIsDualFeasible() implemented in lpi_spx.cpp and lpi_spx121.cpp
- removed preprocessing of linear constraint pairs with modifiable constraints

- Asserts:
  - removed wrong assert `assert(eventfilter->len == 0 || eventfilter->eventmask != 0x00000000)` from event.c
  - removed wrong assert in conflict analysis (appeared on analyzing diving LP conflicts with both bounds of a non-binary variable changed)

@section RN076 SCIP 0.7.6
*************************

Features
--------

- creation of reconvergence clauses in conflict analysis
- first node of each plunging is not treated as plunging node w.r.t. calling primal heuristics
- improved performance of logic or constraint handler due to better watched variables handling

Interface changes
-----------------

### Deleted and changed API methods

- changed SCIPcatchVarEvent() and SCIPdropVarEvent()
- SCIPstage() is now called SCIPgetStage()
- SCIPprintStatus() is now called SCIPprintStage()

### New API functions

- SCIPgetActivityLinear() in linear constraint handler
- SCIPgetFeasibilityLinear() in linear constraint handler
- SCIPchgVarBranchDirection()
- SCIPvarGetBranchDirection()
- SCIPgetStatus() returns the solution status
- SCIPprintStatus() outputs the solution status (beware, that the old SCIPprintStatus() method is now called SCIPprintStage())

### Changed parameters

- changed default frequency offset of pscostdiving `heuristics/pscostdiving/freqofs` to 2 and frequency offset of fracdiving
  `heuristics/feaspump/freqofs` to 0 in order to not call pscostdiving in root node, where nearly all pseudo costs are uninitialized.

### New parameters

- new parameter `separating/efficacynorm` to choose between Euclidean, maximum, sum and discrete norm in efficacy
  calculation

### Data structures

- new possible result code `SCIP_DELAYED` for primal heuristics

Fixed bugs
----------

- removed bugs in CLP Solver interface
- SCIP returned `gap limit reached` even if the problem was solved to optimality, if the optimal solution was found at a
  node with lower bound equal to the global lower bound
- after conversion of the focus node into a junction (e.g. in case of numerical troubles while solving the node's LP), the child
  nodes got the wrong LP fork attached (the common LP fork of the old and new focus node instead of the old focus node's LP fork)

- Variables:
  - bug reconvergence clauses in conflict analysis if bounds on non-binary variables were the reason for the fixing of the
    uip to create a reconvergence clause for
  - wrong sub calls in SCIPvarGet...CurrentRun() for aggregated variables
  - variables' conflict set counter was not reset when the problem was resolved again

Known bugs
----------

- unbounded models lead to an error
- air04 and air05 return wrong optimal value (1 too large): possibly due to strong branching or setppc propagation?

@section RN075 SCIP 0.7.5
*************************

Miscellaneous
-------------

- started change log
