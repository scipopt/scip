# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separation (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/maxbounddist = 1

# minimal efficacy for a cut to enter the LP
# [type: real, range: [0,1e+98], default: 0.05]
separating/minefficacy = 0.05

# minimal efficacy for a cut to enter the LP in the root node
# [type: real, range: [0,1e+98], default: 0.01]
separating/minefficacyroot = 0.01

# minimal orthogonality for a cut to enter the LP
# [type: real, range: [0,1], default: 0.5]
separating/minortho = 0.5

# minimal orthogonality for a cut to enter the LP in the root node
# [type: real, range: [0,1], default: 0.5]
separating/minorthoroot = 0.1

# factor to scale objective parallelism of cut in separation score calculation
# [type: real, range: [0,1e+98], default: 0.0001]
separating/objparalfac = 0.0001

# factor to scale orthogonality of cut in separation score calculation (0.0 to disable orthogonality calculation)
# [type: real, range: [0,1e+98], default: 1]
separating/orthofac = 1

# function used for calc. scalar prod. in orthogonality test ('e'uclidean, 'd'iscrete)
# [type: char, range: {ed}, default: e]
separating/orthofunc = e

# row norm to use for efficacy calculation ('e'uclidean, 'm'aximum, 's'um, 'd'iscrete)
# [type: char, range: {emsd}, default: e]
separating/efficacynorm = e

# maximal number of runs for which separation is enabled (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/maxruns = -1

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/maxrounds = 5

# maximal number of separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/maxroundsroot = -1

# maximal number of separation rounds in the root node of a subsequent run (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 1]
separating/maxroundsrootsubrun = 5

# maximal additional number of separation rounds in subsequent price-and-cut loops (-1: no additional restriction)
# [type: int, range: [-1,2147483647], default: 1]
separating/maxaddrounds = 5

# maximal number of consecutive separation rounds without objective or integrality improvement (-1: no additional restriction)
# [type: int, range: [-1,2147483647], default: 5]
separating/maxstallrounds = 5

# maximal number of cuts separated per separation round (0: disable local separation)
# [type: int, range: [0,2147483647], default: 100]
separating/maxcuts = 100

# maximal number of separated cuts at the root node (0: disable root node separation)
# [type: int, range: [0,2147483647], default: 2000]
separating/maxcutsroot = 5000

# maximum age a cut can reach before it is deleted from the global cut pool, or -1 to keep all cuts
# [type: int, range: [-1,2147483647], default: 100]
separating/cutagelimit = 100

# separation frequency for the global cut pool (-1: disable global cut pool, 0: only separate pool at the root)
# [type: int, range: [-1,2147483647], default: 0]
separating/poolfreq = 10

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/linear/sepafreq = 10

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/delaysepa = FALSE

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
constraints/linear/maxrounds = 5

# maximal number of separation rounds per node in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
constraints/linear/maxroundsroot = -1

# maximal number of cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
constraints/linear/maxsepacuts = 50

# maximal number of cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 200]
constraints/linear/maxsepacutsroot = 500

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cardinality cuts
# [type: real, range: [0,1], default: 0]
constraints/linear/maxcardbounddist = 0

# should all constraints be subject to cardinality cut generation instead of only the ones with non-zero dual value?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/linear/separateall = TRUE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
constraints/and/sepafreq = 1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/and/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/bounddisjunction/sepafreq = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/bounddisjunction/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/conjunction/sepafreq = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/conjunction/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/countsols/sepafreq = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/countsols/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 10]
constraints/indicator/sepafreq = 10

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/delaysepa = FALSE

# Generate logicor constraints instead of cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/genLogicor = FALSE

# Separate using the alternative LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/sepaAlternativeLP = FALSE

# add initial coupling inequalities
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/addCoupling = FALSE

# Update bounds of original variables for separation?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/indicator/updateBounds = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
constraints/integral/sepafreq = -1

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/integral/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/knapsack/sepafreq = 10

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/knapsack/delaysepa = FALSE

# multiplier on separation frequency, how often cardinality cuts are separated (-1: never, 0: only at root)
# [type: int, range: [-1,2147483647], default: 1]
constraints/knapsack/sepacardfreq = 1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cardinality cuts
# [type: real, range: [0,1], default: 0]
constraints/knapsack/maxcardbounddist = 0

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
constraints/knapsack/maxrounds = 5

# maximal number of separation rounds per node in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
constraints/knapsack/maxroundsroot = -1

# maximal number of cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
constraints/knapsack/maxsepacuts = 50

# maximal number of cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 200]
constraints/knapsack/maxsepacutsroot = 500

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/logicor/sepafreq = 10

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/logicor/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/or/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/or/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/setppc/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/setppc/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/SOS1/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS1/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/SOS2/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/SOS2/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/varbound/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/varbound/delaysepa = FALSE

# frequency for separating cuts (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
constraints/xor/sepafreq = 0

# should separation method be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
constraints/xor/delaysepa = FALSE

# priority of separator <clique>
# [type: int, range: [-536870912,536870911], default: -5000]
separating/clique/priority = -5000

# frequency for calling separator <clique> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/clique/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <clique> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/clique/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/clique/delay = FALSE

# factor for scaling weights
# [type: real, range: [1,1.79769313486232e+308], default: 1000]
separating/clique/scaleval = 1000

# maximal number of nodes in branch and bound tree (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
separating/clique/maxtreenodes = -1

# frequency for premature backtracking up to tree level 1 (0: no backtracking)
# [type: int, range: [0,2147483647], default: 10000]
separating/clique/backtrackfreq = 10000

# maximal number of clique cuts separated per separation round (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10]
separating/clique/maxsepacuts = 10

# maximal number of zero-valued variables extending the clique (-1: no limit)
# [type: int, range: [-1,2147483647], default: 1000]
separating/clique/maxzeroextensions = 1000

# maximal memory size of dense clique table (in kb)
# [type: real, range: [0,2097151.99902344], default: 20000]
separating/clique/cliquetablemem = 20000

# minimal density of cliques to use a dense clique table
# [type: real, range: [0,1], default: 0.05]
separating/clique/cliquedensity = 0.05

# priority of separator <cmir>
# [type: int, range: [-536870912,536870911], default: -3000]
separating/cmir/priority = -3000

# frequency for calling separator <cmir> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/cmir/freq = 20

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <cmir> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/cmir/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/cmir/delay = FALSE

# maximal number of cmir separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 3]
separating/cmir/maxrounds = 3

# maximal number of cmir separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/cmir/maxroundsroot = 15

# maximal number of rows to start aggregation with per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/cmir/maxtries = 100

# maximal number of rows to start aggregation with per separation round in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/cmir/maxtriesroot = -1

# maximal number of consecutive unsuccesful aggregation tries (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 20]
separating/cmir/maxfails = 20

# maximal number of consecutive unsuccesful aggregation tries in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/cmir/maxfailsroot = 200

# maximal number of aggregations for each row per separation round
# [type: int, range: [0,2147483647], default: 3]
separating/cmir/maxaggrs = 3

# maximal number of aggregations for each row per separation round in the root node
# [type: int, range: [0,2147483647], default: 6]
separating/cmir/maxaggrsroot = 6

# maximal number of cmir cuts separated per separation round
# [type: int, range: [0,2147483647], default: 100]
separating/cmir/maxsepacuts = 100

# maximal number of cmir cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/cmir/maxsepacutsroot = 1000

# maximal slack of rows to be used in aggregation
# [type: real, range: [0,1.79769313486232e+308], default: 0]
separating/cmir/maxslack = 0

# maximal slack of rows to be used in aggregation in the root node
# [type: real, range: [0,1.79769313486232e+308], default: 0.1]
separating/cmir/maxslackroot = 0.1

# weight of row density in the aggregation scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.0001]
separating/cmir/densityscore = 0.0001

# weight of slack in the aggregation scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.001]
separating/cmir/slackscore = 0.001

# maximal density of aggregated row
# [type: real, range: [0,1], default: 0.2]
separating/cmir/maxaggdensity = 0.2

# maximal density of row to be used in aggregation
# [type: real, range: [0,1], default: 0.05]
separating/cmir/maxrowdensity = 0.05

# additional number of variables allowed in row on top of density
# [type: int, range: [0,2147483647], default: 100]
separating/cmir/densityoffset = 100

# maximal row aggregation factor
# [type: real, range: [0,1.79769313486232e+308], default: 10000]
separating/cmir/maxrowfac = 10000

# maximal number of different deltas to try (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/cmir/maxtestdelta = -1

# maximal number of active continuous variables in aggregated row
# [type: int, range: [0,2147483647], default: 10]
separating/cmir/maxconts = 10

# maximal number of active continuous variables in aggregated row in the root node
# [type: int, range: [0,2147483647], default: 10]
separating/cmir/maxcontsroot = 10

# tolerance for bounddistances used to select continuous variable in current aggregated constraint to be eliminated
# [type: real, range: [0,1.79769313486232e+308], default: 0.1]
separating/cmir/aggrtol = 0.1

# should negative values also be tested in scaling?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/trynegscaling = TRUE

# should an additional variable be complemented if f0 = 0?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/fixintegralrhs = TRUE

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/cmir/dynamiccuts = TRUE

# priority of separator <flowcover>
# [type: int, range: [-536870912,536870911], default: -4000]
separating/flowcover/priority = -4000

# frequency for calling separator <flowcover> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/flowcover/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <flowcover> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/flowcover/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/flowcover/delay = FALSE

# maximal number of separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/flowcover/maxrounds = 5

# maximal number of separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/flowcover/maxroundsroot = 15

# maximal number of rows to separate flow cover cuts for per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/flowcover/maxtries = 100

# maximal number of rows to separate flow cover cuts for per separation round in the root (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/flowcover/maxtriesroot = -1

# maximal number of consecutive fails to generate a cut per separation round (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 50]
separating/flowcover/maxfails = 50

# maximal number of consecutive fails to generate a cut per separation round in the root (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 100]
separating/flowcover/maxfailsroot = 100

# maximal number of flow cover cuts separated per separation round
# [type: int, range: [0,2147483647], default: 100]
separating/flowcover/maxsepacuts = 100

# maximal number of flow cover cuts separated per separation round in the root
# [type: int, range: [0,2147483647], default: 200]
separating/flowcover/maxsepacutsroot = 500

# maximal slack of rows to separate flow cover cuts for
# [type: real, range: [0,1.79769313486232e+308], default: 1.79769313486232e+308]
separating/flowcover/maxslack = 1.79769313486232e+308

# maximal slack of rows to separate flow cover cuts for in the root
# [type: real, range: [0,1.79769313486232e+308], default: 1.79769313486232e+308]
separating/flowcover/maxslackroot = 1.79769313486232e+308

# weight of slack in the scoring of the rows
# [type: real, range: [0,1.79769313486232e+308], default: 0.001]
separating/flowcover/slackscore = 0.001

# maximal density of row to separate flow cover cuts for
# [type: real, range: [0,1], default: 1]
separating/flowcover/maxrowdensity = 1

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/flowcover/dynamiccuts = TRUE

# should flow cover cuts be separated for 0-1 single node flow set with reversed arcs in addition?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/flowcover/multbyminusone = TRUE

# cut generation heuristic: maximal number of different deltas to try
# [type: int, range: [0,2147483647], default: 10]
separating/flowcover/maxtestdelta = 10

# priority of separator <gomory>
# [type: int, range: [-536870912,536870911], default: -1000]
separating/gomory/priority = -1000

# frequency for calling separator <gomory> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/gomory/freq = 20

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <gomory> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/gomory/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/gomory/delay = FALSE

# maximal number of gomory separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/gomory/maxrounds = 5

# maximal number of gomory separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/gomory/maxroundsroot = -1

# maximal number of gomory cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/gomory/maxsepacuts = 50

# maximal number of gomory cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/gomory/maxsepacutsroot = 1000

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 10000]
separating/gomory/maxweightrange = 10000

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/gomory/dynamiccuts = TRUE

# priority of separator <impliedbounds>
# [type: int, range: [-536870912,536870911], default: -50]
separating/impliedbounds/priority = -50

# frequency for calling separator <impliedbounds> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/impliedbounds/freq = 1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <impliedbounds> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/impliedbounds/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/impliedbounds/delay = FALSE

# priority of separator <intobj>
# [type: int, range: [-536870912,536870911], default: -100]
separating/intobj/priority = -100

# frequency for calling separator <intobj> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/intobj/freq = -1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <intobj> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/intobj/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/intobj/delay = FALSE

# priority of separator <mcf>
# [type: int, range: [-536870912,536870911], default: -10000]
separating/mcf/priority = -10000

# frequency for calling separator <mcf> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/mcf/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <mcf> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/mcf/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/mcf/delay = FALSE

# number of clusters to generate in the shrunken network -- default separation
# [type: int, range: [2,32], default: 5]
separating/mcf/nclusters = 5

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 1000000]
separating/mcf/maxweightrange = 1000000

# maximal number of different deltas to try (-1: unlimited)  -- default separation
# [type: int, range: [-1,2147483647], default: 20]
separating/mcf/maxtestdelta = -1

# should negative values also be tested in scaling?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/mcf/trynegscaling = TRUE

# should an additional variable be complemented if f0 = 0?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/fixintegralrhs = TRUE

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/dynamiccuts = TRUE

# model type of network (0: auto, 1:directed, 2:undirected)
# [type: int, range: [0,2], default: 0]
separating/mcf/modeltype = 0

# maximal number of mcf cuts separated per separation round
# [type: int, range: [-1,2147483647], default: 100]
separating/mcf/maxsepacuts = 100

# maximal number of mcf cuts separated per separation round in the root node  -- default separation
# [type: int, range: [-1,2147483647], default: 200]
separating/mcf/maxsepacutsroot = 200

# maximum inconsistency ratio for separation at all
# [type: real, range: [0,1.79769313486232e+308], default: 0.02]
separating/mcf/maxinconsistencyratio = 0.02

# maximum inconsistency ratio of arcs not to be deleted
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
separating/mcf/maxarcinconsistencyratio = 0.5

# should we separate only if the cuts shores are connected?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/checkcutshoreconnectivity = TRUE

# should we separate inequalities based on single-node cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separatesinglenodecuts = TRUE

# should we separate flowcutset inequalities on the network cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separateflowcutset = TRUE

# should we separate knapsack cover inequalities on the network cuts?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/mcf/separateknapsack = TRUE

# priority of separator <redcost>
# [type: int, range: [-536870912,536870911], default: 10000000]
separating/redcost/priority = 10000000

# frequency for calling separator <redcost> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 1]
separating/redcost/freq = 1

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <redcost> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 1]
separating/redcost/maxbounddist = 1

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/redcost/delay = FALSE

# should reduced cost fixing be also applied to continuous variables?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/redcost/continuous = FALSE

# priority of separator <strongcg>
# [type: int, range: [-536870912,536870911], default: -2000]
separating/strongcg/priority = -2000

# frequency for calling separator <strongcg> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: 0]
separating/strongcg/freq = 20

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <strongcg> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/strongcg/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/strongcg/delay = FALSE

# maximal number of strong CG separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/strongcg/maxrounds = 5

# maximal number of strong CG separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 20]
separating/strongcg/maxroundsroot = 50

# maximal number of strong CG cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/strongcg/maxsepacuts = 50

# maximal number of strong CG cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/strongcg/maxsepacutsroot = 1000

# maximal valid range max(|weights|)/min(|weights|) of row weights
# [type: real, range: [1,1.79769313486232e+308], default: 10000]
separating/strongcg/maxweightrange = 10000

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/strongcg/dynamiccuts = TRUE

# priority of separator <zerohalf>
# [type: int, range: [-536870912,536870911], default: -6000]
separating/zerohalf/priority = -6000

# frequency for calling separator <zerohalf> (-1: never, 0: only in root node)
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/freq = 0

# maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator <zerohalf> (0.0: only on current best node, 1.0: on all nodes)
# [type: real, range: [0,1], default: 0]
separating/zerohalf/maxbounddist = 0

# should separator be delayed, if other separators found cuts?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/delay = FALSE

# maximal number of zerohalf separation rounds per node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 5]
separating/zerohalf/maxrounds = 5

# maximal number of zerohalf separation rounds in the root node (-1: unlimited)
# [type: int, range: [-1,2147483647], default: 10]
separating/zerohalf/maxroundsroot = 10

# maximal number of {0,1/2}-cuts separated per separation round
# [type: int, range: [0,2147483647], default: 50]
separating/zerohalf/maxsepacuts = 50

# maximal number of {0,1/2}-cuts separated per separation round in the root node
# [type: int, range: [0,2147483647], default: 500]
separating/zerohalf/maxsepacutsroot = 500

# should generated cuts be removed from the LP if they are no longer tight?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/dynamiccuts = TRUE

# maximal number of {0,1/2}-cuts determined per separation round 
   #                      (this includes separated but inefficacious cuts)
# [type: int, range: [0,2147483647], default: 100]
separating/zerohalf/maxcutsfound = 100

# maximal number of {0,1/2}-cuts determined per separation round in the root node
   #                      (this includes separated but inefficacious cuts)
# [type: int, range: [0,2147483647], default: 1000]
separating/zerohalf/maxcutsfoundroot = 1000

# separating cuts only if depth <= maxdepth (-1: unlimited)
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/maxdepth = -1

# maximal number of calls (-1: unlimited)
# [type: longint, range: [-1,9223372036854775807], default: -1]
separating/zerohalf/maxncalls = -1

# should continuous variables be relaxed by adding variable bounds?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/relaxcontvars = FALSE

# should rows be scaled to make fractional coefficients integer?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/scalefraccoeffs = FALSE

# should zerohalf cuts found in previous callbacks ignored?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/ignoreprevzhcuts = FALSE

# should only original LP rows be considered (i.e. ignore previously added LP rows)?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/onlyorigrows = FALSE

# should zerohalf cuts be filtered using a cutpool?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/usezhcutpool = TRUE

# should problem be decomposed into subproblems (if possible) before applying preprocessing?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/preprocessing/decomposeproblem = TRUE

# value of delta parameter used in preprocessing method 'd'
# [type: real, range: [0,1], default: 0.5]
separating/zerohalf/preprocessing/delta = 0.5

# preprocessing methods and ordering:
   #                      'd' columns with small LP solution,
   #                      'G' modified Gaussian elimination,
   #                      'i' identical columns,
   #                      'I' identical rows,
   #                      'L' large slack rows,
   #                      'M' large slack rows (minslack),
   #                      's' column singletons,
   #                      'X' add trivial zerohalf cuts,
   #                      'z' zero columns,
   #                      'Z' zero rows,
   #                      'C' fast {'z','s'},
   #                      'R' fast {'Z','L','I'}
   #                      
   #                      '-' no preprocessing
   #                     
# [type: string, default: "CXRGXIM"]
separating/zerohalf/preprocessing/ppmethods = "CXRGXIM"

# should the cuts be forced to enter the LP?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/separating/forcecutstolp = FALSE

# should the cuts be forced to enter SCIP's sepastore?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
separating/zerohalf/separating/forcecutstosepastore = FALSE

# minimal violation of a {0,1/2}-cut to be separated
# [type: real, range: [0.001,0.5], default: 0.3]
separating/zerohalf/separating/minviolation = 0.3

# separating methods and ordering:
   #                      '!' stop further processing if a cut was found,
   #                      '2' exact polynomial time algorithm (only if matrix has max 2 odd entries per row),
   #                      'e' enumeration heuristics (k=1: try all preprocessed rows),
   #                      'E' enumeration heuristics (k=2: try all combinations of up to two preprocessed rows),
   #                      'g' Extended Gaussian elimination heuristics,
   #                      's' auxiliary IP heuristics (i.e. number of solved nodes is limited)
   #                      'S' auxiliary IP exact      (i.e. unlimited number of nodes)
   #                      
   #                      '-' no processing
   #                     
# [type: string, default: "2g"]
separating/zerohalf/separating/sepamethods = "2g"

# optional settings file of the auxiliary IP (-: none)
# [type: string, default: "-"]
separating/zerohalf/separating/auxip/settingsfile = "-"

# limits/solutions setting of the auxiliary IP
# [type: int, range: [-1,2147483647], default: -1]
separating/zerohalf/separating/auxip/sollimit = -1

# penalty factor used with objective function 'p' of auxiliary IP
# [type: real, range: [0,1], default: 0.001]
separating/zerohalf/separating/auxip/penaltyfactor = 0.001

# should all (proper) solutions of the auxiliary IP be used to generate cuts instead of using only the best?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
separating/zerohalf/separating/auxip/useallsols = TRUE

# auxiliary IP objective:
   #                      'v' maximize cut violation,
   #                      'u' minimize number of aggregated rows in cut,
   #                      'w' minimize number of aggregated rows in cut
   #                          weighted by the number of rows in the aggregation,
   #                      'p' maximize cut violation and penalize a high number
   #                          of aggregated rows in the cut weighted by the number
   #                          of rows in the aggregation and the penalty factor p
   #                     
# [type: char, range: {uvwp}, default: v]
separating/zerohalf/separating/auxip/objective = v
