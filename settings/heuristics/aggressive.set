# priority of heuristic <actconsdiving>
# [type: int, range: [-536870912,536870911], default: -1003700]
heuristics/actconsdiving/priority = -1003700

# frequency for calling primal heuristic <actconsdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/actconsdiving/freq = -1

# frequency offset for calling primal heuristic <actconsdiving>
# [type: int, range: [0,2147483647], default: 5]
heuristics/actconsdiving/freqofs = 5

# maximal depth level to call primal heuristic <actconsdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/actconsdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/actconsdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/actconsdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/actconsdiving/maxlpiterquot = 0.05

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/actconsdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/actconsdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/actconsdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/actconsdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/actconsdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/actconsdiving/backtrack = TRUE

# priority of heuristic <coefdiving>
# [type: int, range: [-536870912,536870911], default: -1001000]
heuristics/coefdiving/priority = -1001000

# frequency for calling primal heuristic <coefdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/coefdiving/freq = 5

# frequency offset for calling primal heuristic <coefdiving>
# [type: int, range: [0,2147483647], default: 1]
heuristics/coefdiving/freqofs = 1

# maximal depth level to call primal heuristic <coefdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/coefdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/coefdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/coefdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/coefdiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/coefdiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/coefdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/coefdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/coefdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/coefdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/coefdiving/backtrack = TRUE

# priority of heuristic <crossover>
# [type: int, range: [-536870912,536870911], default: -1104000]
heuristics/crossover/priority = -1104000

# frequency for calling primal heuristic <crossover> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 30]
heuristics/crossover/freq = 20

# frequency offset for calling primal heuristic <crossover>
# [type: int, range: [0,2147483647], default: 10]
heuristics/crossover/freqofs = 10

# maximal depth level to call primal heuristic <crossover> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/crossover/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/crossover/nodesofs = 750

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/crossover/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/crossover/minnodes = 500

# number of solutions to be taken into account
# [type: int, range: [2,2147483647], default: 3]
heuristics/crossover/nusedsols = 3

# number of nodes without incumbent change that heuristic should wait
# [type: longint, range: [0,9223372036854775807], default: 200]
heuristics/crossover/nwaitingnodes = 100

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/crossover/nodesquot = 0.15

# minimum percentage of integer variables that have to be fixed 
# [type: real, range: [0,1], default: 0.666]
heuristics/crossover/minfixingrate = 0.5

# factor by which Crossover should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/crossover/minimprove = 0.01

# should the choice which sols to take be randomized?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/crossover/randomization = TRUE

# priority of heuristic <dins>
# [type: int, range: [-536870912,536870911], default: -1105000]
heuristics/dins/priority = -1105000

# frequency for calling primal heuristic <dins> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/dins/freq = 20

# frequency offset for calling primal heuristic <dins>
# [type: int, range: [0,2147483647], default: 0]
heuristics/dins/freqofs = 0

# maximal depth level to call primal heuristic <dins> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/dins/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/dins/nodesofs = 5000

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.05]
heuristics/dins/nodesquot = 0.05

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/dins/minnodes = 500

# number of pool-solutions to be checked for flag array update (for hard fixing of binary variables)
# [type: int, range: [1,2147483647], default: 5]
heuristics/dins/solnum = 5

# radius (using Manhattan metric) of the incumbent's neighborhood to be searched
# [type: int, range: [1,2147483647], default: 18]
heuristics/dins/neighborhoodsize = 18

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/dins/maxnodes = 5000

# factor by which DINS should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/dins/minimprove = 0.01

# number of nodes without incumbent change that heuristic should wait
# [type: longint, range: [0,9223372036854775807], default: 0]
heuristics/dins/nwaitingnodes = 0

# priority of heuristic <feaspump>
# [type: int, range: [-536870912,536870911], default: -1000000]
heuristics/feaspump/priority = -1000000

# frequency for calling primal heuristic <feaspump> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/feaspump/freq = 10

# frequency offset for calling primal heuristic <feaspump>
# [type: int, range: [0,2147483647], default: 0]
heuristics/feaspump/freqofs = 0

# maximal depth level to call primal heuristic <feaspump> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/feaspump/maxdepth = -1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.01]
heuristics/feaspump/maxlpiterquot = 0.01

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/feaspump/maxlpiterofs = 2000

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: 2]
heuristics/feaspump/maxsols = 2

# factor by which the regard of the objective is decreased in each round, 1.0 for dynamic
# [type: real, range: [0,1], default: 1]
heuristics/feaspump/objfactor = 1

# maximal number of pumping loops (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10000]
heuristics/feaspump/maxloops = 10000

# maximal number of pumping rounds without fractionality improvement (-1: no limit)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/feaspump/maxstallloops = 10

# minimum number of random variables to flip, if a 1-cycle is encountered
# [type: int, range: [1,2147483647], default: 10]
heuristics/feaspump/minflips = 10

# maximum length of cycles to be checked explicitly in each round
# [type: int, range: [1,100], default: 3]
heuristics/feaspump/cyclelength = 3

# number of iterations until a random perturbation is forced
# [type: int, range: [1,2147483647], default: 100]
heuristics/feaspump/perturbfreq = 100

# should the feasibility pump be called at root node before cut separation?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/feaspump/beforecuts = TRUE

# priority of heuristic <fixandinfer>
# [type: int, range: [-536870912,536870911], default: -500000]
heuristics/fixandinfer/priority = -500000

# frequency for calling primal heuristic <fixandinfer> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fixandinfer/freq = -1

# frequency offset for calling primal heuristic <fixandinfer>
# [type: int, range: [0,2147483647], default: 0]
heuristics/fixandinfer/freqofs = 0

# maximal depth level to call primal heuristic <fixandinfer> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fixandinfer/maxdepth = -1

# maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/fixandinfer/proprounds = 0

# minimal number of fixings to apply before dive may be aborted
# [type: int, range: [0,2147483647], default: 100]
heuristics/fixandinfer/minfixings = 100

# priority of heuristic <fracdiving>
# [type: int, range: [-536870912,536870911], default: -1003000]
heuristics/fracdiving/priority = -1003000

# frequency for calling primal heuristic <fracdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/fracdiving/freq = 5

# frequency offset for calling primal heuristic <fracdiving>
# [type: int, range: [0,2147483647], default: 3]
heuristics/fracdiving/freqofs = 3

# maximal depth level to call primal heuristic <fracdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/fracdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/fracdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/fracdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/fracdiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/fracdiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/fracdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/fracdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/fracdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/fracdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/fracdiving/backtrack = TRUE

# priority of heuristic <guideddiving>
# [type: int, range: [-536870912,536870911], default: -1007000]
heuristics/guideddiving/priority = -1007000

# frequency for calling primal heuristic <guideddiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/guideddiving/freq = 5

# frequency offset for calling primal heuristic <guideddiving>
# [type: int, range: [0,2147483647], default: 7]
heuristics/guideddiving/freqofs = 7

# maximal depth level to call primal heuristic <guideddiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/guideddiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/guideddiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/guideddiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/guideddiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/guideddiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/guideddiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/guideddiving/maxdiveavgquot = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/guideddiving/backtrack = TRUE

# priority of heuristic <intdiving>
# [type: int, range: [-536870912,536870911], default: -1003500]
heuristics/intdiving/priority = -1003500

# frequency for calling primal heuristic <intdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intdiving/freq = -1

# frequency offset for calling primal heuristic <intdiving>
# [type: int, range: [0,2147483647], default: 9]
heuristics/intdiving/freqofs = 9

# maximal depth level to call primal heuristic <intdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/intdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/intdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/intdiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/intdiving/maxlpiterofs = 1000

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/intdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/intdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/intdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/intdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/intdiving/backtrack = TRUE

# priority of heuristic <intshifting>
# [type: int, range: [-536870912,536870911], default: -10000]
heuristics/intshifting/priority = -10000

# frequency for calling primal heuristic <intshifting> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/intshifting/freq = 5

# frequency offset for calling primal heuristic <intshifting>
# [type: int, range: [0,2147483647], default: 0]
heuristics/intshifting/freqofs = 0

# maximal depth level to call primal heuristic <intshifting> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/intshifting/maxdepth = -1

# priority of heuristic <linesearchdiving>
# [type: int, range: [-536870912,536870911], default: -1006000]
heuristics/linesearchdiving/priority = -1006000

# frequency for calling primal heuristic <linesearchdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/linesearchdiving/freq = 5

# frequency offset for calling primal heuristic <linesearchdiving>
# [type: int, range: [0,2147483647], default: 6]
heuristics/linesearchdiving/freqofs = 6

# maximal depth level to call primal heuristic <linesearchdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/linesearchdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/linesearchdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/linesearchdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/linesearchdiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/linesearchdiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/linesearchdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/linesearchdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/linesearchdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/linesearchdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/linesearchdiving/backtrack = TRUE

# priority of heuristic <localbranching>
# [type: int, range: [-536870912,536870911], default: -1102000]
heuristics/localbranching/priority = -1102000

# frequency for calling primal heuristic <localbranching> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/localbranching/freq = -1

# frequency offset for calling primal heuristic <localbranching>
# [type: int, range: [0,2147483647], default: 0]
heuristics/localbranching/freqofs = 0

# maximal depth level to call primal heuristic <localbranching> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/localbranching/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 1000]
heuristics/localbranching/nodesofs = 1000

# radius (using Manhattan metric) of the incumbent's neighborhood to be searched
# [type: int, range: [1,2147483647], default: 18]
heuristics/localbranching/neighborhoodsize = 18

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.05]
heuristics/localbranching/nodesquot = 0.05

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 1000]
heuristics/localbranching/minnodes = 1000

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 10000]
heuristics/localbranching/maxnodes = 10000

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/localbranching/nwaitingnodes = 200

# factor by which localbranching should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/localbranching/minimprove = 0.01

# priority of heuristic <mutation>
# [type: int, range: [-536870912,536870911], default: -1103000]
heuristics/mutation/priority = -1103000

# frequency for calling primal heuristic <mutation> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/mutation/freq = -1

# frequency offset for calling primal heuristic <mutation>
# [type: int, range: [0,2147483647], default: 8]
heuristics/mutation/freqofs = 8

# maximal depth level to call primal heuristic <mutation> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/mutation/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 500]
heuristics/mutation/nodesofs = 500

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 5000]
heuristics/mutation/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 500]
heuristics/mutation/minnodes = 500

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/mutation/nwaitingnodes = 200

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/mutation/nodesquot = 0.1

# percentage of integer variables that have to be fixed 
# [type: real, range: [1e-06,0.999999], default: 0.8]
heuristics/mutation/minfixingrate = 0.8

# factor by which Mutation should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/mutation/minimprove = 0.01

# priority of heuristic <nlp>
# [type: int, range: [-536870912,536870911], default: -2000000]
heuristics/nlp/priority = -2000000

# frequency for calling primal heuristic <nlp> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/nlp/freq = 10

# frequency offset for calling primal heuristic <nlp>
# [type: int, range: [0,2147483647], default: 0]
heuristics/nlp/freqofs = 0

# maximal depth level to call primal heuristic <nlp> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/nlp/maxdepth = -1

# verbosity level of NLP solver
# [type: int, range: [0,2], default: 0]
heuristics/nlp/nlpverblevel = 0

# iteration limit of NLP solver; 0 to use solver default
# [type: int, range: [0,2147483647], default: 0]
heuristics/nlp/nlpiterlimit = 0

# time limit of NLP solver; 0 to use solver default
# [type: real, range: [0,1e+20], default: 0]
heuristics/nlp/nlptimelimit = 0

# if SCIP does not accept a solution which the NLP solver thinks is feasible, the feasibility tolerance is reduced by this factor and the NLP resolved (set to 1. to turn off resolve
# [type: real, range: [0,1], default: 0.01]
heuristics/nlp/resolvetolfactor = 0.01

# whether a resolve of an NLP due to disagreement of feasibility should be from the original starting point or the infeasible solution
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/nlp/resolvefromscratch = TRUE

# number of iterations added to the contingent of the total number of iterations
# [type: int, range: [0,2147483647], default: 500]
heuristics/nlp/iteroffset = 500

# contingent of NLP iterations in relation to the number of nodes in SCIP
# [type: real, range: [0,1e+20], default: 0.1]
heuristics/nlp/iterquotient = 0.1

# contingent of NLP iterations in relation to the number of nodes in SCIP
# [type: int, range: [0,2147483647], default: 300]
heuristics/nlp/itermin = 300

# whether variable bound constraints should be handled explicitly before solving NLP instead of adding them to the NLP
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/nlp/varboundexplicit = TRUE

# priority of heuristic <objpscostdiving>
# [type: int, range: [-536870912,536870911], default: -1004000]
heuristics/objpscostdiving/priority = -1004000

# frequency for calling primal heuristic <objpscostdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/objpscostdiving/freq = 10

# frequency offset for calling primal heuristic <objpscostdiving>
# [type: int, range: [0,2147483647], default: 4]
heuristics/objpscostdiving/freqofs = 4

# maximal depth level to call primal heuristic <objpscostdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/objpscostdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/objpscostdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/objpscostdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to total iteration number
# [type: real, range: [0,1], default: 0.01]
heuristics/objpscostdiving/maxlpiterquot = 0.015

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/objpscostdiving/maxlpiterofs = 1500

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/objpscostdiving/maxsols = -1

# maximal diving depth: number of binary/integer variables times depthfac
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
heuristics/objpscostdiving/depthfac = 0.5

# maximal diving depth factor if no feasible solution was found yet
# [type: real, range: [0,1.79769313486232e+308], default: 2]
heuristics/objpscostdiving/depthfacnosol = 2

# priority of heuristic <octane>
# [type: int, range: [-536870912,536870911], default: -1008000]
heuristics/octane/priority = -1008000

# frequency for calling primal heuristic <octane> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/octane/freq = 20

# frequency offset for calling primal heuristic <octane>
# [type: int, range: [0,2147483647], default: 0]
heuristics/octane/freqofs = 0

# maximal depth level to call primal heuristic <octane> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/octane/maxdepth = -1

# number of 0-1-points to be tested as possible solutions by OCTANE
# [type: int, range: [1,2147483647], default: 100]
heuristics/octane/fmax = 100

# number of 0-1-points to be tested at first whether they violate a common row
# [type: int, range: [1,2147483647], default: 10]
heuristics/octane/ffirst = 10

# execute OCTANE only in the space of fractional variables (TRUE) or in the full space? 
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/usefracspace = TRUE

# should the inner normal of the objective be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useobjray = TRUE

# should the average of the basic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgray = TRUE

# should the difference between the root solution and the current LP solution be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: FALSE]
heuristics/octane/usediffray = FALSE

# should the weighted average of the basic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgwgtray = TRUE

# should the weighted average of the nonbasic cone be used as one ray direction?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/octane/useavgnbray = TRUE

# priority of heuristic <oneopt>
# [type: int, range: [-536870912,536870911], default: -20000]
heuristics/oneopt/priority = -20000

# frequency for calling primal heuristic <oneopt> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/oneopt/freq = 1

# frequency offset for calling primal heuristic <oneopt>
# [type: int, range: [0,2147483647], default: 0]
heuristics/oneopt/freqofs = 0

# maximal depth level to call primal heuristic <oneopt> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/oneopt/maxdepth = -1

# should the objective be weighted with the potential shifting value when sorting the shifting candidates?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/oneopt/weightedobj = TRUE

# should the heuristic be called before and during the root node?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/oneopt/duringroot = TRUE

# priority of heuristic <pscostdiving>
# [type: int, range: [-536870912,536870911], default: -1002000]
heuristics/pscostdiving/priority = -1002000

# frequency for calling primal heuristic <pscostdiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/pscostdiving/freq = 5

# frequency offset for calling primal heuristic <pscostdiving>
# [type: int, range: [0,2147483647], default: 2]
heuristics/pscostdiving/freqofs = 2

# maximal depth level to call primal heuristic <pscostdiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/pscostdiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/pscostdiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/pscostdiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/pscostdiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/pscostdiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/pscostdiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/pscostdiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/pscostdiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/pscostdiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/pscostdiving/backtrack = TRUE

# priority of heuristic <rens>
# [type: int, range: [-536870912,536870911], default: -1100000]
heuristics/rens/priority = -1100000

# frequency for calling primal heuristic <rens> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/rens/freq = 0

# frequency offset for calling primal heuristic <rens>
# [type: int, range: [0,2147483647], default: 0]
heuristics/rens/freqofs = 0

# maximal depth level to call primal heuristic <rens> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rens/maxdepth = -1

# minimum percentage of integer variables that have to be fixable 
# [type: real, range: [0,1], default: 0.5]
heuristics/rens/minfixingrate = 0.3

# maximum number of nodes to regard in the subproblem
# [type: longint, range: [0,9223372036854775807], default: 5000]
heuristics/rens/maxnodes = 5000

# should general integers get binary bounds [floor(.),ceil(.)] ?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/rens/binarybounds = TRUE

# number of nodes added to the contingent of the total nodes
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/rens/nodesofs = 2000

# minimum number of nodes required to start the subproblem
# [type: longint, range: [0,9223372036854775807], default: 500]
heuristics/rens/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/rens/nodesquot = 0.1

# factor by which RENS should at least improve the incumbent  
# [type: real, range: [0,1], default: 0.01]
heuristics/rens/minimprove = 0.01

# priority of heuristic <rins>
# [type: int, range: [-536870912,536870911], default: -1101000]
heuristics/rins/priority = -1101000

# frequency for calling primal heuristic <rins> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rins/freq = 20

# frequency offset for calling primal heuristic <rins>
# [type: int, range: [0,2147483647], default: 5]
heuristics/rins/freqofs = 5

# maximal depth level to call primal heuristic <rins> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rins/maxdepth = -1

# number of nodes added to the contingent of the total nodes
# [type: int, range: [0,2147483647], default: 500]
heuristics/rins/nodesofs = 500

# maximum number of nodes to regard in the subproblem
# [type: int, range: [0,2147483647], default: 5000]
heuristics/rins/maxnodes = 5000

# minimum number of nodes required to start the subproblem
# [type: int, range: [0,2147483647], default: 500]
heuristics/rins/minnodes = 500

# contingent of sub problem nodes in relation to the number of nodes of the original problem
# [type: real, range: [0,1], default: 0.1]
heuristics/rins/nodesquot = 0.1

# number of nodes without incumbent change that heuristic should wait
# [type: int, range: [0,2147483647], default: 200]
heuristics/rins/nwaitingnodes = 200

# factor by which RINS should at least improve the incumbent
# [type: real, range: [0,1], default: 0.01]
heuristics/rins/minimprove = 0.01

# minimum percentage of integer variables that have to be fixed 
# [type: real, range: [0,1], default: 0]
heuristics/rins/minfixingrate = 0

# priority of heuristic <rootsoldiving>
# [type: int, range: [-536870912,536870911], default: -1005000]
heuristics/rootsoldiving/priority = -1005000

# frequency for calling primal heuristic <rootsoldiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 20]
heuristics/rootsoldiving/freq = 10

# frequency offset for calling primal heuristic <rootsoldiving>
# [type: int, range: [0,2147483647], default: 5]
heuristics/rootsoldiving/freqofs = 5

# maximal depth level to call primal heuristic <rootsoldiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rootsoldiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/rootsoldiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/rootsoldiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.01]
heuristics/rootsoldiving/maxlpiterquot = 0.015

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/rootsoldiving/maxlpiterofs = 1500

# total number of feasible solutions found up to which heuristic is called (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rootsoldiving/maxsols = -1

# maximal diving depth: number of binary/integer variables times depthfac
# [type: real, range: [0,1.79769313486232e+308], default: 0.5]
heuristics/rootsoldiving/depthfac = 0.5

# maximal diving depth factor if no feasible solution was found yet
# [type: real, range: [0,1.79769313486232e+308], default: 2]
heuristics/rootsoldiving/depthfacnosol = 2

# priority of heuristic <rounding>
# [type: int, range: [-536870912,536870911], default: -1000]
heuristics/rounding/priority = -1000

# frequency for calling primal heuristic <rounding> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/rounding/freq = 1

# frequency offset for calling primal heuristic <rounding>
# [type: int, range: [0,2147483647], default: 0]
heuristics/rounding/freqofs = 0

# maximal depth level to call primal heuristic <rounding> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/rounding/maxdepth = -1

# priority of heuristic <shifting>
# [type: int, range: [-536870912,536870911], default: -5000]
heuristics/shifting/priority = -5000

# frequency for calling primal heuristic <shifting> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/shifting/freq = 2

# frequency offset for calling primal heuristic <shifting>
# [type: int, range: [0,2147483647], default: 0]
heuristics/shifting/freqofs = 0

# maximal depth level to call primal heuristic <shifting> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/shifting/maxdepth = -1

# priority of heuristic <simplerounding>
# [type: int, range: [-536870912,536870911], default: 0]
heuristics/simplerounding/priority = 0

# frequency for calling primal heuristic <simplerounding> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/simplerounding/freq = 1

# frequency offset for calling primal heuristic <simplerounding>
# [type: int, range: [0,2147483647], default: 0]
heuristics/simplerounding/freqofs = 0

# maximal depth level to call primal heuristic <simplerounding> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/simplerounding/maxdepth = -1

# priority of heuristic <trivial>
# [type: int, range: [-536870912,536870911], default: 1000]
heuristics/trivial/priority = 1000

# frequency for calling primal heuristic <trivial> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 0]
heuristics/trivial/freq = -1

# frequency offset for calling primal heuristic <trivial>
# [type: int, range: [0,2147483647], default: 0]
heuristics/trivial/freqofs = 0

# maximal depth level to call primal heuristic <trivial> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/trivial/maxdepth = -1

# priority of heuristic <trysol>
# [type: int, range: [-536870912,536870911], default: -3000000]
heuristics/trysol/priority = -3000000

# frequency for calling primal heuristic <trysol> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 1]
heuristics/trysol/freq = -1

# frequency offset for calling primal heuristic <trysol>
# [type: int, range: [0,2147483647], default: 0]
heuristics/trysol/freqofs = 0

# maximal depth level to call primal heuristic <trysol> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/trysol/maxdepth = -1

# priority of heuristic <veclendiving>
# [type: int, range: [-536870912,536870911], default: -1003100]
heuristics/veclendiving/priority = -1003100

# frequency for calling primal heuristic <veclendiving> (-1: never, 0: only at depth freqofs)
# [type: int, range: [-1,2147483647], default: 10]
heuristics/veclendiving/freq = 5

# frequency offset for calling primal heuristic <veclendiving>
# [type: int, range: [0,2147483647], default: 4]
heuristics/veclendiving/freqofs = 4

# maximal depth level to call primal heuristic <veclendiving> (-1: no limit)
# [type: int, range: [-1,2147483647], default: -1]
heuristics/veclendiving/maxdepth = -1

# minimal relative depth to start diving
# [type: real, range: [0,1], default: 0]
heuristics/veclendiving/minreldepth = 0

# maximal relative depth to start diving
# [type: real, range: [0,1], default: 1]
heuristics/veclendiving/maxreldepth = 1

# maximal fraction of diving LP iterations compared to node LP iterations
# [type: real, range: [0,1.79769313486232e+308], default: 0.05]
heuristics/veclendiving/maxlpiterquot = 0.075

# additional number of allowed LP iterations
# [type: int, range: [0,2147483647], default: 1000]
heuristics/veclendiving/maxlpiterofs = 1500

# maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1], default: 0.8]
heuristics/veclendiving/maxdiveubquot = 0.8

# maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/veclendiving/maxdiveavgquot = 0

# maximal UBQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1], default: 0.1]
heuristics/veclendiving/maxdiveubquotnosol = 0.1

# maximal AVGQUOT when no solution was found yet (0.0: no limit)
# [type: real, range: [0,1.79769313486232e+308], default: 0]
heuristics/veclendiving/maxdiveavgquotnosol = 0

# use one level of backtracking if infeasibility is encountered?
# [type: bool, range: {TRUE,FALSE}, default: TRUE]
heuristics/veclendiving/backtrack = TRUE
